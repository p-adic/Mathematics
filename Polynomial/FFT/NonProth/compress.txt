#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Polynomial/FFT/NonProth/a_Body.hpp"
#else
#define PO Polynomial
#define FPS FormalPowerSeries

TE <TY INT> CE INT Log(INT N){INT AN = 0,pw = 1;WH(N > pw){pw <<= 1;AN++;}RE AN;}

TE <TY T,int EX_lim>CL Power3Power_CE{PU:T m_val[EX_lim];CE Power3Power_CE(CO T& t);CE CO T& OP[](CRI i)CO;CE CO T(&Get()CO)[EX_lim];};
TE <TY T,int EX_lim> CE Power3Power_CE<T,EX_lim>::Power3Power_CE(CO T& t):m_val(){T pw{t};for(uint EX = EX_lim - 1;EX + 1 > 0;EX--){m_val[EX]= -pw;m_val[EX]*= pw *= pw;}}TE <TY T,int EX_lim> CE CO T& Power3Power_CE<T,EX_lim>::OP[](CRI i)CO{AS(i < EX_lim);RE m_val[i];}TE <TY T,int EX_lim> CE CO T(&Power3Power_CE<T,EX_lim>::Get()CO)[EX_lim]{RE m_val;}

// PO
#define DC_OF_AR_FOR_PO(FUNC)IN PO<T> OP FUNC(PO<T> f)CO;IN PO<T> OP FUNC(T t)CO
#define DF_OF_AR_FOR_PO(FUNC,DEF)TE <TY T> IN PO<T> PO<T>::OP FUNC(PO<T> f)CO{RE MO(DEF);};TE <TY T> IN PO<T> PO<T>::OP FUNC(T t)CO{RE *TH FUNC PO<T>(MO(t));}
TE <TY T>CL PO{PU:VE<T> m_f;int m_SZ;IN PO();IN PO(CO PO<T>& f);IN PO(PO<T>&& f);IN PO(VE<T> f);IN PO(T t);IN PO(CRI i,T t);IN PO<T>& OP=(T n);IN PO<T>& OP=(PO<T> f);IN PO<T>& OP=(VE<T> f);IN CO T& OP[](CRI i)CO;IN T& OP[](CRI i);T OP()(CO T& t)CO;PO<T>& OP+=(CO PO<T>& f);PO<T>& OP-=(CO PO<T>& f);PO<T>& OP*=(PO<T> f);IN PO<T>& OP/=(CO PO<T>& f);PO<T>& OP/=(CO T& t);PO<T>& OP%=(CO PO<T>& f);PO<T>& OP%=(CO T& t);bool OP==(CO PO<T>& f)CO;bool OP==(CO T& t)CO;TE <TY P> IN bool OP!=(CO P& f)CO;DC_OF_AR_FOR_PO(+);IN PO<T> OP-()CO;DC_OF_AR_FOR_PO(-);DC_OF_AR_FOR_PO(*);IN PO<T> OP/(CO PO<T>& f)CO;IN PO<T> OP/(CO T& t)CO;IN PO<T> OP%(CO PO<T>& f)CO;IN PO<T> OP%(CO T& t)CO;IN CO VE<T>& GetCoefficient()CO NE;IN CRI SZ()CO NE;IN VO resize(CRI deg_plus)NE;int Valuation()CO NE;IN VO swap(PO<T>& f);IN VO swap(VE<T>& f);VO Reduce();VO TP(CRI N_trunc);ST PO<T> NaiveCN(PO<T> f0,CRI valuation0,CO PO<T>& f1,CRI valuation1,CRI N_trunc);ST PO<T> NaiveQuotient(PO<T> f0,CO PO<T>& f1);ST PO<T> NaiveResidue(PO<T> f0,CO PO<T>& f1);ST IN CO PO<T>& zero();ST IN CO PO<T>& one();ST IN CO PO<T>& x();ST IN CO T& c_zero();ST IN CO T& c_one();ST IN CO T& c_minus_one();IN PO<T>& SignInvert();};

// FPS
TE <TY T>CL FPS:PU PO<T>{PU:int m_N;IN FPS(CRI N = 0);IN FPS(CO FPS<T>& f);IN FPS(FPS<T>&& f);IN FPS(CRI N,T t);IN FPS(CRI N,CO PO<T>& f);IN FPS(CRI N,PO<T>&& f);IN FPS(CRI N,VE<T>&& f);IN FPS(CRI N,CRI i,T t);IN FPS<T>& OP=(FPS<T> f);IN FPS<T>& OP=(T n);IN FPS<T>& OP=(PO<T> f);IN FPS<T>& OP+=(CO T& t);FPS<T>& OP+=(CO PO<T>& f);IN FPS<T>& OP+=(CO FPS<T>& f);IN FPS<T>& OP-=(CO T& t);FPS<T>& OP-=(CO PO<T>& f);IN FPS<T>& OP-=(CO FPS<T>& f);IN FPS<T>& OP*=(CO T& t);FPS<T>& OP*=(PO<T> f);IN FPS<T>& OP*=(FPS<T> f);IN FPS<T>& OP/=(CO T& t);IN FPS<T>& OP/=(CO FPS<T>& t);TE <TY P> IN FPS<T> OP+(CO P& f)CO;IN FPS<T> OP-()CO;TE <TY P> IN FPS<T> OP-(CO P& f)CO;TE <TY P> IN FPS<T> OP*(CO P& f)CO;TE <TY P> IN FPS<T> OP/(CO P& f)CO;FPS<T> Inverse()CO;IN VO SetTruncation(CRI N)NE;IN CRI GetTruncation()CO NE;IN FPS<T>& TruncateInitial(CRI N)NE;IN FPS<T>& TruncateFinal(CRI N)NE;};

// FFT
#define PS_FOR_FFT_BODY(MOD,LE,PR,IPR,TYPE)ST_AS((TYPE::DeRP(PR)*= TYPE::DeRP(IPR))== TYPE::DeRP(1));TE <> CE CO uint LimitOfPowerForFFT<TYPE> = LE - 1;TE <> IN CO TYPE(&PrimitiveRootOfTwoForFFT()NE)[LimitOfPowerForFFT<TYPE>]{ST CE Power3Power_CE<TYPE,LimitOfPowerForFFT<TYPE>> PRT{PR};ST_AS(PRT.m_val[0]== TYPE::DeRP(1));RE PRT.Get();}TE <> IN CO TYPE(&InversePrimitiveRootOfTwoForFFT()NE)[LimitOfPowerForFFT<TYPE>]{ST CE Power3Power_CE<TYPE,LimitOfPowerForFFT<TYPE>> IPRT{IPR};ST_AS(IPRT.m_val[0]== TYPE::DeRP(1)&&(TYPE::DeRP(PR)*= TYPE::DeRP(IPR))== TYPE::DeRP(1));RE IPRT.Get();}TE <> IN PO<TYPE>& PO<TYPE>::OP*=(PO<TYPE> f){CO int SZ = m_SZ + f.m_SZ - 1;RE *TH = FFTCN(MO(*TH),MO(f),SZ);}TE <> IN PO<TYPE>& PO<TYPE>::OP/=(CO PO<TYPE>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();if(m_SZ < f.m_SZ){RE *TH = zero();}RE *TH = FFTQuotient(MO(*TH),f);}TE <> IN PO<TYPE>& PO<TYPE>::OP%=(CO PO<TYPE>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();RE *TH = FFTResidue(MO(*TH),f);}
#define PS_FOR_FFT(MOD,LE,PR,IPR,MINT)PS_FOR_FFT_BODY(MOD,LE,PR,IPR,MINT<MOD>)
TE <TY T> CE CO int LimitOfPowerForFFT;TE <TY T> IN CO T(&PrimitiveRootOfTwoForFFT()NE)[LimitOfPowerForFFT<T>];TE <TY T> IN CO T(&InversePrimitiveRootOfTwoForFFT()NE)[LimitOfPowerForFFT<T>];
TE <TY T>VO CooleyTukey(VE<T>& f,CRI N_shift,CRI N_input_start,CRI N_input_lim,CRI N_trunc,CRI two_pw,CRI EX,CO T(&PRT)[LimitOfPowerForFFT<T>]){AS(N_input_lim - N_input_start <= two_pw);CO int N_zero = N_shift + N_input_start,le = N_zero + two_pw;AS(N_zero <= N_trunc);CO int N_input_final = min(N_input_start + two_pw,int(f.SZ()));for(int i = N_input_lim;i < N_input_final;i++){f[i]= T{};}WH(int(f.SZ())< le){f.push_back(T{});}ST VE<int> bit_reverse[32]={VE<int>(1)};ST int e_next = 1;ST int two_pw_next = 1;ST int two_pw_next2 = 2;ST VE<int>* p_bit_reverse_prev = bit_reverse;ST VE<int>* p_bit_reverse_curr = p_bit_reverse_prev + 1;WH(e_next <= EX){*p_bit_reverse_curr = VE<int>(two_pw_next2);int* p_bit_reverse_curr_i = &((*p_bit_reverse_curr)[0]);int* p_bit_reverse_curr_i_plus = p_bit_reverse_curr_i + two_pw_next;int* p_bit_reverse_prev_i = &((*p_bit_reverse_prev)[0]);for(int i = 0;i < two_pw_next;i++){(*(p_bit_reverse_curr_i_plus++)= *(p_bit_reverse_curr_i++)= *(p_bit_reverse_prev_i++)* 2)+= 1;}e_next++;swap(two_pw_next,two_pw_next2);two_pw_next2 *= 4;p_bit_reverse_prev++;p_bit_reverse_curr++;}CO VE<int>& bit_reverse_EX = bit_reverse[EX];int bit_num = 0;CO int* p_bit_num_reverse = &(bit_reverse_EX[bit_num]);WH(bit_num < two_pw){if(*p_bit_num_reverse < bit_num){swap(f[*p_bit_num_reverse + N_input_start],f[bit_num + N_input_start]);}bit_num++;p_bit_num_reverse++;}CO T& one = PRT[0];T zeta,diff;int i,j,j_lim,two_pw_curr = 1,two_pw_curr_2 = 2;WH(two_pw_curr < two_pw){CO int N_input_final_curr = N_input_start + two_pw_curr;bit_num = 0;i = 0;zeta = one;WH(i < two_pw){j = i;j_lim = i + two_pw_curr;WH(j < j_lim){diff = f[j + N_input_start]- f[j + N_input_final_curr];f[j + N_input_start]+= f[j + N_input_final_curr];f[j + N_input_final_curr]= zeta * diff;j++;}bit_num++;i += two_pw_curr_2;j = 0;WH(true){if(((bit_num >> j)& 1)== 1){zeta *= PRT[j+1];break;}j++;}}two_pw_curr <<= 1;two_pw_curr_2 <<= 1;}if(N_trunc < le){f.resize(N_trunc);}if(N_shift > 0){for(int i = N_trunc - 1;i >= N_zero;i--){f[i]= MO(f[i - N_shift]);}for(int i = N_zero - 1;i >= N_input_start;i--){f[i]= T{};}}RE;}TE <TY T> IN VO FFT(VE<T>& f,CRI N_input_start,CRI N_input_lim,CRI two_pw,CRI EX){CooleyTukey<T>(f,0,N_input_start,N_input_lim,N_input_start + two_pw,two_pw,EX,PrimitiveRootOfTwoForFFT<T>());}TE <TY T> IN VO IFFT(VE<T>& f,CRI N_shift,CRI N_input_start,CRI N_input_lim,CRI N_trunc,CRI two_pw,CO T& two_pw_inv,CRI EX){CooleyTukey<T>(f,N_shift,N_input_start,N_input_lim,N_trunc,two_pw,EX,InversePrimitiveRootOfTwoForFFT<T>());CO int SZ = f.SZ();for(int i = N_shift + N_input_start;i < SZ;i++){f[i]*= two_pw_inv;}}TE <TY T>PO<T> FFTCN(PO<T> f0,PO<T> f1,CRI N_trunc){f0.Reduce();if(f0.m_SZ == 0){RE MO(f0);}f1.Reduce();if(f1.m_SZ == 0){RE MO(f1);}AS(f0.m_SZ <= N_trunc);CO int valuation0 = f0.Valuation();CO int valuation1 = f1.Valuation();if(N_trunc <= valuation0 + valuation1){RE f0.zero();}CO int le0 = f0.m_SZ - valuation0;CO int le1 = min(f1.m_SZ,N_trunc)- valuation1;CO int le = le0 + le1 - 1;CO int EX = Log(le);if(min(le0,le1)<= EX){RE f0.NaiveCN(MO(f0),valuation0,MO(f1),valuation1,min(f0.m_SZ + f1.m_SZ - 1,N_trunc));}CO int two_pw = 1 << EX;FFT(f0.m_f,valuation0,f0.m_SZ,two_pw,EX);FFT(f1.m_f,valuation1,valuation1 + le1,two_pw,EX);for(int i = 0;i < two_pw;i++){f0.m_f[i + valuation0]*= f1.m_f[i + valuation1];}IFFT(f0.m_f,valuation1,valuation0,valuation0 + two_pw,N_trunc,two_pw,f0.c_one()/ two_pw,EX);f0.m_SZ = f0.m_f.SZ();RE MO(f0);}TE <TY T>PO<T> FFTQuotient(PO<T> f0,PO<T> f1){AS(f1.m_SZ > 0 && f1[f1.m_SZ-1]!= f0.c_zero());if(f0.m_SZ < f1.m_SZ){RE PO<T>::zero();}CO int f0_TP_SZ = f0.m_SZ - f1.m_SZ + 1;CO int f1_TP_SZ = min(f0_TP_SZ,f1.m_SZ);f1.TP(f1_TP_SZ);CO FPS<T> f1_TP_inverse = FPS<T>(f0_TP_SZ,MO(f1)).Inverse();f0.TP(f0_TP_SZ);FPS<T> f0_TP{f0_TP_SZ,MO(f0)};f0_TP *= f1_TP_inverse;f0_TP.TP(f0_TP_SZ);RE f0_TP;}TE <TY T>PO<T> FFTResidue(PO<T> f0,CO PO<T>& f1){if(f0.m_SZ >= f1.m_SZ){f0 -=(f0 / f1)* f1;f0.Reduce();}RE MO(f0);}
PS_FOR_FFT(P,24,31,128805723,Mod);
PS_FOR_FFT(167772161,26,17,29606852,Mod);
PS_FOR_FFT(469762049,27,30,15658735,Mod);
PS_FOR_FFT(754974721,25,362,415027540,Mod);

// FPS
TE <TY T> IN FPS<T>::FPS(CRI N):PO<T>(),m_N(N){AS(m_N > 0);}TE <TY T> IN FPS<T>::FPS(CO FPS<T>& f):PO<T>(f),m_N(f.m_N){}TE <TY T> IN FPS<T>::FPS(FPS<T>&& f):PO<T>(MO(f.m_f)),m_N(f.m_N){}TE <TY T> IN FPS<T>::FPS(CRI N,T t):PO<T>(MO(t)),m_N(N){AS(m_N > 0);}TE <TY T> IN FPS<T>::FPS(CRI N,CO PO<T>& f):PO<T>(),m_N(N){AS(m_N > 0);TH->m_SZ = f.m_SZ < m_N?f.m_SZ:m_N;TH->m_f = VE<T>(TH->m_SZ);for(int i = 0;i < TH->m_SZ;i++){TH->m_f[i]= f.m_f[i];}}TE <TY T> IN FPS<T>::FPS(CRI N,PO<T>&& f):PO<T>(),m_N(N){if(f.m_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f.m_SZ > m_N){TruncateFinal(m_N);}}else{TH->m_f = VE<T>(m_N);for(int i = 0;i < m_N;i++){TH->m_f[i]= MO(f.m_f[i]);}TH->m_SZ = m_N;}}TE <TY T> IN FPS<T>::FPS(CRI N,VE<T>&& f):PO<T>(),m_N(N){AS(m_N > 0);CO int f_SZ = f.SZ();if(f_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f_SZ > m_N){TruncateFinal(m_N);}}else{TH->m_f = VE<T>(m_N);for(int i = 0;i < m_N;i++){TH->m_f[i]= MO(f[i]);}}}TE <TY T> IN FPS<T>::FPS(CRI N,CRI i,T t):PO<T>(),m_N(N){AS(m_N > 0);if(i < m_N?t != TH->c_zero():false){(*TH)[i]= MO(t);}}TE <TY T> IN FPS<T>& FPS<T>::OP=(FPS<T> f){PO<T>::OP=(MO(f.m_f));m_N = f.m_N;RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP=(T n){PO<T>::OP=(MO(n));RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP=(PO<T> f){RE OP=(FPS<T>(m_N,MO(f)));}TE <TY T> IN FPS<T>& FPS<T>::OP+=(CO T& t){PO<T>::OP+=(t);RE *TH;}TE <TY T>FPS<T>& FPS<T>::OP+=(CO PO<T>& f){CRI SZ_f = m_N < f.m_SZ?m_N:f.m_SZ;CRI SZ = TH->m_SZ < SZ_f?TH->m_SZ:SZ_f;for(int i = 0;i < SZ;i++){TH->m_f[i]+= f.m_f[i];}for(int i = SZ;i < SZ_f;i++){TH->m_f.push_back(f.m_f[i]);}TH->m_SZ = TH->m_f.SZ();RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP+=(CO FPS<T>& f){AS(m_N <= f.m_N);CO PO<T>& f_ref = f;RE OP+=(f_ref);}TE <TY T> IN FPS<T>& FPS<T>::OP-=(CO T& t){PO<T>::OP-=(t);RE *TH;}TE <TY T>FPS<T>& FPS<T>::OP-=(CO PO<T>& f){CRI SZ_f = m_N < f.m_SZ?m_N:f.m_SZ;CRI SZ = TH->m_SZ < SZ_f?TH->m_SZ:SZ_f;for(int i = 0;i < SZ;i++){TH->m_f[i]-= f.m_f[i];}for(int i = SZ;i < SZ_f;i++){TH->m_f.push_back(-f.m_f[i]);}TH->m_SZ = TH->m_f.SZ();RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP-=(CO FPS<T>& f){AS(m_N <= f.m_N);CO PO<T>& f_ref = f;RE OP-=(f_ref);}TE <TY T> IN FPS<T>& FPS<T>::OP*=(CO T& t){PO<T>::OP*=(t);RE *TH;}TE <TY T>FPS<T>& FPS<T>::OP*=(PO<T> f){*TH = FFTCN(forward<PO<T>>(*TH),MO(f),m_N);RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP*=(FPS<T> f){AS(m_N <= f.m_N);RE OP*=(forward<PO<T>>(f));}TE <TY T> IN FPS<T>& FPS<T>::OP/=(CO T& t){PO<T>::OP/=(t);RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::OP/=(CO FPS<T>& f){AS(m_N <= f.m_N);RE OP*=(m_N == f.m_N?Inverse(f):Inverse(FPS<T>(m_N,f)));}TE <TY T> TE <TY P> IN FPS<T> FPS<T>::OP+(CO P& f)CO{RE MO(FPS<T>(*TH)+= f);}TE <TY T> IN FPS<T> FPS<T>::OP-()CO{RE MO(FPS<T>(m_N)-= *TH);}TE <TY T> TE <TY P> IN FPS<T> FPS<T>::OP-(CO P& f)CO{RE MO(FPS<T>(*TH)-= f);}TE <TY T> TE <TY P> IN FPS<T> FPS<T>::OP*(CO P& f)CO{RE MO(FPS<T>(*TH)*= f);}TE <TY T> TE <TY P> IN FPS<T> FPS<T>::OP/(CO P& f)CO{RE MO(FPS<T>(*TH)/= f);}TE <TY T>FPS<T> FPS<T>::Inverse()CO{AS(TH->m_SZ > 0 && TH->m_f[0]!= TH->c_zero());CO PO<T>& TH_ref = *TH;int pw;int pw_2 = 1;FPS<T> f_inv{pw_2,TH->c_one()/ TH->m_f[0]};WH(pw_2 < m_N){pw = pw_2;pw_2 <<= 1;f_inv.SetTruncation(pw_2);auto temp = f_inv * TH_ref;temp[0]--;temp *= f_inv;for(int i = pw;i < pw_2;i++){f_inv[i]-= temp[i];}}f_inv.SetTruncation(m_N);RE f_inv;}TE <TY T> IN VO FPS<T>::SetTruncation(CRI N)NE{if(N < m_N){TruncateFinal(N);}m_N = N;}TE <TY T> IN CRI FPS<T>::GetTruncation()CO NE{RE m_N;}TE <TY T> IN FPS<T>& FPS<T>::TruncateInitial(CRI N)NE{CRI SZ = N < TH->m_SZ?N:TH->m_SZ;for(int i = 0;i < SZ;i++){TH->m_f[i]= 0;}RE *TH;}TE <TY T> IN FPS<T>& FPS<T>::TruncateFinal(CRI N)NE{WH(TH->m_SZ > N){TH->m_f.pop_back();TH->m_SZ--;}RE *TH;}TE <TY T>FPS<T> Differential(CO FPS<T>& f){auto& SZ = f.SZ();auto& N = f.GetTruncation();if(SZ < 1){RE FPS<T>(1 < N?N - 1:1);}VE<T> df(SZ - 1);for(int i = 1;i < SZ;i++){df[i - 1]= f[i]* i;}RE FPS<T>(1 < N?N - 1:1,MO(df));}TE <TY T>FPS<T> Differential(CRI n,CO FPS<T>& f){if(n == 0){RE f;}if(n == 1){RE Differential<T>(f);}auto& SZ = f.SZ();auto& N = f.GetTruncation();if(SZ < n){RE FPS<T>(n < N?N - n:1);}VE<T> df(SZ - n);T coef = T::Factorial(n),numer = n,denom = 0;for(int i = n;i < SZ;i++){df[i - n]= f[i]* coef;(coef *= ++numer)/= ++denom;}RE FPS<T>(n < N?N - n:1,MO(df));}TE <TY T>FPS<T> ShiftedIntegral(CRI n,CO FPS<T>& f,CRI shift){auto& SZ = f.SZ();auto& N = f.GetTruncation();if(SZ + n < shift){RE FPS<T>{N + n > shift?N + n - shift:1};}VE<T> F(SZ + n - shift);if(n == 0){for(int i = shift;i < SZ;i++){F[i - shift]= f[i];}}else if(n == 1){T denom = 0;for(int i = shift > 0?shift - 1:0;i < SZ;i++){F[i + 1 - shift]= f[i]/ ++denom;}}else{T coef = T::FactorialInverse(n),numer = 0,denom = n;for(int i = shift > n?shift - n:0;i < SZ;i++){F[i + n - shift]= f[i]* coef;(coef *= ++numer)/= ++denom;}}RE FPS<T>(N + n - shift,MO(F));}TE <TY T> IN FPS<T> Integral(CO FPS<T>& f){RE ShiftedIntegral<T>(1,f,0);}TE <TY T> IN FPS<T> Integral(CRI n,CO FPS<T>& f){RE ShiftedIntegral<T>(n,f,0);}TE <TY T>FPS<T> Exp(CO FPS<T>& f){AS(f[0]== f.c_zero());CRI N = f.GetTruncation();int pw;int pw_2 = 1;FPS<T> f_exp{pw_2,f.c_one()};WH(pw_2 < N){pw = pw_2;pw_2 *= 2;f_exp.SetTruncation(pw_2);auto temp = Differential<T>(f_exp);temp /= f_exp;temp = ShiftedIntegral(temp,pw);for(int i = 0;i < pw;i++){temp[i]-= f[i | pw];}temp *= f_exp;for(int i = 0;i < pw;i++){f_exp[i|pw]-= temp[i];}}f_exp.SetTruncation(N);RE f_exp;}TE <TY T> IN FPS<T> Log(CO FPS<T>& f){AS(f[0]== f.c_one());RE Integral<T>(Differential<T>(f)/= f);}

// PO
TE <TY T> IN PO<T>::PO():m_f(),m_SZ(0){}TE <TY T> IN PO<T>::PO(CO PO<T>& f):m_f(f.m_f),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(PO<T>&& f):m_f(MO(f.m_f)),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(VE<T> f):m_f(MO(f)),m_SZ(m_f.SZ()){}TE <TY T> IN PO<T>::PO(T t):PO(){if(t != c_zero()){OP[](0)= MO(t);}}TE <TY T> IN PO<T>::PO(CRI i,T t):PO(){if(t != c_zero()){OP[](i)= MO(t);}}TE <TY T> IN PO<T>& PO<T>::OP=(T n){m_f.clear();m_SZ = 0;OP[](0)= MO(n);RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(PO<T> f){m_f = MO(f.m_f);m_SZ = f.m_SZ;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(VE<T> f){m_f = MO(f);m_SZ = m_f.SZ();RE *TH;}TE <TY T> IN CO T& PO<T>::OP[](CRI i)CO{RE m_SZ <= i?c_zero():m_f[i];}TE <TY T> IN T& PO<T>::OP[](CRI i){if(m_SZ <= i){CO T& z = c_zero();WH(m_SZ <= i){m_f.push_back(z);m_SZ++;}}RE m_f[i];}TE <TY T> T PO<T>::OP()(CO T& t)CO{T AN =(*TH)[0];T t_pw = c_one();for(int d = 1;d < m_SZ;d++){AN += m_f[d]*(t_pw *= t);}RE AN;}TE <TY T>PO<T>& PO<T>::OP+=(CO PO<T>& f){if(m_SZ < f.m_SZ){for(int i = 0;i < m_SZ;i++){m_f[i]+= f.m_f[i];}for(int i = m_SZ;i < f.m_SZ;i++){m_f.push_back(f.m_f[i]);}m_SZ = f.m_SZ;}else{for(int i = 0;i < f.m_SZ;i++){m_f[i]+= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP-=(CO PO<T>& f){if(m_SZ < f.m_SZ){for(int i = 0;i < m_SZ;i++){m_f[i]-= f.m_f[i];}for(int i = m_SZ;i < f.m_SZ;i++){m_f.push_back(- f.m_f[i]);}m_SZ = f.m_SZ;}else{for(int i = 0;i < f.m_SZ;i++){m_f[i]-= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP/=(CO T& t){if(t == c_one()){RE *TH;}CO T t_inv{c_one()/ t};for(int i = 0;i < m_SZ;i++){OP[](i)*= t_inv;}RE *TH;}TE <TY T>PO<T>& PO<T>::OP%=(CO T& t){if(t == c_one()){RE *TH = zero();}for(int i = 0;i < m_SZ;i++){m_f[i]%= t;}RE *TH;}TE <TY T>bool PO<T>::OP==(CO PO<T>& f)CO{CRI SZ0 = SZ();CRI SZ1 = f.SZ();CRI SZ_max = SZ0 < SZ1?SZ1:SZ0;for(int i = 0;i < SZ_max;i++){if(OP[](i)!= f[i]){RE false;}}RE true;}TE <TY T>bool PO<T>::OP==(CO T& t)CO{CRI SZ_max = SZ();CO T& zero = PO<T>::c_zero();for(int i = 1;i < SZ_max;i++){if(m_f[i]!= zero){RE false;}}RE OP[](0)== t;}TE <TY T> TE<TY P> IN bool PO<T>::OP!=(CO P& f)CO{RE !(*TH == f);}DF_OF_AR_FOR_PO(+,f += *TH);TE <TY T> IN PO<T>& PO<T>::SignInvert(){Reduce();for(auto& fi:m_f){fi = -fi;}RE *TH;}TE <TY T> IN PO<T> PO<T>::OP-()CO{RE MO(PO<T>(*TH).SignInvert());}DF_OF_AR_FOR_PO(-,f.SignInvert()+= *TH);DF_OF_AR_FOR_PO(*,f *= *TH);TE <TY T> IN PO<T> PO<T>::OP/(CO T& t)CO{RE MO(PO<T>(*TH)/= t);}TE <TY T> IN PO<T> PO<T>::OP/(CO PO<T>& f)CO{RE MO(PO<T>(*TH)/= f);}TE <TY T> IN PO<T> PO<T>::OP%(CO T& t)CO{RE MO(PO<T>(*TH)%= t);}TE <TY T> IN PO<T> PO<T>::OP%(CO PO<T>& f)CO{RE MO(PO<T>(*TH)%= f);}TE <TY T> IN CO VE<T>& PO<T>::GetCoefficient()CO NE{RE m_f;}TE <TY T> IN CRI PO<T>::SZ()CO NE{RE m_SZ;}TE <TY T> IN VO PO<T>::resize(CRI deg_plus)NE{m_f.resize(m_SZ = deg_plus);}TE <TY T>int PO<T>::Valuation()CO NE{for(int i = 0;i < m_SZ;i++){if(m_f[i]!= c_zero()){RE i;}}RE -1;}TE <TY T> IN VO PO<T>::swap(PO<T>& f){m_f.swap(f.m_f);swap(m_SZ,f.m_SZ);}TE <TY T> IN VO PO<T>::swap(VE<T>& f){m_f.swap(f);m_SZ = m_f.SZ();}TE <TY T>VO PO<T>::Reduce(){CO T& z = c_zero();WH(m_SZ > 0 && m_f[m_SZ - 1]== z){m_f.pop_back();m_SZ--;}RE;}TE <TY T>VO PO<T>::TP(CRI N_trunc){WH(N_trunc > m_SZ){m_f.push_back(c_zero());m_SZ++;}CO int N_half = min(N_trunc,(m_SZ + 1)/ 2);for(int d = 0;d < N_half;d++){::swap(m_f[d],m_f[m_SZ - 1 - d]);}m_f.resize(N_trunc);m_SZ = N_trunc;RE;}TE <TY T> IN CO PO<T>& PO<T>::zero(){ST CO PO<T> z{};RE z;}TE <TY T> IN CO PO<T>& PO<T>::one(){ST CO PO<T> o{c_one()};RE o;}TE <TY T> IN CO PO<T>& PO<T>::x(){ST CO PO<T> f{1,c_one()};RE f;}TE <TY T> IN CO T& PO<T>::c_zero(){ST CO T z{0};RE z;}TE <TY T> IN CO T& PO<T>::c_one(){ST CO T o{1};RE o;}TE <TY T> IN CO T& PO<T>::c_minus_one(){ST CO T m{-1};RE m;}TE <TY T>PO<T> Differential(CRI n,CO PO<T>& f){CRI SZ = f.SZ();if(SZ < n){RE PO<T>::zero();}VE<T> df(SZ - n);T coef = T::Factorial(n);int i = n;WH(i < SZ){df[i - n]= f[i]* coef;i++;(coef *= i)/=(i - n);}RE PO<T>(MO(df));}
TE <TY T>PO<T> PO<T>::NaiveCN(PO<T> f0,CRI valuation0,CO PO<T>& f1,CRI valuation1,CRI N_trunc){CO int SZ0 = f0.SZ();AS(0 <= valuation0 && valuation0 < SZ0);CO int SZ1 = f1.SZ();AS(0 <= valuation1 && valuation1 < SZ1);CO int i_ulim = min(SZ0,N_trunc - valuation1);for(int i = i_ulim - 1;i >= valuation0;i--){CO T f0i = f0[i];f0[i]*= f1[0];CO int j_ulim = min(SZ1,N_trunc - i),j_min = max(valuation1,1);for(int j = j_ulim - 1;j >= j_min;j--){f0[i+j]+= f0i * f1[j];}}RE MO(f0);}
// “ÁŽê‰»‚Å•sŽg—p
TE <TY T>PO<T> PO<T>::NaiveQuotient(PO<T> f0,CO PO<T>& f1){CO int diff = f1.m_SZ - f0.m_SZ;CO T r = f0[f0.m_SZ-1]/ f1[f1.m_SZ-1];f0.m_f.pop_back();f0.m_SZ--;f0.Reduce();for(int i = 0;i < f0.m_SZ;i++){f0[i]-= r * f1[i + diff];}f0.Reduce();f0 = NaiveQuotient(MO(f0),f1);f0[diff]= r;RE MO(f0);}TE <TY T>PO<T> PO<T>::NaiveResidue(PO<T> f0,CO PO<T>& f1){if(f0.m_SZ < f1.m_SZ){RE MO(f0);}CO int diff = f1.m_SZ - f0.m_SZ;CO T r = f0[f0.m_SZ-1]/ f1[f1.m_SZ-1];f0.m_f.pop_back();f0.m_SZ--;f0.Reduce();for(int i = 0;i < f0.m_SZ;i++){f0[i]-= r * f1[i + diff];}f0.Reduce();RE NaiveQuotient(MO(f0),f1);}TE <TY T>PO<T>& PO<T>::OP*=(PO<T> f){Reduce();if(m_SZ == 0){RE *TH;}f.Reduce();if(f.m_SZ == 0){RE *TH = MO(f);}CO int valuation0 = TH->Valuation();CO int valuation1 = f.Valuation();CO int le0 = m_SZ - valuation0;CO int le1 = f.m_SZ - valuation1;CO int SZ = m_SZ + f.m_SZ - 1;m_f = NaiveCN(MO(*TH),valuation0,f,valuation1,SZ);m_SZ = m_f.SZ();RE *TH;}TE <TY T>PO<T>& PO<T>::OP/=(CO PO<T>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();if(m_SZ < f.m_SZ){RE *TH = zero();}RE *TH = NaiveQuotient(MO(*TH),f);}TE <TY T>PO<T>& PO<T>::OP%=(CO PO<T>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();RE *TH = NaiveResidue(MO(*TH),f);}

// NonProth
#define DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(TYPE,MINT,REPRE)TE <> IN PO<TYPE>& PO<TYPE>::OP*=(PO<TYPE> f){RE *TH = NonProthFFTCN<TYPE,MINT>(*TH,f,REPRE);}TE <> IN FPS<TYPE>& FPS<TYPE>::OP*=(PO<TYPE> f){RE *TH = FPS<TYPE>(m_N,NonProthFFTCN<TYPE,MINT>(*TH,f,REPRE));}
#define DF_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MOD,MINT)DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MINT<MOD>,MINT,[](CO MINT<MOD>& n)->CRUI{RE n.RP();});
#define DF_OF_PS_OF_MU_OF_PO_NON_MOD(INT)DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(INT,Mod,[](CO INT& n)-> CO INT&{RE n;});
TE <TY T,TE <uint> TY MINT,TY REPRE>PO<T> NonProthFFTCN(CO PO<T>& f0,CO PO<T>& f1,REPRE repre){CRI SZ0 = f0.SZ();if(SZ0 == 0){RE MO(f0);}CRI SZ1 = f1.SZ();if(SZ1 == 0){RE MO(f1);}CE uint P0 = 167772161;CE uint P1 = 469762049;CE uint P2 = P;US M0 = MINT<P0>;US M1 = MINT<P1>;US M2 = MINT<P2>;VE<M0> v0(SZ0);VE<M1> v1(SZ0);VE<M2> v2(SZ0);for(int d = 0;d < SZ0;d++){auto&& f0_d = repre(f0[d]);v0[d]= f0_d;v1[d]= f0_d;v2[d]= f0_d;}VE<M0> w0(SZ1);VE<M1> w1(SZ1);VE<M2> w2(SZ1);for(int d = 0;d < SZ1;d++){auto&& f1_d = repre(f1[d]);w0[d]= f1_d;w1[d]= f1_d;w2[d]= f1_d;}PO<M0> f0_copy0{MO(v0)};PO<M1> f0_copy1{MO(v1)};PO<M2> f0_copy2{MO(v2)};PO<M0> f1_copy0{MO(w0)};PO<M1> f1_copy1{MO(w1)};PO<M2> f1_copy2{MO(w2)};f0_copy0 *= f1_copy0;f0_copy1 *= f1_copy1;f0_copy2 *= f1_copy2;CE T P0_mod_M{P0};CE T P01_mod_M = T(P1)* P0_mod_M;CE M1 P0_mod_P1_inv = M1::DeRP(104391568);CE M2 P0_mod_P2 = M2::DeRP(P0);CE M2 P01_mod_P2_inv = M2::DeRP(575867115);ST_AS((M1::DeRP(P0)*= P0_mod_P1_inv)== M1::DeRP(1));ST_AS((M2::DeRP(P0)*= M2::DeRP(P1)*= P01_mod_P2_inv)== M2::DeRP(1));CO int SZ = SZ0 + SZ1 - 1;PO<T> AN{VE<T>(SZ)};for(int d = 0;d < SZ;d++){auto&& c0 = f0_copy0[d].RP();auto&& c1 =((f0_copy1[d]-= c0)*= P0_mod_P1_inv).RP();auto&& c2 =((f0_copy2[d]-= P0_mod_P2 * c1 + c0)*= P01_mod_P2_inv).RP();AN[d]= P01_mod_M * c2 + P0_mod_M * c1 + c0;}AN.Reduce();RE AN;}
DF_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(1000000007,Mod);
DF_OF_PS_OF_MU_OF_PO_NON_MOD(ll);
DF_OF_PS_OF_MU_OF_PO_NON_MOD(ull);
#define DEFINITION_OF_PARTIAL_SPECIALISATION_OF_MULTIPLICATION_OF_POLYNOMIAL_ARBITRARY_MOD(MOD,MINT)DF_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MOD,MINT);
#endif
