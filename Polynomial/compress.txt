#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Polynomial/a_Body.hpp"
#else
// ../FormalPowerSeries/compress.txtÇ©ÇÁ
// ëSÇƒÇÃFFTä÷åWÇçÌèúÇµÇΩÇ‡ÇÃÅB
#define PO Polynomial

#define DC_OF_AR_FOR_PO(FUNC)IN PO<T> OP FUNC(PO<T> f)CO;IN PO<T> OP FUNC(T t)CO
#define DF_OF_AR_FOR_PO(FUNC,DEF)TE <TY T> IN PO<T> PO<T>::OP FUNC(PO<T> f)CO{RE MO(DEF);};TE <TY T> IN PO<T> PO<T>::OP FUNC(T t)CO{RE *TH FUNC PO<T>(MO(t));}
TE <TY T>CL PO{PU:VE<T> m_f;int m_SZ;IN PO();IN PO(CO PO<T>& f);IN PO(PO<T>&& f);IN PO(VE<T> f);IN PO(T t);IN PO(CRI i,T t);IN PO<T>& OP=(T n);IN PO<T>& OP=(PO<T> f);IN PO<T>& OP=(VE<T> f);IN CO T& OP[](CRI i)CO;IN T& OP[](CRI i);T OP()(CO T& t)CO;PO<T>& OP+=(CO PO<T>& f);PO<T>& OP-=(CO PO<T>& f);PO<T>& OP*=(PO<T> f);IN PO<T>& OP/=(CO PO<T>& f);PO<T>& OP/=(CO T& t);PO<T>& OP%=(CO PO<T>& f);PO<T>& OP%=(CO T& t);bool OP==(CO PO<T>& f)CO;bool OP==(CO T& t)CO;TE <TY P> IN bool OP!=(CO P& f)CO;DC_OF_AR_FOR_PO(+);IN PO<T> OP-()CO;DC_OF_AR_FOR_PO(-);DC_OF_AR_FOR_PO(*);IN PO<T> OP/(CO PO<T>& f)CO;IN PO<T> OP/(CO T& t)CO;IN PO<T> OP%(CO PO<T>& f)CO;IN PO<T> OP%(CO T& t)CO;IN CO VE<T>& GetCoefficient()CO NE;IN CRI SZ()CO NE;IN VO resize(CRI deg_plus)NE;int Valuation()CO NE;IN VO swap(PO<T>& f);IN VO swap(VE<T>& f);VO Reduce();VO TP(CRI N_trunc);ST PO<T> NaiveCN(PO<T> f0,CRI valuation0,CO PO<T>& f1,CRI valuation1,CRI N_trunc);ST PO<T> NaiveQuotient(PO<T> f0,CO PO<T>& f1);ST PO<T> NaiveResidue(PO<T> f0,CO PO<T>& f1);ST IN CO PO<T>& zero();ST IN CO PO<T>& one();ST IN CO PO<T>& x();ST IN CO T& c_zero();ST IN CO T& c_one();ST IN CO T& c_minus_one();IN PO<T>& SignInvert();};

TE <TY T> IN PO<T>::PO():m_f(),m_SZ(0){}TE <TY T> IN PO<T>::PO(CO PO<T>& f):m_f(f.m_f),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(PO<T>&& f):m_f(MO(f.m_f)),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(VE<T> f):m_f(MO(f)),m_SZ(m_f.SZ()){}TE <TY T> IN PO<T>::PO(T t):PO(){if(t != c_zero()){OP[](0)= MO(t);}}TE <TY T> IN PO<T>::PO(CRI i,T t):PO(){if(t != c_zero()){OP[](i)= MO(t);}}TE <TY T> IN PO<T>& PO<T>::OP=(T n){m_f.clear();m_SZ = 0;OP[](0)= MO(n);RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(PO<T> f){m_f = MO(f.m_f);m_SZ = f.m_SZ;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(VE<T> f){m_f = MO(f);m_SZ = m_f.SZ();RE *TH;}TE <TY T> IN CO T& PO<T>::OP[](CRI i)CO{RE m_SZ <= i?c_zero():m_f[i];}TE <TY T> IN T& PO<T>::OP[](CRI i){if(m_SZ <= i){CO T& z = c_zero();WH(m_SZ <= i){m_f.push_back(z);m_SZ++;}}RE m_f[i];}TE <TY T> T PO<T>::OP()(CO T& t)CO{T AN =(*TH)[0];T t_pw = c_one();for(int d = 1;d < m_SZ;d++){AN += m_f[d]*(t_pw *= t);}RE AN;}TE <TY T>PO<T>& PO<T>::OP+=(CO PO<T>& f){if(m_SZ < f.m_SZ){for(int i = 0;i < m_SZ;i++){m_f[i]+= f.m_f[i];}for(int i = m_SZ;i < f.m_SZ;i++){m_f.push_back(f.m_f[i]);}m_SZ = f.m_SZ;}else{for(int i = 0;i < f.m_SZ;i++){m_f[i]+= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP-=(CO PO<T>& f){if(m_SZ < f.m_SZ){for(int i = 0;i < m_SZ;i++){m_f[i]-= f.m_f[i];}for(int i = m_SZ;i < f.m_SZ;i++){m_f.push_back(- f.m_f[i]);}m_SZ = f.m_SZ;}else{for(int i = 0;i < f.m_SZ;i++){m_f[i]-= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP/=(CO T& t){if(t == c_one()){RE *TH;}CO T t_inv{c_one()/ t};for(int i = 0;i < m_SZ;i++){OP[](i)*= t_inv;}RE *TH;}TE <TY T>PO<T>& PO<T>::OP%=(CO T& t){if(t == c_one()){RE *TH = zero();}for(int i = 0;i < m_SZ;i++){m_f[i]%= t;}RE *TH;}TE <TY T>bool PO<T>::OP==(CO PO<T>& f)CO{CRI SZ0 = SZ();CRI SZ1 = f.SZ();CRI SZ_max = SZ0 < SZ1?SZ1:SZ0;for(int i = 0;i < SZ_max;i++){if(OP[](i)!= f[i]){RE false;}}RE true;}TE <TY T>bool PO<T>::OP==(CO T& t)CO{CRI SZ_max = SZ();CO T& zero = PO<T>::c_zero();for(int i = 1;i < SZ_max;i++){if(m_f[i]!= zero){RE false;}}RE OP[](0)== t;}TE <TY T> TE<TY P> IN bool PO<T>::OP!=(CO P& f)CO{RE !(*TH == f);}DF_OF_AR_FOR_PO(+,f += *TH);TE <TY T> IN PO<T>& PO<T>::SignInvert(){Reduce();for(auto& fi:m_f){fi = -fi;}RE *TH;}TE <TY T> IN PO<T> PO<T>::OP-()CO{RE MO(PO<T>(*TH).SignInvert());}DF_OF_AR_FOR_PO(-,f.SignInvert()+= *TH);DF_OF_AR_FOR_PO(*,f *= *TH);TE <TY T> IN PO<T> PO<T>::OP/(CO T& t)CO{RE MO(PO<T>(*TH)/= t);}TE <TY T> IN PO<T> PO<T>::OP/(CO PO<T>& f)CO{RE MO(PO<T>(*TH)/= f);}TE <TY T> IN PO<T> PO<T>::OP%(CO T& t)CO{RE MO(PO<T>(*TH)%= t);}TE <TY T> IN PO<T> PO<T>::OP%(CO PO<T>& f)CO{RE MO(PO<T>(*TH)%= f);}TE <TY T> IN CO VE<T>& PO<T>::GetCoefficient()CO NE{RE m_f;}TE <TY T> IN CRI PO<T>::SZ()CO NE{RE m_SZ;}TE <TY T> IN VO PO<T>::resize(CRI deg_plus)NE{m_f.resize(m_SZ = deg_plus);}TE <TY T>int PO<T>::Valuation()CO NE{for(int i = 0;i < m_SZ;i++){if(m_f[i]!= c_zero()){RE i;}}RE -1;}TE <TY T> IN VO PO<T>::swap(PO<T>& f){m_f.swap(f.m_f);swap(m_SZ,f.m_SZ);}TE <TY T> IN VO PO<T>::swap(VE<T>& f){m_f.swap(f);m_SZ = m_f.SZ();}TE <TY T>VO PO<T>::Reduce(){CO T& z = c_zero();WH(m_SZ > 0 && m_f[m_SZ - 1]== z){m_f.pop_back();m_SZ--;}RE;}TE <TY T>VO PO<T>::TP(CRI N_trunc){WH(N_trunc > m_SZ){m_f.push_back(c_zero());m_SZ++;}CO int N_half = min(N_trunc,(m_SZ + 1)/ 2);for(int d = 0;d < N_half;d++){::swap(m_f[d],m_f[m_SZ - 1 - d]);}m_f.resize(N_trunc);m_SZ = N_trunc;RE;}TE <TY T> IN CO PO<T>& PO<T>::zero(){ST CO PO<T> z{};RE z;}TE <TY T> IN CO PO<T>& PO<T>::one(){ST CO PO<T> o{c_one()};RE o;}TE <TY T> IN CO PO<T>& PO<T>::x(){ST CO PO<T> f{1,c_one()};RE f;}TE <TY T> IN CO T& PO<T>::c_zero(){ST CO T z{0};RE z;}TE <TY T> IN CO T& PO<T>::c_one(){ST CO T o{1};RE o;}TE <TY T> IN CO T& PO<T>::c_minus_one(){ST CO T m{-1};RE m;}TE <TY T>PO<T> Differential(CRI n,CO PO<T>& f){CRI SZ = f.SZ();if(SZ < n){RE PO<T>::zero();}VE<T> df(SZ - n);T coef = T::Factorial(n);int i = n;WH(i < SZ){df[i - n]= f[i]* coef;i++;(coef *= i)/=(i - n);}RE PO<T>(MO(df));}
TE <TY T>PO<T> PO<T>::NaiveCN(PO<T> f0,CRI valuation0,CO PO<T>& f1,CRI valuation1,CRI N_trunc){CO int SZ0 = f0.SZ();AS(0 <= valuation0 && valuation0 < SZ0);CO int SZ1 = f1.SZ();AS(0 <= valuation1 && valuation1 < SZ1);CO int i_ulim = min(SZ0,N_trunc - valuation1);for(int i = i_ulim - 1;i >= valuation0;i--){CO T f0i = f0[i];f0[i]*= f1[0];CO int j_ulim = min(SZ1,N_trunc - i),j_min = max(valuation1,1);for(int j = j_ulim - 1;j >= j_min;j--){f0[i+j]+= f0i * f1[j];}}RE MO(f0);}

TE <TY T>PO<T> PO<T>::NaiveQuotient(PO<T> f0,CO PO<T>& f1){CO int diff = f1.m_SZ - f0.m_SZ;CO T r = f0[f0.m_SZ-1]/ f1[f1.m_SZ-1];f0.m_f.pop_back();f0.m_SZ--;f0.Reduce();for(int i = 0;i < f0.m_SZ;i++){f0[i]-= r * f1[i + diff];}f0.Reduce();f0 = NaiveQuotient(MO(f0),f1);f0[diff]= r;RE MO(f0);}TE <TY T>PO<T> PO<T>::NaiveResidue(PO<T> f0,CO PO<T>& f1){if(f0.m_SZ < f1.m_SZ){RE MO(f0);}CO int diff = f1.m_SZ - f0.m_SZ;CO T r = f0[f0.m_SZ-1]/ f1[f1.m_SZ-1];f0.m_f.pop_back();f0.m_SZ--;f0.Reduce();for(int i = 0;i < f0.m_SZ;i++){f0[i]-= r * f1[i + diff];}f0.Reduce();RE NaiveQuotient(MO(f0),f1);}TE <TY T>PO<T>& PO<T>::OP*=(PO<T> f){Reduce();if(m_SZ == 0){RE *TH;}f.Reduce();if(f.m_SZ == 0){RE *TH = MO(f);}CO int valuation0 = TH->Valuation();CO int valuation1 = f.Valuation();CO int le0 = m_SZ - valuation0;CO int le1 = f.m_SZ - valuation1;CO int SZ = m_SZ + f.m_SZ - 1;m_f = NaiveCN(MO(*TH),valuation0,f,valuation1,SZ);m_SZ = m_f.SZ();RE *TH;}TE <TY T>PO<T>& PO<T>::OP/=(CO PO<T>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();if(m_SZ < f.m_SZ){RE *TH = zero();}RE *TH = NaiveQuotient(MO(*TH),f);}TE <TY T>PO<T>& PO<T>::OP%=(CO PO<T>& f){AS(f.m_SZ > 0 && f[f.m_SZ-1]!= c_zero());Reduce();RE *TH = NaiveResidue(MO(*TH),f);}
#endif
