#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Algebra/Monoid/Semirng/Ring/Algebra/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U Power(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY MAGMA,TY U = inner_t<MAGMA>>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN AbstractRSet<R,U,O_U>& OP=(CO AbstractRSet<R,U,O_U>&)NE;IN U Action(CO R& r,U u);};TE <TY R,TY O_U,TY GROUP,TY U = inner_t<GROUP>>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY MAGMA,TY U> IN RegularRSet<MAGMA,U>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY O_U,TY GROUP,TY U> IN AbstractModule<R,O_U,GROUP,U>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>& AbstractRSet<R,U,O_U>::OP=(CO AbstractRSet<R,U,O_U>&)NE{RE *TH;}TE <TY MAGMA,TY U> IN U RegularRSet<MAGMA,U>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::Power(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY MONOID,TY SEMIGROUP,TY U = inner_t<MONOID>>CL VirtualSemirng{PU:VI U Sum(U u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(U u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY MONOID,TY SEMIGROUP,TY U = inner_t<MONOID>>CL AbstractSemirng:VI PU VirtualSemirng<MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(U u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(U u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY U>CL Semirng:PU AbstractSemirng<AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY MONOID,TY SEMIGROUP,TY U> IN AbstractSemirng<MONOID,SEMIGROUP,U>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY MONOID,TY SEMIGROUP,TY U> IN U AbstractSemirng<MONOID,SEMIGROUP,U>::Sum(U u0,CO U& u1){RE m_R0.Sum(MO(u0),u1);}TE <TY MONOID,TY SEMIGROUP,TY U> IN CO U& AbstractSemirng<MONOID,SEMIGROUP,U>::Zero()CO NE{RE m_R0.Zero();}TE <TY MONOID,TY SEMIGROUP,TY U> IN U AbstractSemirng<MONOID,SEMIGROUP,U>::Product(U u0,CO U& u1){RE m_R1.Product(MO(u0),u1);}TE <TY MONOID,TY SEMIGROUP,TY U> IN MONOID& AbstractSemirng<MONOID,SEMIGROUP,U>::AdditiveMonoid()NE{RE m_R0;}TE <TY MONOID,TY SEMIGROUP,TY U> IN SEMIGROUP& AbstractSemirng<MONOID,SEMIGROUP,U>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY GROUP,TY MONOID,TY U = inner_t<GROUP>>CL VirtualRing:VI PU VirtualSemirng<GROUP,MONOID>{PU:VI U Inverse(CO U& u)= 0;VI CO U& One()CO NE = 0;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY GROUP,TY MONOID,TY U = inner_t<GROUP>>CL AbstractRing:VI PU VirtualRing<GROUP,MONOID>,PU AbstractSemirng<GROUP,MONOID>{PU:IN AbstractRing(GROUP R0,MONOID R1);IN U Inverse(CO U& u);IN CO U& One()CO NE;};TE <TY U = ll>CL Ring:PU AbstractRing<AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(U one_U);};
TE <TY GROUP,TY MONOID,TY U> IN AbstractRing<GROUP,MONOID,U>::AbstractRing(GROUP R0,MONOID R1):AbstractSemirng<GROUP,MONOID>(MO(R0),MO(R1)){}TE <TY U> IN Ring<U>::Ring(U one_U):AbstractRing<AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(MO(one_U))){}TE <TY GROUP,TY MONOID,TY U> IN U AbstractRing<GROUP,MONOID,U>::Inverse(CO U& u){RE TH->m_R0.Inverse(u);}TE <TY GROUP,TY MONOID,TY U> IN CO U& AbstractRing<GROUP,MONOID,U>::One()CO NE{RE TH->m_R1.One();}TE <TY GROUP,TY MONOID,TY U> IN GROUP& VirtualRing<GROUP,MONOID,U>::AdditiveGroup()NE{RE TH->AdditiveMonoid();}TE <TY GROUP,TY MONOID,TY U> IN MONOID& VirtualRing<GROUP,MONOID,U>::MultiplicativeMonoid()NE{RE TH->MultiplicativeSemigroup();}

TE <TY R,TY GROUP,TY MONOID,TY U = inner_t<GROUP>>CL VirtualAlgebra:VI PU VirtualRSet<R,U>,VI PU VirtualRing<GROUP,MONOID>{PU:IN U Power(U u,CO R& r)= delete;};TE <TY R,TY GROUP,TY MONOID,TY O_U,TY U = inner_t<GROUP>>CL AbstractAlgebra:VI PU VirtualAlgebra<R,GROUP,MONOID>,PU AbstractRing<GROUP,MONOID>,PU AbstractRSet<R,U,O_U>{PU:O_U m_o_U;IN AbstractAlgebra(CO R& dummy,GROUP R0,MONOID R1,O_U o_U);US AbstractRing<GROUP,MONOID>::type;};TE <TY R,TY U>CL Algebra:VI PU VirtualAlgebra<R,AdditiveGroup<U>,MultiplicativeMonoid<U>>,PU Ring<U>{PU:IN Algebra(CO R& dummy,U one);US Ring<U>::type;IN U Action(CO R& r,U u);};
TE <TY R,TY GROUP,TY MONOID,TY O_U,TY U> IN AbstractAlgebra<R,GROUP,MONOID,O_U,U>::AbstractAlgebra(CO R& dummy,GROUP R0,MONOID R1,O_U o_U):AbstractRing<U,GROUP,MONOID>(U{},MO(R0),MO(R1)),AbstractRSet<R,U,O_U>(MO(o_U)){}TE <TY R,TY U> IN Algebra<R,U>::Algebra(CO R& dummy,U one):Ring<U>(MO(one)){}TE <TY R,TY U> IN U Algebra<R,U>::Action(CO R& r,U u){RE MO(u *= r);}
#endif
