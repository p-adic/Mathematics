#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Algebra/Monoid/Group/Module/Interval/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN AbstractRSet<R,U,O_U>& OP=(CO AbstractRSet<R,U,O_U>&)NE;IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>& AbstractRSet<R,U,O_U>::OP=(CO AbstractRSet<R,U,O_U>&){RE *TH;}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY R,TY ABEL_GROUP,TY U,TY R_SET>CL AbstractIntervalRSet:PU VirtualRSet<pair<R,R>,U>,PU R_SET{PU:ABEL_GROUP m_L;IN AbstractIntervalRSet(ABEL_GROUP L,R_SET M);IN U Action(CO pair<R,R>& lr,U u);};TE <TY ABEL_GROUP,TY R_SET> AbstractIntervalRSet(ABEL_GROUP,R_SET)-> AbstractIntervalRSet<inner_t<ABEL_GROUP>,ABEL_GROUP,inner_t<R_SET>,R_SET>;TE <TY R,TY U>CL IntervalModule:PU AbstractIntervalRSet<R,AdditiveGroup<R>,U,Module<R,U>>{PU:IN IntervalModule();};
TE <TY R,TY ABEL_GROUP,TY U,TY R_SET> IN AbstractIntervalRSet<R,ABEL_GROUP,U,R_SET>::AbstractIntervalRSet(ABEL_GROUP L,R_SET M):R_SET(MO(M)),m_L(MO(L)){ST_AS(is_same_v<R,inner_t<ABEL_GROUP>> && is_same_v<U,inner_t<R_SET>>);}TE <TY R,TY U> IntervalModule<R,U>::IntervalModule():AbstractIntervalRSet<R,AdditiveGroup<R>,U,Module<R,U>>(AdditiveGroup<R>(),Module<R,U>()){}TE <TY R,TY ABEL_GROUP,TY U,TY R_SET> IN U AbstractIntervalRSet<R,ABEL_GROUP,U,R_SET>::Action(CO pair<R,R>& lr,U u){RE R_SET::Action(m_L.Sum(lr.second,m_L.Inverse(lr.first)),MO(u));}
#endif

