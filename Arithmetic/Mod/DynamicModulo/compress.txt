#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/DynamicModulo/Debug/a_Body.hpp"
#else
// SetModulo( M , M_is_prime = false );
// M_is_primeÇ™trueÇÃéûÇÕinverseÇÃåvéZÇ™ÉÅÉÇâªçƒãAÇ≥ÇÍÇÈÅB

TE <TY INT1,TY INT2> CE INT1 Residue(INT1 n,CO INT2& M)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < M?n:n %= M);}
// TE <TY INT> IN INT ModularInverse(CO INT& base,ll c){AS(base > 0);ll a[2]={0,1 % base};INT b[2]={base,INT((c %= base)< 0?c += base:c)};WH(b[1]!= 0){CO INT q = b[0]/ b[1];(a[0]-= q * a[1]% base)< 0?a[0]+= base:a[0];b[0]-= q * b[1];swap(a[0],a[1]);swap(b[0],b[1]);}AS(b[0]== 1 &&(a[0]* c - 1)% base == 0);RE a[0];}

TE <int NUM> CL DynamicMods;TE <int NUM>CL COantsForDynamicMods{PU:COantsForDynamicMods()= delete;ST uint g_M;ST CE CO uint g_memory_bound = 2e6;ST uint g_memory_le;ST uint g_M_minus;ST bool g_M_is_prime;};
TE <int NUM> uint COantsForDynamicMods<NUM>::g_M = 0;TE <int NUM> uint COantsForDynamicMods<NUM>::g_memory_le = 0;TE <int NUM> uint COantsForDynamicMods<NUM>::g_M_minus = -1;TE <int NUM> bool COantsForDynamicMods<NUM>::g_M_is_prime = false;

#define SFINAE_FOR_DMOD enable_if_t<is_COructible_v<uint,decay_t<T>>>*
#define DC_OF_CM_FOR_DYNAMIC_MOD(OPR)IN bool OP OPR(CO DynamicMods<NUM>& n)CO NE
#define DC_OF_AR_FOR_DYNAMIC_MOD(OPR,EX)IN DynamicMods<NUM> OP OPR(DynamicMods<NUM> n)CO EX;
#define DF_OF_CM_FOR_DYNAMIC_MOD(OPR)TE <int NUM> IN bool DynamicMods<NUM>::OP OPR(CO DynamicMods<NUM>& n)CO NE{RE m_n OPR n.m_n;}
#define DF_OF_AR_FOR_DYNAMIC_MOD(OPR,EX,LEFT,OPR2)TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP OPR(DynamicMods<NUM> n)CO EX{RE MO(LEFT OPR2 ## = *TH);}TE <int NUM,TY T,SFINAE_FOR_DMOD = nullptr> IN DynamicMods<NUM> OP OPR(T n0,CO DynamicMods<NUM>& n1)EX{RE MO(DynamicMods<NUM>(MO(n0))OPR ## = n1);}
TE <int NUM>CL DynamicMods{PU:uint m_n;IN DynamicMods()NE;IN DynamicMods(CO DynamicMods<NUM>& n)NE;IN DynamicMods(DynamicMods<NUM>&& n)NE;TE <TY T,SFINAE_FOR_DMOD = nullptr> IN DynamicMods(T n)NE;IN DynamicMods<NUM>& OP=(DynamicMods<NUM> n)NE;IN DynamicMods<NUM>& OP+=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP-=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP*=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP/=(DynamicMods<NUM> n);IN DynamicMods<NUM>& OP^=(ll EX);IN DynamicMods<NUM>& OP<<=(ll n);IN DynamicMods<NUM>& OP>>=(ll n);IN DynamicMods<NUM>& OP++()NE;IN DynamicMods<NUM> OP++(int)NE;IN DynamicMods<NUM>& OP--()NE;IN DynamicMods<NUM> OP--(int)NE;DC_OF_CM_FOR_DYNAMIC_MOD(==);DC_OF_CM_FOR_DYNAMIC_MOD(!=);DC_OF_CM_FOR_DYNAMIC_MOD(<);DC_OF_CM_FOR_DYNAMIC_MOD(<=);DC_OF_CM_FOR_DYNAMIC_MOD(>);DC_OF_CM_FOR_DYNAMIC_MOD(>=);DC_OF_AR_FOR_DYNAMIC_MOD(+,NE);DC_OF_AR_FOR_DYNAMIC_MOD(-,NE);DC_OF_AR_FOR_DYNAMIC_MOD(*,NE);DC_OF_AR_FOR_DYNAMIC_MOD(/,);IN DynamicMods<NUM> OP^(ll EX)CO;IN DynamicMods<NUM> OP<<(ll n)CO;IN DynamicMods<NUM> OP>>(ll n)CO;IN DynamicMods<NUM> OP-()CO NE;IN VO swap(DynamicMods<NUM>& n)NE;IN CRUI RP()CO NE;ST IN DynamicMods<NUM> DeRP(uint n)NE;ST IN CO DynamicMods<NUM>& Factorial(CRL n);ST IN CO DynamicMods<NUM>& FactorialInverse(CRL n);ST IN DynamicMods<NUM> Combination(CRL n,CRL i);ST IN CO DynamicMods<NUM>& zero()NE;ST IN CO DynamicMods<NUM>& one()NE;ST IN CRUI GetModulo()NE;ST IN VO SetModulo(CRUI M,CO bool& M_is_prime = false)NE;IN DynamicMods<NUM>& SignInvert()NE;IN DynamicMods<NUM>& Invert();IN DynamicMods<NUM>& PPW(ll EX)NE;IN DynamicMods<NUM>& NNPW(ll EX)NE;ST IN CO DynamicMods<NUM>& Inverse(CRI n);ST IN CO DynamicMods<NUM>& TwoPower(CRI n);ST IN CO DynamicMods<NUM>& TwoPowerInverse(CRI n);US COants = COantsForDynamicMods<NUM>;};
US DynamicMod = DynamicMods<0>;
TE <int NUM> IN DynamicMods<NUM>::DynamicMods()NE:m_n(){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(CO DynamicMods<NUM>& n)NE:m_n(n.m_n){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(DynamicMods<NUM>&& n)NE:m_n(MO(n.m_n)){}TE <int NUM> TE <TY T,SFINAE_FOR_DMOD> IN DynamicMods<NUM>::DynamicMods(T n)NE:m_n(Residue(MO(n),COants::g_M)){}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP=(DynamicMods<NUM> n)NE{m_n = MO(n.m_n);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP+=(CO DynamicMods<NUM>& n)NE{(m_n += n.m_n)< COants::g_M?m_n:m_n -= COants::g_M;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP-=(CO DynamicMods<NUM>& n)NE{m_n < n.m_n?(m_n += COants::g_M)-= n.m_n:m_n -= n.m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP*=(CO DynamicMods<NUM>& n)NE{m_n = Residue(MO(ull(m_n)* n.m_n),COants::g_M);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP/=(DynamicMods<NUM> n){RE OP*=(n.Invert());}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::PPW(ll EX)NE{DynamicMods<NUM> pw{*TH};EX--;WH(EX != 0){(EX & 1)== 1?*TH *= pw:*TH;EX >>= 1;pw *= pw;}RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::NNPW(ll EX)NE{RE EX == 0?(m_n = 1,*TH):PPW(MO(EX));}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP^=(ll EX){if(EX < 0){Invert();EX *= -1;}RE NNPW(MO(EX));}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP<<=(ll n){RE *TH *=(n < 0 && -n < int(COants::g_memory_le))?TwoPowerInverse(- int(n)):(n >= 0 && n < int(COants::g_memory_le))?TwoPower(int(n)):DynamicMods<NUM>(2)^= MO(n);}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP>>=(ll n){RE *TH <<= MO(n *= -1);}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP++()NE{m_n < COants::g_M_minus?++m_n:m_n = 0;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP++(int)NE{DynamicMods<NUM> n{*TH};OP++();RE n;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP--()NE{m_n == 0?m_n = COants::g_M_minus:--m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP--(int)NE{DynamicMods<NUM> n{*TH};OP--();RE n;}DF_OF_CM_FOR_DYNAMIC_MOD(==);DF_OF_CM_FOR_DYNAMIC_MOD(!=);DF_OF_CM_FOR_DYNAMIC_MOD(>);DF_OF_CM_FOR_DYNAMIC_MOD(>=);DF_OF_CM_FOR_DYNAMIC_MOD(<);DF_OF_CM_FOR_DYNAMIC_MOD(<=);DF_OF_AR_FOR_DYNAMIC_MOD(+,NE,n,+);DF_OF_AR_FOR_DYNAMIC_MOD(-,NE,n.SignInvert(),+);DF_OF_AR_FOR_DYNAMIC_MOD(*,NE,n,*);DF_OF_AR_FOR_DYNAMIC_MOD(/,,n.Invert(),*);TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP^(ll EX)CO{RE MO(DynamicMods<NUM>(*TH)^= MO(EX));}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP<<(ll n)CO{RE MO(DynamicMods<NUM>(*TH)<<= MO(n));}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP>>(ll n)CO{RE MO(DynamicMods<NUM>(*TH)>>= MO(n));}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP-()CO NE{RE MO(DynamicMods<NUM>(*TH).SignInvert());}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::SignInvert()NE{m_n > 0?m_n = COants::g_M - m_n:m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::Invert(){m_n = COants::g_M_is_prime && m_n < COants::g_memory_le?Inverse(int(m_n)).m_n:ModularInverse(COants::g_M,MO(m_n));RE *TH;}TE <int NUM> IN VO DynamicMods<NUM>::swap(DynamicMods<NUM>& n)NE{std::swap(m_n,n.m_n);}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Inverse(CRI n){if(COants::g_M == 1){RE zero();}AS(COants::g_M_is_prime && 0 < n && n < int(COants::g_memory_le));ST VE<DynamicMods<NUM>> memory ={zero(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(DeRP(COants::g_M - memory[COants::g_M % le_curr].m_n * ull(COants::g_M / le_curr)% COants::g_M));le_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::TwoPower(CRI n){if(COants::g_M == 1){RE zero();}AS(0 <= n && n < int(COants::g_memory_le));ST VE<DynamicMods<NUM>> memory ={one()};ST int le_curr = 1;WH(le_curr <= n){memory.push_back(memory.back()+ memory.back());le_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::TwoPowerInverse(CRI n){if(COants::g_M == 1){RE zero();}AS(0 <= n && n < int(COants::g_memory_le));ST VE<DynamicMods<NUM>> memory ={one()};ST int le_curr = 1;WH(le_curr <= n){auto& m = memory.back().m_n;memory.push_back(DeRP(((m & 1)== 0?m:m + COants::g_M)>> 1));le_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Factorial(CRL n){AS(0 <= n);if(ll(COants::g_M)<= n){RE zero();}ST VE<DynamicMods<NUM>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n && memory.back().m_n != 0){memory.push_back(memory.back()* DeRP(le_curr));le_curr++;}RE le_curr <= n?memory.back():memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::FactorialInverse(CRL n){AS(0 <= n && n < COants::g_M);ST VE<DynamicMods<NUM>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* Inverse(le_curr));le_curr++;}RE memory[n];}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::Combination(CRL n,CRL i){RE 0 <= i && i <= n?Factorial(n)* FactorialInverse(i)* FactorialInverse(n - i):zero();}TE <int NUM> IN CRUI DynamicMods<NUM>::RP()CO NE{RE m_n;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::DeRP(uint n)NE{DynamicMods<NUM> n_copy{};n_copy.m_n = MO(n);RE n_copy;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::zero()NE{ST CO DynamicMods<NUM> z{};RE z;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::one()NE{ST CO DynamicMods<NUM> o{1};RE o;}TE <int NUM> IN CRUI DynamicMods<NUM>::GetModulo()NE{RE COants::g_M;}TE <int NUM> IN VO DynamicMods<NUM>::SetModulo(CRUI M,CO bool& M_is_prime)NE{COants::g_M = M;COants::g_memory_le = M < COants::g_memory_bound?M:COants::g_memory_bound;;COants::g_M_minus = M - 1;COants::g_M_is_prime = M_is_prime;}TE <int NUM> IN DynamicMods<NUM> Inverse(CO DynamicMods<NUM>& n){RE MO(DynamicMods<NUM>(n).Invert());}TE <int NUM> IN DynamicMods<NUM> Power(DynamicMods<NUM> n,ll EX){RE MO(n ^= MO(EX));}TE <int NUM> IN VO swap(DynamicMods<NUM>& n0,DynamicMods<NUM>& n1)NE{n0.swap(n1);}TE <int NUM,CL Traits> IN IS& OP>>(IS& is,DynamicMods<NUM>& n){ll m;is >> m;n = m;RE is;}TE <int NUM,CL Traits> IN OS& OP<<(OS& os,CO DynamicMods<NUM>& n){RE os << n.RP();}

TE <TY INT1,TY INT2>INT1 GCD(CO INT1& b_0,CO INT2& b_1){INT1 a_0 = b_0 < 0?-b_0:b_0;INT1 a_1 = b_1 < 0?-b_1:b_1;WH(a_1 != 0){swap(a_0 %= a_1,a_1);}RE a_0;}TE <TY INT1,TY INT2> IN INT1 LCM(CO INT1& b_0,CO INT2& b_1){RE(b_0 == 0 && b_1 == 0)?0:(b_0 / GCD(b_0,b_1))* b_1;}

#ifndef DF_OF_HASH_FOR_MOD
#define DF_OF_HASH_FOR_MOD(MOD)IN size_t hash<MOD>::OP()(CO MOD& n)CO{ST CO hash<decldecay_t(n.RP())> h;RE h(n.RP());}
#endif
TE <int NUM> DC_OF_HASH(DynamicMods<NUM>);
TE <int NUM> DF_OF_HASH_FOR_MOD( DynamicMods<NUM> );
#endif

