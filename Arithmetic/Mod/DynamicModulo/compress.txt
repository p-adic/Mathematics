#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/DynamicModulo/Debug/a_Body.hpp"
#else
// SetModulo( M , order_minus_1 = -1 );
// order_minus_1はinverseの計算時の指数。
// 例えばEuler関数-1で、をdefault引数-1にした場合、Mを素数とみなしてM-2に置き換える。

TE <TY INT1,TY INT2> CE INT1 Residue(INT1 n,CO INT2& M)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < M?n:n %= M);}

TE <int NUM> CL DynamicMods;TE <int NUM>CL COantsForDynamicMods{PU:COantsForDynamicMods()= delete;ST uint g_M;ST CE CO uint g_memory_bound = 2e6;ST uint g_memory_le;ST uint g_M_minus;ST int g_order;ST int g_order_minus;ST bool g_M_is_prime;};
TE <int NUM> uint COantsForDynamicMods<NUM>::g_M = 0;TE <int NUM> uint COantsForDynamicMods<NUM>::g_memory_le = 0;TE <int NUM> uint COantsForDynamicMods<NUM>::g_M_minus = -1;TE <int NUM> int COantsForDynamicMods<NUM>::g_order = 1;TE <int NUM> int COantsForDynamicMods<NUM>::g_order_minus = 0;TE <int NUM> bool COantsForDynamicMods<NUM>::g_M_is_prime = false;

#define SFINAE_FOR_DMOD enable_if_t<is_COructible_v<uint,decay_t<T>>>*
#define DC_OF_CM_FOR_DYNAMIC_MOD(OPR)IN bool OP OPR(CO DynamicMods<NUM>& n)CO NE
#define DC_OF_AR_FOR_DYNAMIC_MOD(OPR,EX)IN DynamicMods<NUM> OP OPR(DynamicMods<NUM> n)CO EX;
#define DF_OF_CM_FOR_DYNAMIC_MOD(OPR)TE <int NUM> IN bool DynamicMods<NUM>::OP OPR(CO DynamicMods<NUM>& n)CO NE{RE m_n OPR n.m_n;}
#define DF_OF_AR_FOR_DYNAMIC_MOD(OPR,EX,LEFT,OPR2)TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP OPR(DynamicMods<NUM> n)CO EX{RE MO(LEFT OPR2 ## = *TH);}TE <int NUM,TY T,SFINAE_FOR_DMOD = nullptr> IN DynamicMods<NUM> OP OPR(T n0,CO DynamicMods<NUM>& n1)EX{RE MO(DynamicMods<NUM>(MO(n0))OPR ## = n1);}
TE <int NUM>CL DynamicMods{PU:uint m_n;IN DynamicMods()NE;IN DynamicMods(CO DynamicMods<NUM>& n)NE;IN DynamicMods(DynamicMods<NUM>&& n)NE;TE <TY T,SFINAE_FOR_DMOD = nullptr> IN DynamicMods(T n)NE;IN DynamicMods<NUM>& OP=(DynamicMods<NUM> n)NE;IN DynamicMods<NUM>& OP+=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP-=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP*=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP/=(DynamicMods<NUM> n);TE <TY INT> IN DynamicMods<NUM>& OP<<=(INT n);TE <TY INT> IN DynamicMods<NUM>& OP>>=(INT n);IN DynamicMods<NUM>& OP++()NE;IN DynamicMods<NUM> OP++(int)NE;IN DynamicMods<NUM>& OP--()NE;IN DynamicMods<NUM> OP--(int)NE;DC_OF_CM_FOR_DYNAMIC_MOD(==);DC_OF_CM_FOR_DYNAMIC_MOD(!=);DC_OF_CM_FOR_DYNAMIC_MOD(<);DC_OF_CM_FOR_DYNAMIC_MOD(<=);DC_OF_CM_FOR_DYNAMIC_MOD(>);DC_OF_CM_FOR_DYNAMIC_MOD(>=);DC_OF_AR_FOR_DYNAMIC_MOD(+,NE);DC_OF_AR_FOR_DYNAMIC_MOD(-,NE);DC_OF_AR_FOR_DYNAMIC_MOD(*,NE);DC_OF_AR_FOR_DYNAMIC_MOD(/,);TE <TY INT> IN DynamicMods<NUM> OP^(INT EX)CO;TE <TY INT> IN DynamicMods<NUM> OP<<(INT n)CO;TE <TY INT> IN DynamicMods<NUM> OP>>(INT n)CO;IN DynamicMods<NUM> OP-()CO NE;IN DynamicMods<NUM>& SignInvert()NE;IN DynamicMods<NUM>& Invert();TE <TY INT> IN DynamicMods<NUM>& Power(INT EX);IN VO swap(DynamicMods<NUM>& n)NE;IN CRUI RP()CO NE;ST IN DynamicMods<NUM> DeRP(uint n)NE;ST IN CO DynamicMods<NUM>& Factorial(CRL n);ST IN CO DynamicMods<NUM>& FactorialInverse(CRL n);ST IN DynamicMods<NUM> Combination(CRL n,CRL i);ST IN CO DynamicMods<NUM>& zero()NE;ST IN CO DynamicMods<NUM>& one()NE;ST IN CRUI GetModulo()NE;ST IN VO SetModulo(CRUI M,CRI order_minus_1 = -1)NE;TE <TY INT> IN DynamicMods<NUM>& PositivePower(INT EX)NE;TE <TY INT> IN DynamicMods<NUM>& NonNegativePower(INT EX)NE;ST IN CO DynamicMods<NUM>& Inverse(CRI n);ST IN CO DynamicMods<NUM>& TwoPower(CRI n);US COants = COantsForDynamicMods<NUM>;};
US DynamicMod = DynamicMods<0>;
TE <int NUM> IN DynamicMods<NUM>::DynamicMods()NE:m_n(){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(CO DynamicMods<NUM>& n)NE:m_n(n.m_n){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(DynamicMods<NUM>&& n)NE:m_n(MO(n.m_n)){}TE <int NUM> TE <TY T,SFINAE_FOR_DMOD> IN DynamicMods<NUM>::DynamicMods(T n)NE:m_n(Residue(MO(n),COants::g_M)){}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP=(DynamicMods<NUM> n)NE{m_n = MO(n.m_n);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP+=(CO DynamicMods<NUM>& n)NE{(m_n += n.m_n)< COants::g_M?m_n:m_n -= COants::g_M;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP-=(CO DynamicMods<NUM>& n)NE{m_n < n.m_n?(m_n += COants::g_M)-= n.m_n:m_n -= n.m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP*=(CO DynamicMods<NUM>& n)NE{m_n = Residue(MO(ull(m_n)* n.m_n),COants::g_M);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP/=(DynamicMods<NUM> n){RE OP*=(n.Invert());}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::OP<<=(INT n){AS(n >= 0);RE *TH *= DynamicMods<NUM>(2).NonNegativePower(MO(n));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::OP>>=(INT n){AS(n >= 0);WH(n-- > 0){((m_n & 1)== 0?m_n:m_n += COants::g_M)>>= 1;}RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP++()NE{m_n < COants::g_M_minus?++m_n:m_n = 0;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP++(int)NE{DynamicMods<NUM> n{*TH};OP++();RE n;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP--()NE{m_n == 0?m_n = COants::g_M_minus:--m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP--(int)NE{DynamicMods<NUM> n{*TH};OP--();RE n;}DF_OF_CM_FOR_DYNAMIC_MOD(==);DF_OF_CM_FOR_DYNAMIC_MOD(!=);DF_OF_CM_FOR_DYNAMIC_MOD(>);DF_OF_CM_FOR_DYNAMIC_MOD(>=);DF_OF_CM_FOR_DYNAMIC_MOD(<);DF_OF_CM_FOR_DYNAMIC_MOD(<=);DF_OF_AR_FOR_DYNAMIC_MOD(+,NE,n,+);DF_OF_AR_FOR_DYNAMIC_MOD(-,NE,n.SignInvert(),+);DF_OF_AR_FOR_DYNAMIC_MOD(*,NE,n,*);DF_OF_AR_FOR_DYNAMIC_MOD(/,,n.Invert(),*);TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP^(INT EX)CO{RE MO(DynamicMods<NUM>(*TH).Power(MO(EX)));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP<<(INT n)CO{RE MO(DynamicMods<NUM>(*TH)<<= MO(n));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP>>(INT n)CO{RE MO(DynamicMods<NUM>(*TH)>>= MO(n));}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP-()CO NE{RE MO(DynamicMods<NUM>(*TH).SignInvert());}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::SignInvert()NE{m_n > 0?m_n = COants::g_M - m_n:m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::Invert(){RE m_n <(COants::g_M_is_prime?1e6:3e4)?*TH = Inverse(m_n):NonNegativePower(COants::g_order_minus);}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::PositivePower(INT EX)NE{DynamicMods<NUM> pw{*TH};EX--;WH(EX != 0){(EX & 1)== 1?*TH *= pw:*TH;EX >>= 1;pw *= pw;}RE *TH;}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::NonNegativePower(INT EX)NE{RE EX == 0?(m_n = 1,*TH):PositivePower(MO(EX));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::Power(INT EX){bool neg = EX < 0;AS(!(neg && m_n == 0));RE NonNegativePower(MO(neg?(EX %= COants::g_order)== 0?EX:EX += COants::g_order:EX));}TE <int NUM> IN VO DynamicMods<NUM>::swap(DynamicMods<NUM>& n)NE{std::swap(m_n,n.m_n);}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Inverse(CRI n){if(COants::g_M == 1){RE zero();}AS(0 < n && n < int(COants::g_memory_le));ST VE<DynamicMods<NUM>> memory ={zero(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(COants::g_M_is_prime?DeRP(COants::g_M - memory[COants::g_M % le_curr].m_n * ull(COants::g_M / le_curr)% COants::g_M):DeRP(n).NonNegativePower(COants::g_order_minus));le_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::TwoPower(CRI n){if(COants::g_M == 1){RE zero();}AS(0 <= n && n < int(COants::g_memory_le));ST VE<DynamicMods<NUM>> memory ={one()};ST int le_curr = 1;WH(le_curr <= n){memory.push_back(memory.back()+ memory.back());le_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Factorial(CRL n){AS(0 <= n);if(ll(COants::g_M)<= n){RE zero();}ST VE<DynamicMods<NUM>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n && memory.back().m_n != 0){memory.push_back(memory.back()* DeRP(le_curr));le_curr++;}RE le_curr <= n?memory.back():memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::FactorialInverse(CRL n){AS(0 <= n && n < COants::g_M);ST VE<DynamicMods<NUM>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* Inverse(le_curr));le_curr++;}RE memory[n];}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::Combination(CRL n,CRL i){RE 0 <= i && i <= n?Factorial(n)* FactorialInverse(i)* FactorialInverse(n - i):zero();}TE <int NUM> IN CRUI DynamicMods<NUM>::RP()CO NE{RE m_n;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::DeRP(uint n)NE{DynamicMods<NUM> n_copy{};n_copy.m_n = MO(n);RE n_copy;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::zero()NE{ST CO DynamicMods<NUM> z{};RE z;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::one()NE{ST CO DynamicMods<NUM> o{1};RE o;}TE <int NUM> IN CRUI DynamicMods<NUM>::GetModulo()NE{RE COants::g_M;}TE <int NUM> IN VO DynamicMods<NUM>::SetModulo(CRUI M,CRI order_minus)NE{COants::g_M = M;COants::g_memory_le = M < COants::g_memory_bound?M:COants::g_memory_bound;;COants::g_M_minus = M - 1;COants::g_order = order_minus == -1?M - 1:order_minus + 1;COants::g_order_minus = COants::g_order - 1;COants::g_M_is_prime = order_minus == -1;}TE <int NUM> IN DynamicMods<NUM> Inverse(CO DynamicMods<NUM>& n){RE MO(DynamicMods<NUM>(n).Invert());}TE <int NUM,TY INT> IN DynamicMods<NUM> Power(DynamicMods<NUM> n,INT EX){RE MO(n.Power(MO(EX)));}TE <int NUM> IN VO swap(DynamicMods<NUM>& n0,DynamicMods<NUM>& n1)NE{n0.swap(n1);}TE <int NUM> IN string to_string(CO DynamicMods<NUM>& n)NE{RE to_string(n.RP())+ " + " + to_string(DynamicMods<NUM>::GetModulo())+ "Z";}TE <int NUM,CL Traits> IN IS& OP>>(IS& is,DynamicMods<NUM>& n){ll m;is >> m;n = m;RE is;}TE <int NUM,CL Traits> IN OS& OP<<(OS& os,CO DynamicMods<NUM>& n){RE os << n.RP();}

TE <TY INT1,TY INT2>INT1 GCD(CO INT1& b_0,CO INT2& b_1){INT1 a_0 = b_0 < 0?-b_0:b_0;INT1 a_1 = b_1 < 0?-b_1:b_1;WH(a_1 != 0){swap(a_0 %= a_1,a_1);}RE a_0;}TE <TY INT1,TY INT2> IN INT1 LCM(CO INT1& b_0,CO INT2& b_1){RE(b_0 == 0 && b_1 == 0)?0:(b_0 / GCD(b_0,b_1))* b_1;}

TE <int NUM> DC_OF_HASH(DynamicMods<NUM>);
TE <int NUM> DF_OF_HASH_FOR_MOD( DynamicMods<NUM> );
#endif

