#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/Function/CRT/a_Body.hpp"
#else
TE <TY RET,TY INT>tuple<RET,RET,INT> PartitionOfUnity(CO INT& base_0,CO INT& base_1){if(base_1 == 0){RE{base_0<0?-1:1,0,abs(base_0)};}auto[c_1,c_0,gcd]= PartitionOfUnity<RET,INT>(base_1,base_0 % base_1);c_1 -= base_0 / base_1 * c_0;RE{MO(c_0),MO(c_1),MO(gcd)};}TE <TY INT>INT ChineseRemainderTheorem(CO INT& b_0,CO INT& c_0,CO INT& b_1,CO INT& c_1){auto[u_0,u_1,gcd]= PartitionOfUnity<ll>(b_0,b_1,u_0,u_1);CO INT c = c_0 % gcd;if(c_1 % gcd != c){RE -1;}CO INT lcm =(b_0 / gcd)* b_1;(u_0 *=(c_1 - c)/ gcd)%= lcm;(u_1 *=(c_0 - c)/ gcd)%= lcm;RE Residue(c + u_0 * b_0 + u_1 * b_1,lcm);}TE <TY INT>INT Garner(CO VE<INT>& b,CO VE<INT>& c){CO int SZ = b.SZ();AS(int(c.SZ())== SZ);VE<INT> coeff(SZ);for(int i = 0;i < SZ;i++){INT temp = 0,b_prod = 1 % b[i];for(int j = 0;j < i;j++){temp += coeff[j]* b_prod % b[i];b_prod = b_prod * b[j]% b[i];}(coeff[i]=(c[i]% b[i]- temp)* ModularInverse(b[i],b_prod)% b[i])< 0?coeff[i]+= b[i]:coeff[i];}INT AN = 0,b_prod;for(int i = 0;i < SZ;i++){i == 0?b_prod = 1:b_prod *= b[i-1];AN += coeff[i]* b_prod;}RE AN;}
#endif

