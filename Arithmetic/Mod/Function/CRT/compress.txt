#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/Function/CRT/a_Body.hpp"
#else
TE <TY INT1,TY INT2> IN CE INT1 RS(INT1 n,CO INT2& M)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < M?n:n %= M);}

IN int GCD(){RE 0;}TE <TY INT1,TY...INT2>INT1 GCD(INT1 b_0,INT2... args){b_0 < 0?b_0 = -b_0:b_0;INT1 b_1 = GCD(MO(args)...);WH(b_1 != 0){swap(b_0 %= b_1,b_1);}RE MO(b_0);}TE <TY INT,TE <TY...> TY V>INT GCD(V<INT> a){INT AN = 0;for(auto& b:a){AN = GCD(MO(AN),b);}RE AN;}IN int LCM(){RE 0;}TE <TY INT1,TY...INT2>INT1 LCM(INT1 b_0,INT2... args){b_0 < 0?-b_0:b_0;INT1 b_1 = LCM(MO(args)...);RE b_1 == 0?b_0:b_0 / GCD(b_0,b_1)* b_1;}TE <TY INT,TE <TY...> TY V>INT LCM(V<INT> a){INT AN = 1;for(auto& b:a){AN = LCM(MO(AN),b);}RE AN;}

TE <TY INT>INT PartitionOfUnity(CO INT& b_0,CO INT& b_1,INT& u_0,INT& u_1){INT a[2][2]={{1,0},{0,1}};INT b[2]={b_0,b_1};for(int i = 0;i < 2;i++){if(b[i]< 0){a[i][i]= -1;b[i]*= -1;}}int i_0 =(b_0 >= b_1?0:1);int i_1 = 1 - i_0;WH(b[i_1]!= 0){INT& b_i_0 = b[i_0];CO INT& b_i_1 = b[i_1];INT(&a_i_0)[2]= a[i_0];CO INT(&a_i_1)[2]= a[i_1];CO INT q = b_i_0 / b_i_1;a_i_0[i_0]-= q * a_i_1[i_0];a_i_0[i_1]-= q * a_i_1[i_1];b_i_0 -= q * b_i_1;swap(i_0,i_1);}INT(&a_i_0)[2]= a[i_0];u_0 = MO(a_i_0[0]);u_1 = MO(a_i_0[1]);RE MO(b[i_0]);}TE <TY INT> IN INT ModularInverse(CO INT& b,CO INT& c){INT u_0,u_1;CO INT gcd = PartitionOfUnity(b,c % b,u_0,u_1);AS(gcd == 1);RE u_1;}TE <TY INT>INT ChineseRemainderTheorem(CO INT& b_0,CO INT& c_0,CO INT& b_1,CO INT& c_1){INT u_0,u_1;CO INT gcd = PartitionOfUnity(b_0,b_1,u_0,u_1);CO INT c = c_0 % gcd;if(c_1 % gcd != c){RE -1;}CO INT lcm =(b_0 / gcd)* b_1;u_0 *=(c_1 - c)/ gcd;RS(u_0,lcm);u_1 *=(c_0 - c)/ gcd;u_1 =(u_1 >= 0?u_1 % lcm:lcm -(- u_1 - 1)% lcm - 1);RE(c + u_0 * b_0 + u_1 * b_1)% lcm;}TE <TY INT>INT Garner(CO VE<INT>& b,CO VE<INT>& c){CO int SZ = b.SZ();AS(int(c.SZ())== SZ);VE<INT> coeff(SZ);for(int i = 0;i < SZ;i++){INT temp = 0,b_prod = 1 % b[i];for(int j = 0;j < i;j++){temp += coeff[j]* b_prod % b[i];b_prod = b_prod * b[j]% b[i];}(coeff[i]=(c[i]% b[i]- temp)* ModularInverse(b[i],b_prod)% b[i])< 0?coeff[i]+= b[i]:coeff[i];}INT AN = 0,b_prod;for(int i = 0;i < SZ;i++){i == 0?b_prod = 1:b_prod *= b[i-1];AN += coeff[i]* b_prod;}RE AN;}
#endif
