// 常設ライブラリーのDynamicModsを消す必要はなく、非常設ライブラリーとして貼り付ける。
// DynamicModsを消す場合はCEXPR(uint,P,998244353);のコメントアウトを解除する。
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/ConstexprModulo/Debug/a_Body.hpp"
#else
// CEXPR(uint,P,998244353);
TE <uint M,TY INT> CE INT Residue(INT n)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < INT(M)?n:n %= M);}TE <TY INT> CE INT& ResidueP(INT& n)NE{CE CO uint trunc =(1 << 23)- 1;INT n_u = n >> 23;n &= trunc;INT n_uq =(n_u / 7)/ 17;n_u -= n_uq * 119;n += n_u << 23;RE n < n_uq?n += P - n_uq:n -= n_uq;}
TE <TY INT> IN INT ModularInverse(CO INT& base,ll c){AS(base > 0);ll a[2]={0,1 % base};INT b[2]={base,INT((c %= base)< 0?c += base:c)};WH(b[1]!= 0){CO INT q = b[0]/ b[1];(a[0]-= q * a[1]% base)< 0?a[0]+= base:a[0];b[0]-= q * b[1];swap(a[0],a[1]);swap(b[0],b[1]);}AS(b[0]== 1 &&(a[0]* c - 1)% base == 0);RE a[0];}
TE <uint M> CL Mod;TE <uint M>CL COantsForMod{PU:COantsForMod()= delete;ST CE CO uint g_memory_bound = 2e6;ST CE CO uint g_memory_le = M < g_memory_bound?M:g_memory_bound;ST CE uint g_M_minus = M - 1;ST CE int g_order = M - 1;ST CE int g_order_minus = g_order - 1;};
#define SFINAE_FOR_MOD enable_if_t<is_COructible_v<uint,decay_t<T>>>*
#define DC_OF_CM_FOR_MOD(OPR)CE bool OP OPR(CO Mod<M>& n)CO NE
#define DC_OF_AR_FOR_MOD(OPR,EX)CE Mod<M> OP OPR(Mod<M> n)CO EX;
#define DF_OF_CM_FOR_MOD(OPR)TE <uint M> CE bool Mod<M>::OP OPR(CO Mod<M>& n)CO NE{RE m_n OPR n.m_n;}
#define DF_OF_AR_FOR_MOD(OPR,EX,LEFT,OPR2)TE <uint M> CE Mod<M> Mod<M>::OP OPR(Mod<M> n)CO EX{RE MO(LEFT OPR2 ## = *TH);}TE <uint M,TY T,SFINAE_FOR_MOD = nullptr> CE Mod<M> OP OPR(T n0,CO Mod<M>& n1)EX{RE MO(Mod<M>(MO(n0))OPR ## = n1);}
TE <uint M>CL Mod{PU:uint m_n;CE Mod()NE;CE Mod(CO Mod<M>& n)NE;CE Mod(Mod<M>&& n)NE;TE <TY T,SFINAE_FOR_MOD = nullptr> CE Mod(T n)NE;CE Mod<M>& OP=(Mod<M> n)NE;CE Mod<M>& OP+=(CO Mod<M>& n)NE;CE Mod<M>& OP-=(CO Mod<M>& n)NE;CE Mod<M>& OP*=(CO Mod<M>& n)NE;IN Mod<M>& OP/=(Mod<M> n);CE Mod<M>& OP^=(ll EX);CE Mod<M>& OP<<=(ll n);CE Mod<M>& OP>>=(ll n);CE Mod<M>& OP++()NE;CE Mod<M> OP++(int)NE;CE Mod<M>& OP--()NE;CE Mod<M> OP--(int)NE;DC_OF_CM_FOR_MOD(==);DC_OF_CM_FOR_MOD(!=);DC_OF_CM_FOR_MOD(<);DC_OF_CM_FOR_MOD(<=);DC_OF_CM_FOR_MOD(>);DC_OF_CM_FOR_MOD(>=);DC_OF_AR_FOR_MOD(+,NE);DC_OF_AR_FOR_MOD(-,NE);DC_OF_AR_FOR_MOD(*,NE);DC_OF_AR_FOR_MOD(/,);CE Mod<M> OP^(ll EX)CO;CE Mod<M> OP<<(ll n)CO;CE Mod<M> OP>>(ll n)CO;CE Mod<M> OP-()CO NE;CE VO swap(Mod<M>& n)NE;CE CRUI RP()CO NE;ST CE Mod<M> DeRP(uint n)NE;ST IN CO Mod<M>& Factorial(CRL n);ST IN CO Mod<M>& FactorialInverse(CRL n);ST IN Mod<M> Combination(CRL n,CRL i);ST IN CO Mod<M>& zero()NE;ST IN CO Mod<M>& one()NE;ST CE uint GetModulo()NE;CE Mod<M>& SignInvert()NE;IN Mod<M>& Invert();CE Mod<M>& PPW(ll EX)NE;CE Mod<M>& NNPW(ll EX)NE;ST IN CO Mod<M>& Inverse(CRI n);ST IN CO Mod<M>& TwoPower(CRI n);ST IN CO Mod<M>& TwoPowerInverse(CRI n);US COants = COantsForMod<M>;};
US MP = Mod<P>;
TE <uint M> CE Mod<M>::Mod()NE:m_n(){}TE <uint M> CE Mod<M>::Mod(CO Mod<M>& n)NE:m_n(n.m_n){}TE <uint M> CE Mod<M>::Mod(Mod<M>&& n)NE:m_n(MO(n.m_n)){}TE <uint M> TE <TY T,SFINAE_FOR_MOD> CE Mod<M>::Mod(T n)NE:m_n(Residue<M>(MO(n))){}TE <uint M> CE Mod<M>& Mod<M>::OP=(Mod<M> n)NE{m_n = MO(n.m_n);RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::OP+=(CO Mod<M>& n)NE{(m_n += n.m_n)< M?m_n:m_n -= M;RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::OP-=(CO Mod<M>& n)NE{m_n < n.m_n?(m_n += M)-= n.m_n:m_n -= n.m_n;RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::OP*=(CO Mod<M>& n)NE{m_n = MO(ull(m_n)* n.m_n)% M;RE *TH;}TE <> CE MP& MP::OP*=(CO MP& n)NE{ull m_n_copy = m_n;m_n = MO((m_n_copy *= n.m_n)< P?m_n_copy:ResidueP(m_n_copy));RE *TH;}TE <uint M> IN Mod<M>& Mod<M>::OP/=(Mod<M> n){RE OP*=(n.Invert());}TE <uint M> CE Mod<M>& Mod<M>::PPW(ll EX)NE{Mod<M> pw{*TH};EX--;WH(EX != 0){(EX & 1)== 1?*TH *= pw:*TH;EX >>= 1;pw *= pw;}RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::NNPW(ll EX)NE{RE EX == 0?(m_n = 1,*TH):PPW(MO(EX));}TE <uint M> CE Mod<M>& Mod<M>::OP^=(ll EX){if(EX < 0){m_n = ModularInverse(M,MO(m_n));EX *= -1;}RE NNPW(MO(EX));}TE <uint M> CE Mod<M>& Mod<M>::OP<<=(ll n){RE *TH *=(n < 0 && -n < int(COants::g_memory_le))?TwoPowerInverse(- int(n)):(n >= 0 && n < int(COants::g_memory_le))?TwoPower(int(n)):Mod<M>(2)^= MO(n);}TE <uint M> CE Mod<M>& Mod<M>::OP>>=(ll n){RE *TH <<= MO(n *= -1);}TE <uint M> CE Mod<M>& Mod<M>::OP++()NE{m_n < COants::g_M_minus?++m_n:m_n = 0;RE *TH;}TE <uint M> CE Mod<M> Mod<M>::OP++(int)NE{Mod<M> n{*TH};OP++();RE n;}TE <uint M> CE Mod<M>& Mod<M>::OP--()NE{m_n == 0?m_n = COants::g_M_minus:--m_n;RE *TH;}TE <uint M> CE Mod<M> Mod<M>::OP--(int)NE{Mod<M> n{*TH};OP--();RE n;}DF_OF_CM_FOR_MOD(==);DF_OF_CM_FOR_MOD(!=);DF_OF_CM_FOR_MOD(>);DF_OF_CM_FOR_MOD(>=);DF_OF_CM_FOR_MOD(<);DF_OF_CM_FOR_MOD(<=);DF_OF_AR_FOR_MOD(+,NE,n,+);DF_OF_AR_FOR_MOD(-,NE,n.SignInvert(),+);DF_OF_AR_FOR_MOD(*,NE,n,*);DF_OF_AR_FOR_MOD(/,,n.Invert(),*);TE <uint M> CE Mod<M> Mod<M>::OP^(ll EX)CO{RE MO(Mod<M>(*TH)^= MO(EX));}TE <uint M> CE Mod<M> Mod<M>::OP<<(ll n)CO{RE MO(Mod<M>(*TH)<<= MO(n));}TE <uint M> CE Mod<M> Mod<M>::OP>>(ll n)CO{RE MO(Mod<M>(*TH)>>= MO(n));}TE <uint M> CE Mod<M> Mod<M>::OP-()CO NE{RE MO(Mod<M>(*TH).SignInvert());}TE <uint M> CE Mod<M>& Mod<M>::SignInvert()NE{m_n > 0?m_n = M - m_n:m_n;RE *TH;}TE <uint M> IN Mod<M>& Mod<M>::Invert(){m_n = m_n < COants::g_memory_le?Inverse(int(m_n)).m_n:ModularInverse(M,MO(m_n));RE *TH;}TE <uint M> CE VO Mod<M>::swap(Mod<M>& n)NE{std::swap(m_n,n.m_n);}TE <uint M> IN CO Mod<M>& Mod<M>::Inverse(CRI n){AS(0 < n && n < int(COants::g_memory_le));ST VE<Mod<M>> memory ={zero(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(DeRP(M - memory[M % le_curr].m_n * ull(M / le_curr)% M));le_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::TwoPower(CRI n){AS(0 <= n && n < int(COants::g_memory_le));ST VE<Mod<M>> memory ={one()};ST int le_curr = 1;WH(le_curr <= n){memory.push_back(memory.back()+ memory.back());le_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::TwoPowerInverse(CRI n){AS(0 <= n && n < int(COants::g_memory_le));ST VE<Mod<M>> memory ={one()};ST int le_curr = 1;WH(le_curr <= n){auto& m = memory.back().m_n;memory.push_back(DeRP(((m & 1)== 0?m:m + M)>> 1));le_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::Factorial(CRL n){AS(n >= 0);if(ll(M)<= n){RE zero();}ST VE<Mod<M>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* le_curr);le_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::FactorialInverse(CRL n){AS(0 <= n && n < ll(M));ST VE<Mod<M>> memory ={one(),one()};ST int le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* Inverse(le_curr));le_curr++;}RE memory[n];}TE <uint M> IN Mod<M> Mod<M>::Combination(CRL n,CRL i){RE 0 <= i && i <= n?Factorial(n)* FactorialInverse(i)* FactorialInverse(n - i):zero();}TE <uint M> CE CRUI Mod<M>::RP()CO NE{RE m_n;}TE <uint M> CE Mod<M> Mod<M>::DeRP(uint n)NE{Mod<M> n_copy{};n_copy.m_n = MO(n);RE n_copy;}TE <uint M> IN CO Mod<M>& Mod<M>::zero()NE{ST CE CO Mod<M> z{};RE z;}TE <uint M> IN CO Mod<M>& Mod<M>::one()NE{ST CE CO Mod<M> o{1};RE o;}TE <uint M> CE uint Mod<M>::GetModulo()NE{RE M;}TE <uint M> IN Mod<M> Inverse(CO Mod<M>& n){RE MO(Mod<M>(n).Invert());}TE <uint M> CE Mod<M> Power(Mod<M> n,ll EX){RE MO(n ^= MO(EX));}TE <uint M> CE VO swap(Mod<M>& n0,Mod<M>& n1)NE{n0.swap(n1);}TE <uint M> IN string to_string(CO Mod<M>& n)NE{RE to_string(n.RP())+ " + " + to_string(M)+ "Z";}TE <uint M,CL Traits> IN IS& OP>>(IS& is,Mod<M>& n){ll m;is >> m;n = m;RE is;}TE <uint M,CL Traits> IN OS& OP<<(OS& os,CO Mod<M>& n){RE os << n.RP();}

#ifndef DF_OF_HASH_FOR_MOD
#define DF_OF_HASH_FOR_MOD(MOD)IN size_t hash<MOD>::OP()(CO MOD& n)CO{ST CO hash<decldecay_t(n.RP())> h;RE h(n.RP());}
#endif
TE <uint M> DC_OF_HASH(Mod<M>);TE <uint M> DF_OF_HASH_FOR_MOD(Mod<M>);
#endif
