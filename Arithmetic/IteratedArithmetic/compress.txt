#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/IteratedArithmetic/a_Body.hpp"
#else
TE <TY T,TY U,TE <TY...> TY V,TY OPR> T LeftConnectiveProd(T t,CO V<U>& f,OPR opr){for(auto& u:f){t = opr(MO(t),u);}RE MO(t);}TE <TY T,TY U,TE <TY...> TY V> IN T Sum(T t,CO V<U>& f){RE LeftConnectiveProd(MO(t),f,[](T t0,CO U& u1){RE MO(t0 += u1);});}TE <TY T,TE <TY...> TY V> IN T Sum(CO V<T>& f){RE Sum(T{},f);}TE <TY T,TY U,TE <TY...> TY V> IN T Prod(T t,CO V<U>& f){RE LeftConnectiveProd(MO(t),f,[](T t0,CO U& u1){RE MO(t0 *= u1);});}TE <TY T,TE <TY...> TY V> IN T Prod(CO V<T>& f){RE Prod(T{1},f);}TE <TY T,TE <TY...> TY V> IN T Max(CO V<T>& f){RE *max_element(f.BE(),f.EN());}TE <TY T,TY...Args> IN T Max(CO T& t0,CO T& t1,CO Args&... args){RE Max(VE<T>{t0,t1,args...});}TE <TY T,TE <TY...> TY V> IN T Min(CO V<T>& f){RE *min_element(f.BE(),f.EN());}TE <TY T,TY...Args> IN T Min(CO T& t0,CO T& t1,CO Args&... args){RE Min(VE<T>{t0,t1,args...});}TE <TY T,TY U> IN T SetMax(T& n,CO U& m){RE n < m?n = m:n;}TE <TY T,TY U> IN T SetMin(T& n,CO U& m){RE n > m?n = m:n;}TE <TY T,TY UINT>T Power(T t,UINT EX,T init = 1){(EX & 1)== 1?init *= t:init;EX >>= 1;WH(EX > 0){t = Square(t);(EX & 1)== 1?init *= t:init;EX >>= 1;}RE MO(init);}TE <TY INT> IN INT ArithmeticProgressionSum(CO INT& l,INT r,CO INT& d = 1){AS(l <= r);CO INT c =(r - l)/ d;RE(c & 1)== 0?(c + 1)*(l + d *(c >> 1)):((c + 1)>> 1)*((l << 1)+ d * c);}TE <TY INT> IN INT ArithmeticProgressionSum(CO INT& r){RE ArithmeticProgressionSum(INT{},r);}TE <TY T,TY UINT> IN T GeometricProgressionSum(T rate,UINT EX_max,CO T& init = 1){T rate_minus = rate - 1;RE rate_minus == 0?init * ++EX_max:(Power(MO(rate),MO(++EX_max))- 1)/ MO(rate_minus)* init;}TE <TY T,TY UINT>T GeometricProgressionLinearCombinationSum(VE<T> rate,VE<UINT> EX_max,CO VE<T>& init){CO int SZ = init.SZ();AS(int(rate.SZ())== SZ && int(EX_max.SZ())== SZ);T AN{};for(int i = 0;i < SZ;i++){AN += GeometricProgressionSum(MO(rate[i]),MO(EX_max[i]),init[i]);}RE AN;}
#endif
