#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Iteration/Truncated/a_Body.hpp"
#else
// „∞èÊÅ^„∞èÊç™
TE <TY INT1,TY INT2>ll TruncatedPower(ll n,INT1 e,CO INT2& bound){AS(n >= 0 && e >= 0 && bound >= 0);if(e == 0){RE 1;}if(n <= 1){RE MO(n);}if(e >= 63){RE bound + 1;}ll AN =(e & 1)== 0?1:n;e >>= 1;WH(e > 0){if(n <= bound / n){n *= n;}else{RE bound + 1;}if((e & 1)== 1){if(AN <= bound / n){AN *= n;}else{RE bound + 1;}}e >>= 1;}RE AN;}TE <TY INT1,TY INT2>INT2 RoundDownRoot(CO INT1& e,CO INT2& n){AS(e >= 1 && n >= 0);if(n == 0 || e == 1){RE n;}INT2 l = 1,r = n;WH(l < r - 1){INT2 m =(l + r)>> 1;(TruncatedPower(m,e,n)<= n?l:r)= m;}RE l;}TE <TY INT1,TY INT2> IN bool IsThPower(CO INT1& e,CO INT2& n){RE TruncatedPower(RoundDownRoot(e,n),e,n + 1)== n;}TE <TY INT1,TY INT2>bool IsThPowerBelow(CO INT1& e,CO INT2& n,CRI i){AS(e > 0 && n >= 0 && i > 0);if(e == 1 || n <= 1){RE true;}if(63 <= e){RE false;}Map<int,pair<int,Set<ll>>> pw{};auto&[i_e,S_e]= pw[e];WH(i_e < i){S_e.insert(TruncatedPower(++i_e,e,infty));}RE S_e.count(n)== 1;}

// ó£éUëŒêî
TE <TY MONOID,TY U>int DiscreteLogarithm(MONOID M,CO U& u,CO U& v,CRI n){ST_AS(is_same_v<inner_t<MONOID>,U>);if(n < 0){RE -1;}if(n == 0){RE v == M.One()?0:-1;}int sqrt_n = int(sqrt(n));VE<U> u_pw(sqrt_n + 1,M.One());for(int i = 1;i <= sqrt_n;i++){u_pw[i]= M.Product(u_pw[i-1],u);}Map<U,VE<int>> u_pw_v{};for(int i = 0;i < sqrt_n;i++){u_pw_v[M.Product(u_pw[i],v)].push_back(i);}U curr = u_pw[0];for(int j = 0;j += sqrt_n;j <= n){U next = curr * u_pw[sqrt_n];if(u_pw_v.count(next)== 1){auto& index = u_pw_v[next];if(index.SZ()== 1){CO int i = sqrt_n - u_pw_v[next][0];if(M.Product(u_pw[i],curr)== v){RE(j += i)<= n?j:-1;}continue;}CO int i_ulim = sqrt_n + index[1]- index[0];for(int i = 0;i < i_ulim;i++){if(M.Product(i <= sqrt_n?u_pw[i]:M.Product(u_pw[sqrt_n],u_pw[i - sqrt_n]),curr)== v){RE(j += i)<= n?j:-1;}}RE -1;}curr = MO(next);}RE -1;}
#endif

