#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/AdicExpansion/Sparse/a_Body.hpp"
#else
TE <int M,TY INT = int>CL SparseAdicExpansion{PU:map<INT,INT> m_digit;IN SparseAdicExpansion()= default;IN CO map<INT,INT>& GetDigit()CO NE;TE <TY MODINT> MODINT GetValue()CO;VO Add(INT d,INT c);IN bool OP==(CO SparseAdicExpansion<M,INT>& n)CO NE;IN bool OP!=(CO SparseAdicExpansion<M,INT>& n)CO NE;IN bool OP<=(CO SparseAdicExpansion<M,INT>& n)CO NE;IN bool OP<(CO SparseAdicExpansion<M,INT>& n)CO NE;int comp(CO SparseAdicExpansion<M,INT>& n)CO NE;};
TE <int M,TY INT>VO SparseAdicExpansion<M,INT>::Add(INT d,INT c){WH(c != 0){auto& c_d = m_digit[d];c =(c_d += c)/ M;c_d %= M;if(c_d == 0){m_digit.erase(d);}d++;}RE;}TE <int M,TY INT> IN CO map<INT,INT>& SparseAdicExpansion<M,INT>::GetDigit()CO NE{RE m_digit;}TE <int M,TY INT> TE <TY MODINT>MODINT SparseAdicExpansion<M,INT>::GetValue()CO{MODINT AN{},m{M};for(auto&[d,c]:m_digit){AN += Power(m,d)* c;}RE AN;}TE <int M,TY INT> IN bool SparseAdicExpansion<M,INT>::OP==(CO SparseAdicExpansion<M,INT>& n)CO NE{RE comp(n)== 0;}TE <int M,TY INT> IN bool SparseAdicExpansion<M,INT>::OP!=(CO SparseAdicExpansion<M,INT>& n)CO NE{RE !(*TH == n);}TE <int M,TY INT> IN bool SparseAdicExpansion<M,INT>::OP<=(CO SparseAdicExpansion<M,INT>& n)CO NE{RE 0 <= comp(n);}TE <int M,TY INT> IN bool SparseAdicExpansion<M,INT>::OP<(CO SparseAdicExpansion<M,INT>& n)CO NE{RE 0 < comp(n);}TE <int M,TY INT>int SparseAdicExpansion<M,INT>::comp(CO SparseAdicExpansion<M,INT>& n)CO NE{INT a = 0,d;auto IT0 = m_digit.rBE(),EN0 = m_digit.rend(),IT1 = n.m_digit.rBE(),EN1 = n.m_digit.rend();WH(abs(a)<= 1 && IT0 != EN0 && IT1 != EN1){auto&[d0,c0]= *IT0;auto&[d1,c1]= *IT1;if(a == 0){if(d0 < d1){a = c1;}else if(d1 < d0){a = -c0;}else{a = c1 - c0;}if(a == 0){IT0++;IT1++;}else{d = a < 0?d0:d1;}continue;}if(--d !=(a < 0?d0:d1)){break;}a =(d1 == d?c1:0)-(d0 == d?c0:0)+(a < 0?-M:M);}if(a == 0){a =(IT1 == EN1?0:IT1->second)-(IT0 == EN0?0:IT0->second);}RE a > 0?1:a < 0?-1:0;}
#endif

