#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/LinearAlgebra/Rank/Bitset/a_Body.hpp"
#else
#define DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_BITSET(DECL_J)CO size_t M_N = M + N;AS(M_N <= bound_M_N);size_t rank = RowEchelonForm(A,M_N);VE<bool> solvable(N,true);size_t i = rank;WH(--i < rank){CO bitset<bound_M_N>& A_i = A[i];DECL_J;WH(j < M){if(A_i[j]!= 0){break;}j++;}if(j == M){WH(j < M_N){solvable[j]= solvable[j]&& A_i[j]== 0;j++;}rank--;}else{size_t i_curr = i;WH(--i_curr < i){bitset<bound_M_N>& A_i_curr = A[i_curr];if(A_i_curr[j]== 1){A_i_curr ^= A_i;}}}}
TE <size_t bound_M>size_t RowEchelonForm(VE<bitset<bound_M>>& A,CO size_t& M){AS(M <= bound_M);CO size_t L = A.SZ();size_t i_min = 0;size_t i_curr;size_t j_curr = 0;WH(i_min < L && j_curr < M){i_curr = i_min;WH(i_curr < L?A[i_curr][j_curr]== 0:false){i_curr++;}if(i_curr < L){swap(A[i_min],A[i_curr]);CO bitset<bound_M>& A_i_min = A[i_min++];WH(++i_curr < L){bitset<bound_M>& A_i_curr = A[i_curr];if(A_i_curr[j_curr]== 1){A_i_curr ^= A_i_min;}}}j_curr++;}RE i_min;}TE <size_t bound_M_N>pair<size_t,VE<bool>> ExtendedReducedRowEchelonForm(VE<bitset<bound_M_N>>& A,CO size_t& M){CO int L = A.SZ();CE int N = 1;VE<int> left(L,-1);DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_BITSET(size_t& j = left[i]);VE<bool> solution{};if(solvable[0]){solution.resize(M);i = rank;WH(--i >= 0){auto& A_i = A[i];CRI j = left[i];solution[j]= A_i[M];}}RE{rank,MO(solution)};}TE <size_t bound_N,size_t bound_M_N>tuple<size_t,VE<bool>,VE<bitset<bound_N>>> MultiExtendedReducedRowEchelonForm(VE<bitset<bound_M_N>>& A,CO size_t& M,CO size_t& N){AS(N <= bound_N);CO size_t L = A.SZ();VE<size_t> left(L);DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_BITSET(size_t& j = left[i]);VE<bitset<bound_N>> solutions(M,bitset<bound_N>());i = rank;WH(--i < rank){CO bitset<bound_M_N>& A_i = A[i];CO size_t& j = left[i];bitset<bound_N>& solutions_j = solutions[j];for(size_t k = 0;k < N;k++){solutions_j[k]= A_i[M + k];}}RE{rank,MO(solvable),MO(solutions)};}TE <size_t bound_M> IN size_t ReducedRowEchelonForm(VE<bitset<bound_M>>& A,CO size_t& M){RE get<0>(MultiExtendedReducedRowEchelonForm<0>(A,M,0));}TE <size_t bound_M> IN size_t Rank(VE<bitset<bound_M>> A,CO size_t& M){RE ReducedRowEchelonForm(A,M);}TE <size_t bound_L>VE<bitset<bound_L>> Inverse(CO VE<bitset<bound_L>>& A){CO size_t L = A.SZ();VE<bitset<bound_L + bound_L>> A_copy(L);for(size_t i = 0;i < L;i++){CO bitset<bound_L>& A_i = A[i];bitset<bound_L + bound_L>& A_copy_i = A_copy[i];for(size_t j = 0;j < L;j++){A_copy_i[j]= A_i[j];}for(size_t j = 0;j < L;j++){A_copy_i[L + j]= i == j?1:0;}}auto[rank,solvable,AN]= MultiExtendedReducedRowEchelonForm(A_copy,L,L);if(rank != L){AN.clear();}RE AN;}TE <size_t bound_L,size_t bound_M>pair<int,VE<bool>> LinearRelation(CO VE<bitset<bound_M>>& A,CO size_t& M){CO size_t L = A.SZ();CO size_t rank = ReducedRowEchelonForm(A,M);VE<bool> coeff{};if(rank < M){coeff.resize(M);int j = 0;WH(j < L && A[j][j]!= 0){j++;}for(int i = 0;i < j;i++){coeff[i]= A[i][j]== 1;}coeff[j]= true;}RE{rank,MO(coeff)};}
#endif
