// TÇ…ìnÇ∑å^ÇÃcompressÇêÊÇ…ì\ÇÈÅB
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/LinearAlgebra/a_Body.hpp"
#else
#define MA Matrix

#define SFINAE_FOR_MA(DEFAULT) TY Arg,enable_if_t<is_constructible<T,Arg>::value>* DEFAULT

TE <uint Y,uint X,TY T>CL MA{PU:T m_M[Y][X];IN MA()NE;IN MA(CO T& t)NE;IN MA(CRI t)NE;TE <TY Arg0,TY Arg1,TY... Args> IN MA(Arg0&& t0,Arg1&& t1,Args&&... args)NE;IN MA(CO MA<Y,X,T>& mat)NE;IN MA(MA<Y,X,T>&& mat)NE;TE <TY... Args> IN MA(CO T (&mat)[Y][X])NE;TE <TY... Args> IN MA(T (&&mat)[Y][X])NE;IN MA<Y,X,T>& OP=(CO MA<Y,X,T>& mat)NE;IN MA<Y,X,T>& OP=(MA<Y,X,T>&& mat)NE;IN MA<Y,X,T>& OP=(CO T (&mat)[Y][X])NE;IN MA<Y,X,T>& OP=(T (&&mat)[Y][X])NE;IN MA<Y,X,T>& OP+=(CO MA<Y,X,T>& mat)NE;IN MA<Y,X,T>& OP-=(CO MA<Y,X,T>& mat)NE;IN MA<Y,X,T>& OP*=(CO T& scalar)NE;IN MA<Y,X,T>& OP*=(CO MA<X,X,T>& mat)NE;IN MA<Y,X,T>& OP/=(CO T& scalar);IN MA<Y,X,T>& OP%=(CO T& scalar);IN bool OP==(CO MA<Y,X,T>& mat) CO NE;TE <uint Z> IN MA<Y,Z,T> OP*(CO MA<X,Z,T>& mat) CO NE;IN MA<X,Y,T> Transpose() CO NE;IN T Trace() CO NE;IN CO T(&OP[](CRUI y)CO)[X];IN T(&OP[](CRUI y))[X];ST IN CO MA<Y,X,T>& Zero()NE;ST IN CO MA<Y,X,T>& One()NE;ST IN VO SetArray(T (&M)[Y][X],T (&&array)[Y * X])NE;};

TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA()NE:m_M(){}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CO T& t)NE:m_M(){CE CO uint minXY = Y < X?Y:X;for(uint y = 0;y < minXY;y++){m_M[y][y] = t;}}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CRI t)NE:MA(T(t)){}TE <uint Y,uint X,TY T> TE <TY Arg0,TY Arg1,TY... Args> IN MA<Y,X,T>::MA(Arg0&& t0,Arg1&& t1,Args&&... args)NE:m_M(){T array[Y * X] ={T(forward<Arg0>(t0)),T(forward<Arg1>(t1)),T(forward<Args>(args))...};SetArray(m_M,MO(array));}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CO MA<Y,X,T>& mat)NE:m_M(){OP=(mat.m_M);}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(MA<Y,X,T>&& mat)NE:m_M(){swap(m_M,mat.m_M);}TE <uint Y,uint X,TY T> TE <TY... Args> IN MA<Y,X,T>::MA(CO T (&mat)[Y][X])NE:m_M(){OP=(mat);}TE <uint Y,uint X,TY T> TE <TY... Args> IN MA<Y,X,T>::MA(T (&&mat)[Y][X])NE:m_M(){swap(m_M,mat);}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP=(CO MA<Y,X,T>& mat)NE{RE OP=(mat.m_M);}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP=(MA<Y,X,T>&& mat)NE{RE OP=(MO(mat.m_M));}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP=(CO T (&mat)[Y][X])NE{for(uint y = 0;y < Y;y++){T (&m_M_y)[X] = m_M[y];CO T (&mat_y)[X] = mat[y];for(uint x = 0;x < X;x++){m_M_y[x] = mat_y[x];}}RE *TH;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP=(T (&&mat)[Y][X])NE{swap(m_M,mat);RE *TH;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP+=(CO MA<Y,X,T>& mat)NE{for(uint y = 0;y < Y;y++){T (&m_M_y)[X] = m_M[y];T (&mat_y)[X] = mat.m_M[y];for(uint x = 0;x < X;x++){m_M_y[x] += mat_y[x];}}RE *TH;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP-=(CO MA<Y,X,T>& mat)NE{for(uint y = 0;y < Y;y++){T (&m_M_y)[X] = m_M[y];T (&mat_y)[X] = mat.m_M[y];for(uint x = 0;x < X;x++){m_M_y[x] -= mat_y[x];}}RE *TH;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP*=(CO T& scalar)NE{for(uint y = 0;y < Y;y++){T (&m_M_y)[X] = m_M[y];for(uint x = 0;x < X;x++){m_M_y[x] *= scalar;}}RE *TH;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP*=(CO MA<X,X,T>& mat)NE{RE OP=(MO(*TH * mat));}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP/=(CO T& scalar){RE OP*=(T(1) / scalar);}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::OP%=(CO T& scalar){for(uint y = 0;y < Y;y++){T (&m_M_y)[X] = m_M[y];for(uint x = 0;x < X;x++){m_M_y[x] %= scalar;}}RE *TH;}TE <uint Y,uint X,TY T> TE <uint Z> IN MA<Y,Z,T> MA<Y,X,T>::OP*(CO MA<X,Z,T>& mat) CO NE{MA<Y,Z,T> prod{};for(uint y = 0;y < Y;y++){CO T (&m_M_y)[X] = m_M[y];T (&prod_y)[Z] = prod.m_M[y];for(uint x = 0;x < X;x++){CO T &m_M_yx = m_M_y[x];CO T (&mat_x)[Z] = mat.m_M[x];for(uint z = 0;z < Z;z++){prod_y[z] += m_M_yx * mat_x[z];}}}RE prod;}TE <uint Y,uint X,TY T> IN bool MA<Y,X,T>::OP==(CO MA<Y,X,T>& mat) CO NE{for(uint y = 0;y < Y;y++){CO T (&m_M_y)[X] = m_M[y];CO T (&mat_y)[X] = mat[y];for(uint x = 0;x < X;x++){if(m_M_y[x] != mat_y[x]){RE false;}}}RE true;}TE <uint Y,uint X,TY T> IN MA<X,Y,T> MA<Y,X,T>::Transpose() CO NE{MA<X,Y,T> M_t{};for(uint x = 0;x < X;x++){CO T (&M_t_x)[Y] = M_t.m_M[x];for(uint y = 0;y < Y;y++){M_t_x[y] = m_M[y][x];}}RE M_t;}TE <uint Y,uint X,TY T> IN T MA<Y,X,T>::Trace() CO NE{CE CO uint minXY = Y < X?Y:X;T AN{};for(uint y = 0;y < minXY;y++){AN += m_M[y][y];}RE AN;}TE <uint Y,uint X,TY T> IN CO T(&MA<Y,X,T>::OP[](CRUI y)CO)[X]{AS(y < Y);RE m_M[y];}TE <uint Y,uint X,TY T> IN T(&MA<Y,X,T>::OP[](CRUI y))[X]{AS(y < Y);RE m_M[y];}TE <uint Y,uint X,TY T> IN CO MA<Y,X,T>& MA<Y,X,T>::Zero()NE{ST CO MA<Y,X,T> zero{};RE zero;}TE <uint Y,uint X,TY T> IN CO MA<Y,X,T>& MA<Y,X,T>::One()NE{ST CO MA<Y,X,T> one{1};RE one;}TE <uint Y,uint X,TY T> IN VO MA<Y,X,T>::SetArray(T (&M)[Y][X],T (&&array)[Y * X])NE{uint i = 0;for(uint y = 0;y < Y;y++){T (&M_y)[X] = M[y];for(uint x = 0;x < X;x++){M_y[x] = MO(array[i + x]);}i += X;}}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP!=(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2)NE{RE !(mat1 == mat2);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP+(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2)NE{RE MO(MA<Y,X,T>(mat1) += mat2);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP-(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2)NE{RE MO(MA<Y,X,T>(mat1) -= mat2);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP*(CO MA<Y,X,T>& mat,CO T& scalar)NE{RE MO(MA<Y,X,T>(mat) *= scalar);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP*(CO T& scalar,CO MA<Y,X,T>& mat)NE{RE MO(MA<Y,X,T>(mat) *= scalar);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP/(CO MA<Y,X,T>& mat,CO T& scalar){RE MO(MA<Y,X,T>(mat) /= scalar);}TE <uint Y,uint X,TY T> IN MA<Y,X,T> OP%(CO MA<Y,X,T>& mat,CO T& scalar){RE MO(MA<Y,X,T>(mat) %= scalar);}
#endif
