#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/LinearAlgebra/a_Body.hpp"
#else
// TÇ…ìnÇ∑å^ÇÃcompressÇêÊÇ…ì\ÇÈÅB
#define MA Matrix

TE <TY T>CL MA{PU:int m_Y;int m_X;VE<VE<T>> m_M;IN MA(CRI Y = 0,CRI X = 0)NE;IN MA(CRI Y,CRI X,CO T& t)NE;TE <TY Arg0,TY Arg1,TY... Args> IN MA(CRI Y,CRI X,Arg0&& t0,Arg1&& t1,Args&&... args)NE;IN MA(CO MA<T>& mat)NE;IN MA(MA<T>&& mat)NE;IN MA(CO VE<VE<T>>& mat)NE;IN MA(VE<VE<T>>&& mat)NE;IN MA<T>& OP=(CO MA<T>& mat)NE;IN MA<T>& OP=(MA<T>&& mat)NE;IN MA<T>& OP=(VE<VE<T>> mat);IN MA<T>& OP+=(CO MA<T>& mat);IN MA<T>& OP-=(CO MA<T>& mat);IN MA<T>& OP*=(CO T& scalar)NE;IN MA<T>& OP*=(CO MA<T>& mat);IN MA<T>& OP/=(CO T& scalar);IN MA<T>& OP%=(CO T& scalar);TE <TY INT> IN MA<T>& OP^=(INT EX);IN bool OP==(CO MA<T>& mat)CO NE;IN bool OP!=(CO MA<T>& mat)CO NE;IN MA<T> OP+(CO MA<T>& mat)CO;IN MA<T> OP-(CO MA<T>& mat)CO;IN MA<T> OP*(CO T& scalar)CO NE;IN MA<T> OP*(CO MA<T>& mat)CO;IN MA<T> OP/(CO T& scalar)CO;IN MA<T> OP%(CO T& scalar)CO;TE <TY INT> IN MA<T> OP^(INT EX)CO;IN MA<T> TP()CO NE;IN T Trace()CO NE;IN CRI GetCodomainDimension()CO NE;IN CRI GetDomainDimension()CO NE;IN CO VE<VE<T>>& GetEntry()CO NE;IN VE<VE<T>>& RefEntry()NE;IN CO VE<T>& OP[](CRI y)CO;IN VE<T>& OP[](CRI y);};TE <TY T>CL Vector:PU MA<T>{PU:IN Vector(CRI Y = 0)NE;TE <TY Arg0,TY Arg1,TY... Args> IN Vector(Arg0&& t0,Arg1&& t1,Args&&... args)NE;IN Vector(CO MA<T>& vec)NE;IN Vector(MA<T>&& vec)NE;IN Vector(CO VE<T>& vec)NE;IN Vector(VE<T>&& vec)NE;IN Vector<T>& OP=(CO MA<T>& vec)NE;IN Vector<T>& OP=(MA<T>&& vec)NE;IN Vector<T>& OP=(CO VE<T>& vec);IN CO T& OP[](CRI y)CO;IN T& OP[](CRI y);IN CRI SZ()CO NE;};
TE <TY T> IN MA<T>::MA(CRI Y,CRI X)NE:m_Y(Y),m_X(X),m_M(Y,VE<T>(X)){}TE <TY T> IN Vector<T>::Vector(CRI Y)NE:MA<T>(Y,1){}TE <TY T> IN MA<T>::MA(CRI Y,CRI X,CO T& t)NE:MA(Y,X){CO int minXY = min(X,Y);for(int y = 0;y < minXY;y++){m_M[y][y]= t;};}TE <TY T> TE <TY Arg0,TY Arg1,TY... Args> IN MA<T>::MA(CRI Y,CRI X,Arg0&& t0,Arg1&& t1,Args&&... args)NE:MA(Y,X){VE<T> temp ={T(forward<Arg0>(t0)),T(forward<Arg1>(t1)),T(forward<Args>(args))...};AS(int(temp.SZ())== X * Y);int i = 0;for(int y = 0;y < Y;y++){for(int x = 0;x < X;x++){m_M[y][x]= MO(temp[i++]);}}}TE <TY T> TE <TY Arg0,TY Arg1,TY... Args> IN Vector<T>::Vector(Arg0&& t0,Arg1&& t1,Args&&... args)NE:MA<T>(2 + sizeof...(args),1,forward<Arg0>(t0),forward<Arg1>(t1),forward<Args>(args)...){}TE <TY T> IN MA<T>::MA(CO MA<T>& mat)NE:m_Y(),m_X(),m_M(){*TH = mat.m_M;}TE <TY T> IN Vector<T>::Vector(CO MA<T>& vec)NE:MA<T>(vec){}TE <TY T> IN MA<T>::MA(MA<T>&& mat)NE:m_Y(),m_X(),m_M(){*TH = MO(mat.m_M);}TE <TY T> IN Vector<T>::Vector(MA<T>&& vec)NE:MA<T>(MO(vec)){}TE <TY T> IN MA<T>::MA(CO VE<VE<T>>& mat)NE:m_Y(),m_X(),m_M(){*TH = mat;}TE <TY T> IN Vector<T>::Vector(CO VE<T>& vec)NE:MA<T>(){*TH = vec;}TE <TY T> IN MA<T>::MA(VE<VE<T>>&& mat)NE:m_Y(),m_X(),m_M(){*TH = MO(mat);}TE <TY T> IN Vector<T>::Vector(VE<T>&& vec)NE:MA<T>(){*TH = MO(vec);}TE <TY T> IN MA<T>& MA<T>::OP=(CO MA<T>& mat)NE{RE *TH = mat.m_M;}TE <TY T> IN Vector<T>& Vector<T>::OP=(CO MA<T>& vec)NE{MA<T>& mat = *TH;mat = vec;AS(TH->m_X == 1);RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP=(MA<T>&& mat)NE{RE *TH = MO(mat.m_M);}TE <TY T> IN Vector<T>& Vector<T>::OP=(MA<T>&& vec)NE{MA<T>& mat = *TH;mat = MO(vec);AS(TH->m_X == 1);RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP=(VE<VE<T>> mat){m_M = MO(mat);m_X =(m_Y = m_M.SZ())> 0?int(m_M[0].SZ()):0;for(int y = 1;y < m_Y;y++){AS(int(m_M[y].SZ())== m_X);}RE *TH;}TE <TY T> IN Vector<T>& Vector<T>::OP=(CO VE<T>& vec){TH->m_M.resize(TH->m_Y = vec.SZ(),VE<T>(TH->m_X = 1));for(int y = 0;y < TH->m_Y;y++){TH->m_M[y][0]= vec[y];}RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP+=(CO MA<T>& mat){AS(m_X == mat.m_X && m_Y == mat.m_Y);for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];auto& mat_y = mat.m_M[y];for(int x = 0;x < m_X;x++){m_M_y[x]+= mat_y[x];}}RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP-=(CO MA<T>& mat){AS(m_X == mat.m_X && m_Y == mat.m_Y);for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];auto& mat_y = mat.m_M[y];for(int x = 0;x < m_X;x++){m_M_y[x]-= mat_y[x];}}RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP*=(CO T& scalar)NE{for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];for(int x = 0;x < m_X;x++){m_M_y[x]*= scalar;}}RE *TH;}TE <TY T> IN MA<T>& MA<T>::OP*=(CO MA<T>& mat){RE OP=(MO(*TH * mat));}TE <TY T> IN MA<T>& MA<T>::OP/=(CO T& scalar){RE OP*=(T(1)/ scalar);}TE <TY T> IN MA<T>& MA<T>::OP%=(CO T& scalar){for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];for(int x = 0;x < m_X;x++){m_M_y[x]%= scalar;}}RE *TH;}TE <TY T> TE <TY INT> IN MA<T>& MA<T>::OP^=(INT EX){AS(m_X == m_Y && EX >= 0);MA<T> pw{m_X,m_Y,1};WH(EX > 0){(EX& 1)== 1?pw *= *TH:pw;*TH *= *TH;EX >>= 1;}RE *TH = MO(pw);}TE <TY T> IN bool MA<T>::OP==(CO MA<T>& mat)CO NE{if(m_X != mat.m_X || m_Y != mat.m_Y){RE false;}for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];auto& mat_y = mat[y];for(int x = 0;x < m_X;x++){if(m_M_y[x]!= mat_y[x]){RE false;}}}RE true;}TE <TY T> IN bool MA<T>::OP!=(CO MA<T>& mat)CO NE{RE !(*TH == mat);}TE <TY T> IN MA<T> MA<T>::OP+(CO MA<T>& mat)CO{RE MO(MA<T>(*TH)+= mat);}TE <TY T> IN MA<T> MA<T>::OP-(CO MA<T>& mat)CO{RE MO(MA<T>(*TH)-= mat);}TE <TY T> IN MA<T> MA<T>::OP*(CO T& scalar)CO NE{RE MO(MA<T>(*TH)*= scalar);}TE <TY T> IN MA<T> MA<T>::OP*(CO MA<T>& mat)CO{AS(m_X == mat.m_Y);MA<T> prod{m_Y,mat.m_X};for(int y = 0;y < m_Y;y++){auto& m_M_y = m_M[y];auto& prod_y = prod.m_M[y];for(int x = 0;x < m_X;x++){auto& m_M_yx = m_M_y[x];auto& mat_x = mat.m_M[x];for(int z = 0;z < mat.m_X;z++){prod_y[z]+= m_M_yx * mat_x[z];}}}RE prod;}TE <TY T> IN MA<T> MA<T>::OP/(CO T& scalar)CO{RE MO(MA<T>(*TH)/= scalar);}TE <TY T> IN MA<T> MA<T>::OP%(CO T& scalar)CO{RE MO(MA<T>(*TH)%= scalar);}TE <TY T> TE <TY INT> IN MA<T> MA<T>::OP^(INT EX)CO{RE MO(MA<T>(*TH)%= MO(EX));}TE <TY T> IN MA<T> MA<T>::TP()CO NE{MA<T> M_t{m_Y,m_X};for(int x = 0;x < m_X;x++){auto& M_t_x = M_t.m_M[x];for(int y = 0;y < m_Y;y++){M_t_x[y]= m_M[y][x];}}RE M_t;}TE <TY T> IN T MA<T>::Trace()CO NE{CE CO int minXY = min(m_X,m_Y);T AN{};for(int y = 0;y < minXY;y++){AN += m_M[y][y];}RE AN;}TE <TY T> IN CRI MA<T>::GetCodomainDimension()CO NE{RE m_Y;}TE <TY T> IN CRI MA<T>::GetDomainDimension()CO NE{RE m_X;}TE <TY T> IN CO VE<VE<T>>& MA<T>::GetEntry()CO NE{RE m_M;}TE <TY T> IN CRI Vector<T>::SZ()CO NE{RE TH->m_Y;}TE <TY T> IN CO VE<T>& MA<T>::OP[](CRI y)CO{AS(0 <= y && y < m_Y);RE m_M[y];}TE <TY T> IN CO T& Vector<T>::OP[](CRI y)CO{AS(0 <= y && y < TH->m_Y);RE TH->m_M[y][0];}TE <TY T> IN VE<T>& MA<T>::OP[](CRI y){AS(0 <= y && y < m_Y);RE m_M[y];}TE <TY T> IN T& Vector<T>::OP[](CRI y){AS(0 <= y && y < TH->m_Y);RE TH->m_M[y][0];}TE <TY T> IN MA<T> OP*(CO T& scalar,CO MA<T>& mat)NE{RE mat * scalar;}TE <TY T,TY INT> IN MA<T> Power(MA<T> mat,INT EX){RE MO(mat ^= MO(EX));}TE <TY T,TY INT> IN MA<T> Act(MA<T> mat,INT EX,MA<T> v){AS(EX >= 0);WH(EX > 0){(EX & 1)== 0?v:v = mat * v;mat *= mat;EX >>= 1;}RE MO(v);}TE <TY T,CL Traits> IN OS& OP<<(OS& os,CO Vector<T>& v){auto& Y = v.SZ();for(int y = 0;y < Y;y++){(y == 0?os:os << ' ')<< v[y];}RE os;}
#endif

