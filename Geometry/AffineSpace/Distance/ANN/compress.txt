#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/AffineSpace/Distance/ANN/a_Body.hpp"
#else
TE <TY Dist2,TY INT>VE<VE<int>> TwoDimensionalAllNearestNeighbour(CO Dist2& d2,CO VE<pair<INT,INT>>& S){CO int S_SZ = S.SZ();AS(S_SZ != 1);if(S_SZ == 0){RE{};}auto[x_min,y_min]= S[0];auto[x_max,y_max]= S[0];for(int i = 1;i < S_SZ;i++){auto&[x,y]= S[i];x_min = min(x_min,x);x_max = max(x,x_max);y_min = min(y_min,y);y_max = max(y,y_max);}US Block = tuple<INT,INT,INT,INT,VE<int>>;VE<pair<bool,int>> location(S_SZ,{true,0});VE<VE<pair<bool,int>>> neighbours(S_SZ);VE<bool> updatable(S_SZ,true);VE<Block> divisible_block ={{x_min,x_max,y_min,y_max,VE<int>(S_SZ)}};for(i,0,S_SZ){get<4>(divisible_block[0])[i]= i;}VE<Block> indivisible_block ={};WH(!divisible_block.empty()){CO int divisible_block_SZ = divisible_block.SZ();VE<Block> next_divisible_block{};VE<VE<pair<bool,int>>> Partition(divisible_block_SZ);for(int num = 0;num < divisible_block_SZ;num++){auto&[x_min,x_max,y_min,y_max,s]= divisible_block[num];CO int s_SZ = s.SZ();VE<pair<INT,int>> x_sort(s_SZ),y_sort(s_SZ);for(int j = 0;j < t_SZ;j++){x_sort[j]={S[s[j]].first,j};y_sort[j]={S[s[j]].second,j};}sort(x_sort.BE(),x_sort.EN());sort(y_sort.BE(),y_sort.EN());VE<int> x_ord(s_SZ),y_ord(s_SZ);for(int i = 0;i < s_SZ;i++){x_ord[x_sort[i].second]= y_ord[y_sort[i].second]= i;}Block block_sub[2][2]{};CO int s_SZ_half = s_SZ >> 1;for(int i = 0;i < s_SZ;i++){auto&[x,y]= S[s[i]];CO int num_x = x_ord[i]< s_SZ_half?0:1;CO int num_y = y_ord[i]< s_SZ_half?0:1;auto&[x_min_sub,x_max_sub,y_min_sub,y_max_sub,s_sub]= block_sub[num_x][num_y];if(s_sub.empty()){x_min_sub = x_max_sub = x;y_min_sub = y_max_sub = y;}else{x_min_sub = min(x_min_sub,x);x_max_sub = max(x,x_max_sub);y_min_sub = min(y_min_sub,y);y_max_sub = max(y,y_max_sub);}s_sub.push_back(s[i]);}for(int num_x = 0;num_x <= 1;num_x++){for(int num_y = 0;num_y <= 1;num_y++){Block& block_xy = block_sub[num_x][num_y];CO int s_sub_SZ = get<4>(block_xy).SZ();if(s_sub_SZ > 0){if(s_sub_SZ == 1){Partition[num].push_back({false,indivisible_block.SZ()});indivisible_block.push_back(MO(block_xy));}else{Partition[num].push_back({true,next_divisible_block.SZ()});next_divisible_block.push_back(MO(block_xy));}}}}}divisible_block = MO(next_divisible_block);VE<VE<pair<bool,int>>> neighbour_partition(S_SZ);for(int num = 0;num < divisible_block_SZ;num++){for(auto& coord1:Partition[num]){auto&[divisible_sub1,num_sub1]= coord1;for(auto& i:get<2>((divisible_sub1?divisible_block:indivisible_block)[num_sub1])){if(updatable[i]){location[i]= coord1;for(auto& coord2:Partition[num]){if(coord1 != coord2){neighbour_partition[i].push_back(coord2);}}}}}}for(int i = 0;i < S_SZ;i++){if(!updatable[i]){continue;}auto&[divisible_i,num_i]= location[i];updatable[i]= get<4>((divisible_i?divisible_block:indivisible_block)[num_i]).SZ()> 1;for(auto& coord:neighbours[i]){auto&[divisible,num]= coord;if(divisible){for(auto& coord_sub:Partition[num]){neighbour_partition[i].push_back(coord_sub);}}else{neighbour_partition[i].push_back(coord);}}auto&[x,y]= S[i];auto d2_max =[&](CO pair<bool,int>& coord){auto&[divisible,num]= coord;auto&[x_min,x_max,y_min,y_max,x_set,y_set]=(divisible?divisible_block:indivisible_block)[num];RE d2({0,0},{max(abs(x - x_min),abs(x_max - x)),max(abs(y - y_min),abs(y_max - y))});};auto d2_min =[&](CO pair<bool,int>& coord){auto&[divisible,num]= coord;auto&[x_min,x_max,y_min,y_max,x_set,y_set]=(divisible?divisible_block:indivisible_block)[num];RE d2(S[i],{x < x_min?x_min:x_max < x?x_max:x,y < y_min?y_min:y_max < y?y_max:y});};CO int neighbour_partition_SZ = neighbour_partition[i].SZ();AS(neighbour_partition_SZ > 0);decltype(d2({0,0},{0,0}))d2_max_min = d2_max(neighbour_partition[i][0]);for(int num = 1;num < neighbour_partition_SZ;num++){d2_max_min = min(d2_max_min,d2_max(neighbour_partition[i][num]));}neighbours[i].clear();for(int num = 0;num < neighbour_partition_SZ;num++){if(d2_min(neighbour_partition[i][num])<= d2_max_min){updatable[i]= updatable[i]|| neighbour_partition[i][num].first;neighbours[i].push_back(MO(neighbour_partition[i][num]));}}neighbour_partition[i].clear();}}VE<VE<int>> AN(S_SZ);for(int i = 0;i < S_SZ;i++){for(auto&[divisible,num]:neighbours[i]){AS(!divisible);auto&[x_min,x_max,y_min,y_max,s]= indivisible_block[num];AS(s.SZ()== 1);CRI j = s[0];AS(x_min == x_max && x_min == S[j].first && y_min == y_max && y_min == S[j].second);AN[i].push_back(j);}}RE AN;}TE <TY Dist2,TY INT>VE<VE<int>> TwoDimensionalAllNearestNeighbour(CO Dist2& d2,CO VE<pair<INT,INT>>& S,CO VE<pair<INT,INT>>& T){CO int S_SZ = S.SZ();if(S_SZ == 0){RE{};}CO int T_SZ = T.SZ();AS(T_SZ > 0);if(T_SZ == 1){RE VE(S_SZ,VE<int>{0});}auto[x_min,y_min]= T[0];auto[x_max,y_max]= T[0];for(int j = 1;j < T_SZ;j++){auto&[x,y]= T[j];x_min = min(x_min,x);x_max = max(x,x_max);y_min = min(y_min,y);y_max = max(y,y_max);}US Block = tuple<INT,INT,INT,INT,VE<int>>;VE<VE<pair<bool,int>>> neighbours(S_SZ,{{true,0}});VE<bool> updatable(S_SZ,true);VE<Block> divisible_block ={{x_min,x_max,y_min,y_max,VE<int>(T_SZ)}};for(int j = 0;j < T_SZ;j++){get<4>(divisible_block[0])[j]= j;}VE<Block> indivisible_block ={};WH(!divisible_block.empty()){CO int divisible_block_SZ = divisible_block.SZ();VE<Block> next_divisible_block{};VE<VE<pair<bool,int>>> Partition(divisible_block_SZ);for(int num = 0;num < divisible_block_SZ;num++){auto&[x_min,x_max,y_min,y_max,t]= divisible_block[num];CO int t_SZ = t.SZ();VE<pair<INT,int>> x_sort(t_SZ),y_sort(t_SZ);for(int j = 0;j < t_SZ;j++){x_sort[j]={T[t[j]].first,j};y_sort[j]={T[t[j]].second,j};}sort(x_sort.BE(),x_sort.EN());sort(y_sort.BE(),y_sort.EN());VE<int> x_ord(t_SZ),y_ord(t_SZ);for(int j = 0;j < t_SZ;j++){x_ord[x_sort[j].second]= y_ord[y_sort[j].second]= j;}Block block_sub[2][2]{};CO int t_SZ_half = t_SZ >> 1;for(int j = 0;j < t_SZ;j++){auto&[x,y]= T[t[j]];CO int num_x = x_ord[j]< t_SZ_half?0:1;CO int num_y = y_ord[j]< t_SZ_half?0:1;auto&[x_min_sub,x_max_sub,y_min_sub,y_max_sub,t_sub]= block_sub[num_x][num_y];if(t_sub.empty()){x_min_sub = x_max_sub = x;y_min_sub = y_max_sub = y;}else{x_min_sub = min(x_min_sub,x);x_max_sub = max(x,x_max_sub);y_min_sub = min(y_min_sub,y);y_max_sub = max(y,y_max_sub);}t_sub.push_back(t[j]);}for(int num_x = 0;num_x <= 1;num_x++){for(int num_y = 0;num_y <= 1;num_y++){Block& block_xy = block_sub[num_x][num_y];CO int t_sub_SZ = get<4>(block_xy).SZ();if(t_sub_SZ > 0){if(t_sub_SZ == 1){Partition[num].push_back({false,indivisible_block.SZ()});indivisible_block.push_back(MO(block_xy));}else{Partition[num].push_back({true,next_divisible_block.SZ()});next_divisible_block.push_back(MO(block_xy));}}}}}divisible_block = MO(next_divisible_block);for(int i = 0;i < S_SZ;i++){if(updatable[i]){updatable[i]= false;VE<pair<bool,int>> neighbour_partition{};for(auto& coord:neighbours[i]){auto&[divisible,num]= coord;if(divisible){for(auto& coord_sub:Partition[num]){neighbour_partition.push_back(coord_sub);}}else{neighbour_partition.push_back(coord);}}auto&[x,y]= S[i];auto d2_max =[&](CO pair<bool,int>& coord){auto&[divisible,num]= coord;auto&[x_min,x_max,y_min,y_max,t]=(divisible?divisible_block:indivisible_block)[num];RE d2({0,0},{max(abs(x - x_min),abs(x_max - x)),max(abs(y - y_min),abs(y_max - y))});};auto d2_min =[&](CO pair<bool,int>& coord){auto&[divisible,num]= coord;auto&[x_min,x_max,y_min,y_max,t]=(divisible?divisible_block:indivisible_block)[num];RE d2(S[i],{x < x_min?x_min:x_max < x?x_max:x,y < y_min?y_min:y_max < y?y_max:y});};CO int neighbour_partition_SZ = neighbour_partition.SZ();AS(neighbour_partition_SZ > 0);decltype(d2({0,0},{0,0}))d2_max_min = d2_max(neighbour_partition[0]);for(int num = 1;num < neighbour_partition_SZ;num++){d2_max_min = min(d2_max_min,d2_max(neighbour_partition[num]));}neighbours[i].clear();for(int num = 0;num < neighbour_partition_SZ;num++){if(d2_min(neighbour_partition[num])<= d2_max_min){updatable[i]= updatable[i]|| neighbour_partition[num].first;neighbours[i].push_back(MO(neighbour_partition[num]));}}}}}VE<VE<int>> AN(S_SZ);for(int i = 0;i < S_SZ;i++){for(auto&[divisible,num]:neighbours[i]){AS(!divisible);auto&[x_min,x_max,y_min,y_max,t]= indivisible_block[num];AS(t.SZ()== 1);CRI j = t[0];AS(x_min == x_max && x_min == T[j].first && y_min == y_max && y_min == T[j].second);AN[i].push_back(j);}}RE AN;}
#endif

