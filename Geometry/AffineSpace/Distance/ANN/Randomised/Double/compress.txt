#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/AffineSpace/Distance/ANN/Randomised/Double/a_Body.hpp"
#else
#define DF_OF_RANDOMISED_DOUBLE_ANN_BODY(RESET)CO double d_temp = d(S[i],T[line[j].second]);if(d_opt > d_temp){RESET;d_opt = d_temp;AN[i]= line[j].second;}else if(abs(line[j].first - proj_i.first)> d_opt){break;}
#define DF_OF_RANDOMISED_DOUBLE_ANN(SET_COUNT,CHECK_COUNT,RESET)CO int S_SZ = S.SZ(),T_SZ = T.SZ();if(S_SZ == 0){RE{};}AS(T_SZ > 0);VE<int> AN(S_SZ);VE<pair<double,int>> line(T_SZ);SET_COUNT;WH(CHECK_COUNT){CO double theta = GetRand(-1000,1000)* 0.00314;CO double dx = cos(theta),dy = sin(theta);auto proj =[&](CO pair<INT,INT>& v){RE v.first * dx + v.second * dy;};for(int j = 0;j < T_SZ;j++){line[j]={proj(T[j]),j};}sort(line.BE(),line.EN());for(int i = 0;i < S_SZ;i++){CO pair<double,int> proj_i{proj(S[i]),0};int l = 0,r = T_SZ;WH(l + 1 < r){int m =(l + r)>> 1;(proj_i < line[m]?r:l)= m;}CO int j_min = max(0,l - bucket_SZ);CO int j_max = min(T_SZ - 1,l + bucket_SZ);double d_opt = d(S[i],T[AN[i]]);for(int j = l - 1;j >= j_min;j--){DF_OF_RANDOMISED_DOUBLE_ANN_BODY(RESET);}for(int j = l;j <= j_max;j++){DF_OF_RANDOMISED_DOUBLE_ANN_BODY(RESET);}}}RE AN
TE <TY Dist,TY INT>VE<int> TwoDimensionalAllNearestNeighbourRandomisedDouble(CO Dist& d,CO VE<pair<INT,INT>>& S,CO VE<pair<INT,INT>>& T,CRI bucket_SZ,CRI success_count_bound){DF_OF_RANDOMISED_DOUBLE_ANN(int success_count = 0,success_count++ < success_count_bound,success_count = 0);}TE <TY Dist,TY INT>VE<int> TwoDimensionalAllNearestNeighbourRandomisedDouble(CO Dist& d,CO VE<pair<INT,INT>>& S,CO VE<pair<INT,INT>>& T,CRI bucket_SZ,CO double& time){DF_OF_RANDOMISED_DOUBLE_ANN(chrono::system_clock::time_point watch = chrono::system_clock::now(),static_cast<double>(chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now()- watch).count()/ 1000.0)< time,);}
#endif

