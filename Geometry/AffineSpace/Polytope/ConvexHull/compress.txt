#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/AffineSpace/Polytope/ConvexHull/a_Body.hpp"
#else
#define DF_OF_AREA (x1 - x0)*(y2 - y0)-(y1 - y0)*(x2 - x0)
#define CALL_DF_OF_AREA Area (get<0>(v0),get<1>(v0),get<0>(v1),get<1>(v1),get<0>(v2),get<1>(v2))
IN ll Area_ll(CRL x0,CRL y0,CRL x1,CRL y1,CRL x2,CRL y2){RE DF_OF_AREA;}TE <TY INT> IN ll Area(CO INT& x0,CO INT& y0,CO INT& x1,CO INT& y1,CO INT& x2,CO INT& y2){RE Area_ll(x0,y0,x1,y1,x2,y2);}IN double Area(CO double& x0,CO double& y0,CO double& x1,CO double& y1,CO double& x2,CO double& y2){RE DF_OF_AREA;}TE <TY INT,TE <TY...> TY PAIR> IN ll Area(CO PAIR<INT,INT>& v0,CO PAIR<INT,INT>& v1,CO PAIR<INT,INT>& v2){RE CALL_DF_OF_AREA;}TE <TE <TY...> TY PAIR> IN double Area(CO PAIR<double,double>& v0,CO PAIR<double,double>& v1,CO PAIR<double,double>& v2){RE CALL_DF_OF_AREA;}TE <TY INT,TE <TY...> TY PAIR,TY RET> IN RET Area(CO VE<PAIR<INT,INT>>& v,RET dummy){CRI SZ = v.SZ();AS(SZ > 2);for(int i = 2;i < SZ;i++){dummy += Area(v[0],v[i-1],v[i]);}RE MO(dummy);}

TE <TY INT,TE <TY...> TY PAIR>CL ConvexHull{PU:int m_SZ;set<tuple<int,INT,INT,int>> m_ext_cyc;set<int> m_ext;VE<int> m_non_ext_EN;VE<int> m_interior;IN ConvexHull()= default;TE <TE <TY...> TY VEC> IN ConvexHull(CO VEC<PAIR<INT,INT>>& xy);IN VO insert(CO Pair<INT,INT>& xy);VO insert(CO INT& x,CO INT& y);IN CRI TotalSize()CO NE;IN int ExtremalPointSize()CO NE;IN int NonExtremalEndPointSize()CO NE;IN int EndPointSize()CO NE;IN int InteriorPointSize()CO NE;IN CO set<int>& ExtremalPoints()CO NE;IN CO VE<int>& NonExtremalEndPoints()CO NE;IN CO VE<int>& InteriorPoints()CO NE;};
TE <TY INT,TE <TY...> TY PAIR> TE <TE <TY...> TY VEC> IN ConvexHull<INT,PAIR>::ConvexHull(CO VEC<PAIR<INT,INT>>& xy):ConvexHull(){for(auto& p:xy){insert(p);}}TE <TY INT,TE <TY...> TY PAIR> IN VO ConvexHull<INT,PAIR>::insert(CO Pair<INT,INT>& xy){insert(get<0>(xy),get<1>(xy));}TE <TY INT,TE <TY...> TY PAIR>VO ConvexHull<INT,PAIR>::insert(CO INT& x,CO INT& y){VE<tuple<int,INT,INT,int>> update ={{0,x,y,m_SZ++}};auto EN = m_ext_cyc.EN();US iterator = TY set<tuple<int,INT,INT,int>>::iterator;auto eval =[&](CO iterator& IT){auto[t,x,y,i]= *IT;if(t == 1){x *= -1;y *= -1;}RE tuple{t,x,y,i};};auto decr =[&](iterator& IT)-> iterator&{RE --(IT == m_ext_cyc.BE()?IT = EN:IT);};auto incr =[&](iterator& IT)-> iterator&{RE ++IT == EN?IT = m_ext_cyc.BE():IT;};auto valid =[&](iterator& IT){if(m_ext_cyc.SZ()< 3){RE true;}auto prev = IT,next = IT;auto[t1,x1,y1,i1]= eval(decr(prev));auto[t2,x2,y2,i2]= eval(IT);auto[t3,x3,y3,i3]= eval(incr(next));auto S = Area(x1,y1,x2,y2,x3,y3);if(S > 0 ||(t2 == 0 &&(t3 == 1 || tuple{x3,i3,i3}< tuple{x2,y2,i2}|| tuple{x2,y2,i2}< tuple{x1,y1,i1}))){RE true;}if(S < 0){if(t2 == 0){update.push_back({1,-x2,-y2,i2});}else{m_interior.push_back(i2);}}else{m_non_ext_EN.push_back(i2);}m_ext.erase(i2);IT = m_ext_cyc.erase(IT);if(IT == EN){IT = m_ext_cyc.BE();}RE false;};WH(!update.empty()){auto p = update.back();update.pop_back();m_ext_cyc.insert(p);m_ext.insert(get<3>(p));auto IT = m_ext_cyc.lower_bound(p);if(valid(IT)){auto temp = IT;WH(!valid(decr(temp))){}temp = IT;WH(!valid(incr(temp))){}}}RE;}TE <TY INT,TE <TY...> TY PAIR> IN CRI ConvexHull<INT,PAIR>::TotalSize()CO NE{RE m_SZ;}TE <TY INT,TE <TY...> TY PAIR> IN int ConvexHull<INT,PAIR>::ExtremalPointSize()CO NE{RE m_ext.SZ();}TE <TY INT,TE <TY...> TY PAIR> IN int ConvexHull<INT,PAIR>::NonExtremalEndPointSize()CO NE{RE m_non_ext_EN.SZ();}TE <TY INT,TE <TY...> TY PAIR> IN int ConvexHull<INT,PAIR>::EndPointSize()CO NE{RE ExtremalPointSize()+ NonExtremalEndPointSize();}TE <TY INT,TE <TY...> TY PAIR> IN int ConvexHull<INT,PAIR>::InteriorPointSize()CO NE{RE m_interior.SZ();}TE <TY INT,TE <TY...> TY PAIR> IN CO set<int>& ConvexHull<INT,PAIR>::ExtremalPoints()CO NE{RE m_ext;}TE <TY INT,TE <TY...> TY PAIR> IN CO VE<int>& ConvexHull<INT,PAIR>::NonExtremalEndPoints()CO NE{RE m_non_ext_EN;}TE <TY INT,TE <TY...> TY PAIR> IN CO VE<int>& ConvexHull<INT,PAIR>::InteriorPoints()CO NE{RE m_interior;}
#endif

