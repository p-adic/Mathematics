#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/AffineSpace/Polytope/ConvexHull/a_Body.hpp"
#else
#define DF_OF_AREA (x1 - x0)*(y2 - y0)-(y1 - y0)*(x2 - x0)
#define CALL_DF_OF_AREA Area (get<0>(v0),get<1>(v0),get<0>(v1),get<1>(v1),get<0>(v2),get<1>(v2))
IN ll Area_ll(CRL x0,CRL y0,CRL x1,CRL y1,CRL x2,CRL y2){RE DF_OF_AREA;}TE <TY INT> IN ll Area(CO INT& x0,CO INT& y0,CO INT& x1,CO INT& y1,CO INT& x2,CO INT& y2){RE Area_ll(x0,y0,x1,y1,x2,y2);}IN double Area(CO double& x0,CO double& y0,CO double& x1,CO double& y1,CO double& x2,CO double& y2){RE DF_OF_AREA;}TE <TY INT,TE <TY...> TY PAIR> IN ll Area(CO PAIR<INT,INT>& v0,CO PAIR<INT,INT>& v1,CO PAIR<INT,INT>& v2){RE CALL_DF_OF_AREA;}TE <TE <TY...> TY PAIR> IN double Area(CO PAIR<double,double>& v0,CO PAIR<double,double>& v1,CO PAIR<double,double>& v2){RE CALL_DF_OF_AREA;}TE <TY INT,TE <TY...> TY PAIR,TY RET> IN RET Area(CO VE<PAIR<INT,INT>>& v,RET dummy){CRI SZ = v.SZ();AS(SZ > 2);for(int i = 2;i < SZ;i++){dummy += Area(v[0],v[i-1],v[i]);}RE MO(dummy);}

TE <TY INT>CL ArgumentSortOrder{PU:INT m_x;INT m_y;IN ArgumentSortOrder(INT x,INT y);TE <TY PAIR> bool OP()(CO PAIR& v0,CO PAIR& v1)CO;};
TE <TY INT> IN ArgumentSortOrder<INT>::ArgumentSortOrder(INT x,INT y):m_x(MO(x)),m_y(MO(y)){}TE <TY INT> TE <TY PAIR> IN bool ArgumentSortOrder<INT>::OP()(CO PAIR& v0,CO PAIR& v1)CO{auto&[x0,y0]= v0;auto&[x1,y1]= v1;CO ll S = Area<ll>(m_x,m_y,x0,y0,x1,y1);RE S > 0 ||(S == 0 &&(abs(x0 - m_x)< abs(x1 - m_x)|| abs(y0 - m_y)< abs(y1 - m_y)));}

TE <TY INT>CL ConvexHull{PU:int m_SZ;VE<int> m_ext;Map<int,int> m_ext_inv;VE<int> m_non_ext_EN;VE<int> m_interior;TE <TE <TY...> TY PAIR> ConvexHull(CO VE<PAIR<INT,INT>>& xy);IN CRI TotalSize()CO NE;IN int ExtremalPointSize()CO NE;IN int NonExtremalEndPointSize()CO NE;IN int EndPointSize()CO NE;IN int InteriorPointSize()CO NE;IN CO VE<int>& ExtremalPointIndex()CO NE;IN CO VE<int>& NonExtremalEndPointIndex()CO NE;IN CO VE<int>& InteriorPointIndex()CO NE;IN int Index(CRI i)CO NE;IN int Prev(CRI i)CO NE;IN int Next(CRI i)CO NE;};
TE <TY INT> TE <TE <TY...> TY PAIR>ConvexHull<INT>::ConvexHull(CO VE<PAIR<INT,INT>>& xy):m_SZ(xy.SZ()),m_ext(),m_ext_inv(),m_non_ext_EN(),m_interior(){if(m_SZ > 0){auto[x0,y0]= Min(xy);ArgumentSortOrder ord{x0,y0};auto index_ord =[&](CRI i0,CRI i1){RE ord(xy[i0],xy[i1]);};auto index = id<int>(xy.SZ());sort(index.BE(),index.EN(),index_ord);int L = 0;for(auto& i:index){auto&[x1,y1]= xy[i];if(L > 1){auto&[x2,y2]= xy[m_ext[L-1]];CO ll S = Area<ll>(x2,y2,x1,y1,x0,y0);AS(S >= 0);if(S == 0){m_non_ext_EN <<= pop(m_ext);L--;}}WH(L > 1){auto&[x2,y2]= xy[m_ext[L-1]];auto&[x3,y3]= xy[m_ext[L-2]];CO ll S = Area<ll>(x3,y3,x2,y2,x1,y1);if(S > 0){break;}(S < 0?m_interior:m_non_ext_EN)<<= pop(m_ext);L--;}m_ext <<= i;L++;}for(int i = 0;i < L;i++){m_ext_inv[m_ext[i]]= i;}}}TE <TY INT> IN CRI ConvexHull<INT>::TotalSize()CO NE{RE m_SZ;}TE <TY INT> IN int ConvexHull<INT>::ExtremalPointSize()CO NE{RE m_ext.SZ();}TE <TY INT> IN int ConvexHull<INT>::NonExtremalEndPointSize()CO NE{RE m_non_ext_EN.SZ();}TE <TY INT> IN int ConvexHull<INT>::EndPointSize()CO NE{RE ExtremalPointSize()+ NonExtremalEndPointSize();}TE <TY INT> IN int ConvexHull<INT>::InteriorPointSize()CO NE{RE m_interior.SZ();}TE <TY INT> IN CO VE<int>& ConvexHull<INT>::ExtremalPointIndex()CO NE{RE m_ext;}TE <TY INT> IN CO VE<int>& ConvexHull<INT>::NonExtremalEndPointIndex()CO NE{RE m_non_ext_EN;}TE <TY INT> IN CO VE<int>& ConvexHull<INT>::InteriorPointIndex()CO NE{RE m_interior;}TE <TY INT> IN int ConvexHull<INT>::Index(CRI i)CO NE{auto IT = m_ext_inv.find(i);RE IT == m_ext_inv.EN()?-1:IT->second;}TE <TY INT> IN int ConvexHull<INT>::Prev(CRI i)CO NE{RE m_ext[0]== i?m_ext.back():m_ext[m_ext_inv.at(i)- 1];}TE <TY INT> IN int ConvexHull<INT>::Next(CRI i)CO NE{RE m_ext.back()== i?m_ext[0]:m_ext[m_ext_inv.at(i)+ 1];}
#endif

