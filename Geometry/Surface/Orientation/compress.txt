#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Surface/Orientation/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<pair<int,int>> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<pair<int,int>> LinearEdge::OP()(CRI t){VE<pair<int,int>> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back({t - 1,1});}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back({t + 1,1});}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

TE <TY GRAPH,TY ABEL_GROUP,TY T = inner_t<GRAPH>,TY U = inner_t<ABEL_GROUP>>CL AbstractPotentialisedUnionFindForest{PU:GRAPH& m_G;ABEL_GROUP m_M;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;VE<bool> m_solvable;AbstractPotentialisedUnionFindForest(GRAPH& G,ABEL_GROUP M);T RootOfNode(CO T&);VE<T> GetRoot()CO;IN U Potential(CO T& t0,CO T& t1);IN CRI NodeSize()CO NE;IN CRI RootSize()CO NE;bool Graft(CO T& t0,CO T& t1,CO U& w = U());TE <TY PATH> IN bool Graft(CO T& t0,CO PATH& t1);pair<VE<VE<T>>,VE<bool>> Solvability()NE;};TE <TY U = int>CL PotentialisedUnionFindForest:PU LinearGraph,PU AbstractPotentialisedUnionFindForest<LinearGraph,AdditiveGroup<U>>{PU:IN PotentialisedUnionFindForest(CRI SZ);};
TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::AbstractPotentialisedUnionFindForest(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)),m_root_SZ(m_G.SZ()),m_pred(m_root_SZ),m_height(m_root_SZ,1),m_w(m_root_SZ,m_M.Zero()),m_solvable(m_root_SZ,true){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_pred[i]= i;}for(int i = 0;i < SZ;i++){auto&& s = m_G.Enumeration(i);for(auto& t:m_G.Edge(s)){Graft(s,t);}}}TE <TY U> IN PotentialisedUnionFindForest<U>::PotentialisedUnionFindForest(CRI SZ):LinearGraph(SZ,0),AbstractPotentialisedUnionFindForest<LinearGraph,AdditiveGroup<U>>(*TH,AdditiveGroup<U>()){}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>T AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::RootOfNode(CO T& t){auto&& num = m_G.Enumeration_inv(t);int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));m_solvable[num]= m_solvable[pred1]= m_solvable[pred2];pred1 = pred2 = m_pred[pred2];}RE m_G.Enumeration(pred1);}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>VE<T> AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::GetRoot()CO{VE<T> AN{};AN.reserve(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){if(i == m_pred[i]){AN.push_back(m_G.Enumeration(i));}}RE AN;}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>U AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::Potential(CO T& t0,CO T& t1){AS(RootOfNode(t0)== RootOfNode(t1));RE m_M.Sum(m_w[m_G.Enumeration_inv(t0)],m_M.Inverse(m_w[m_G.Enumeration_inv(t1)]));}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U> IN CRI AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::NodeSize()CO NE{RE m_G.SZ();}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U> IN CRI AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::RootSize()CO NE{RE m_root_SZ;}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>bool AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::Graft(CO T& t0,CO T& t1,CO U& w){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);if(root0 == root1){RE m_solvable[root0]= m_solvable[root0]&& Potential(t0,t1)== w;}auto&& num0 = m_G.Enumeration_inv(t0);auto&& num1 = m_G.Enumeration_inv(t1);auto&& rnum0 = m_G.Enumeration_inv(root0);auto&& rnum1 = m_G.Enumeration_inv(root1);int& height0 = m_height[rnum0];CRI height1 = m_height[rnum1];int reMOd_root,reMOd_node,kept_root;if(height0 < height1){reMOd_root = rnum0;reMOd_node = num0;kept_root = rnum1;m_w[reMOd_root]= m_M.Sum(m_w[reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}reMOd_root = rnum1;reMOd_node = num1;kept_root = rnum0;m_w[reMOd_root]= m_M.Sum(m_w[reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(reMOd_node != reMOd_root){m_w[reMOd_node]= m_M.Sum(m_w[reMOd_node],m_w[reMOd_root]);}m_pred[reMOd_node]= m_pred[reMOd_root]= kept_root;m_root_SZ--;RE m_solvable[kept_root]= m_solvable[kept_root]&& m_solvable[reMOd_root];}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U> TE <TY PATH> IN bool AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::Graft(CO T& t0,CO PATH& t1){RE Graft(t0,get<0>(t1),get<1>(t1));}TE <TY GRAPH,TY ABEL_GROUP,TY T,TY U>pair<VE<VE<T>>,VE<bool>> AbstractPotentialisedUnionFindForest<GRAPH,ABEL_GROUP,T,U>::Solvability()NE{auto roots = GetRoot();Map<T,int> roots_inv{};VE<bool> solvable(m_root_SZ);for(int num = 0;num < m_root_SZ;num++){roots_inv[roots[num]]= num;solvable[num]= m_solvable[m_G.Enumeration_inv(roots[num])];}VE<VE<T>> cc(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){cc[roots_inv[RootOfNode(i)]]<<= m_G.Enumeration(i);}RE{MO(cc),MO(solvable)};}

TE <TY T>pair<VE<VE<T>>,VE<bool>> Orientability(CO VE<VE<T>>& faces){CO int M = faces.SZ();Map<T2<int>,int> edge_num{};US path = Pair<int,bool>;VE<VE<path>> vertex{};VE<VE<path>> edge(M);for(int m = 0;m < M;m++){AS(faces[m].SZ()== 3);for(int i = 0;i < 2;i++){for(int j = i + 1;j < 3;j++){CO T2<int> e{faces[m][i],faces[m][j]};if(In(e,edge_num)){auto& v = vertex[edge_num[e]];v <<= path{m,j-i<2};AS(v.SZ()<= 2);for(int n = 0;n < 2;n++){edge[v[n][O]]<<= path{v[1-n][O],v[0][I]==v[1][I]};}}else{CO int SZ = edge_num.SZ();edge_num[e]= SZ;vertex <<= VE{path{m,j-i<2}};}}}}auto Edge = Get(edge);Graph graph{M,Edge};auto neq =[](bool b0,CO bool& b1){RE MO(b0 ^= b1);};bool unit = false;auto inverse =[](CO bool& b){RE b;};AbstractGroup Mod2{neq,unit,inverse};AbstractPotentialisedUnionFindForest uff{graph,Mod2};RE uff.Solvability();}
#endif

