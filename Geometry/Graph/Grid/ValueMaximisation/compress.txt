#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Grid/ValueMaximisation/a_Body.hpp"
#else
TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY COMM_IDEM_MONOID>CL IdempotentMonoidBIT{PU:COMM_IDEM_MONOID m_M;int m_SZ;VE<U> m_a;VE<U> m_fenwick_0;VE<U> m_fenwick_1;int m_PW;IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ = 0);IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);VO Set(CRI i,CO U& u);VO Multiply(CRI i,CO U& u);VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN CRI SZ()CO NE;IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN CO U& LSBSegmentProduct(CRI j,CO bool& left = true)CO;U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);int Search(CO U& u);IN VO COruct();};TE <TY COMM_IDEM_MONOID> IdempotentMonoidBIT(COMM_IDEM_MONOID M)-> IdempotentMonoidBIT<inner_t<COMM_IDEM_MONOID>,COMM_IDEM_MONOID>;TE <TY U>CL IntervalMaxBIT:PU IdempotentMonoidBIT<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN IntervalMaxBIT(CO U& zero_U,Args&&... args);IN VO SetMax(CRI i,CO U& u);IN VO IntervalSetMax(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMax(CRI j,CO bool& left = true)CO;IN U IntervalMax(CRI i_start,CRI i_final);};TE <TY U>CL IntervalMinBIT:PU IdempotentMonoidBIT<U,MinSemilattice<U>>{PU:TE <TY...Args> IN IntervalMinBIT(CO U& infty_U,Args&&... args);IN VO SetMin(CRI i,CO U& u);IN VO IntervalSetMin(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMin(CRI j,CO bool& left = true)CO;IN U IntervalMin(CRI i_start,CRI i_final);};
TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_a(SZ,m_M.One()),m_fenwick_0(m_SZ + 1,m_M.One()),m_fenwick_1(m_SZ + 1,m_M.One()),m_PW(1){COruct();}TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a):m_M(MO(M)),m_SZ(a.SZ()),m_a(MO(a)),m_fenwick_0(m_SZ + 1),m_fenwick_1(m_SZ + 1),m_PW(1){COruct();for(int i = 0;i < m_SZ;i++){int j = i + 1;U& fenwick_0i = m_fenwick_0[j];fenwick_0i = m_a[i];CO int j_llim = j -(j & -j);j--;WH(j > j_llim){fenwick_0i = m_M.Product(m_fenwick_0[j],fenwick_0i);j -=(j & -j);}}for(int i = m_SZ - 1;i >= 0;i--){int j = i + 1;U& fenwick_1i = m_fenwick_1[j];fenwick_1i = m_a[i];CO int j_ulim = min(j +(j & -j),m_SZ + 1);j++;WH(j < j_ulim){fenwick_1i = m_M.Product(MO(fenwick_1i),m_fenwick_1[j]);j +=(j & -j);}}}TE <TY U> TE <TY...Args> IN IntervalMaxBIT<U>::IntervalMaxBIT(CO U& zero_U,Args&&... args):IdempotentMonoidBIT<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),forward<Args>(args)...){}TE <TY U> TE <TY...Args> IN IntervalMinBIT<U>::IntervalMinBIT(CO U& infty_U,Args&&... args):IdempotentMonoidBIT<U,MinSemilattice<U>>(MinSemilattice<U>(infty_U),forward<Args>(args)...){}TE <TY U,TY COMM_IDEM_MONOID> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::COruct(){ST_AS(is_same_v<U,inner_t<COMM_IDEM_MONOID>>);WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U,TY COMM_IDEM_MONOID> TE <TY...Args> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Initialise(Args&&... args){IdempotentMonoidBIT<U,COMM_IDEM_MONOID> temp{m_M,forward<Args>(args)...};m_SZ = temp.m_SZ;m_a = MO(temp.m_a);m_fenwick_0 = MO(temp.m_fenwick_0);m_fenwick_1 = MO(temp.m_fenwick_1);m_PW = temp.m_PW;}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Set(CRI i,CO U& u){U& ai = m_a[i];if(u == m_M.Product(ai,u)){Multiply(i,u);}else{ai = u;int j = i + 1;int j_minus = j -(j & -j);U temp_left = m_M.Product(IntervalProduct(j_minus,i - 1),ai);U temp_right = m_M.One();WH(j <= m_SZ){m_fenwick_0[j]= m_M.Product(temp_left,temp_right);int j_next = j +(j & -j);int j_minus_next = j_next -(j_next & -j_next);if(j_minus_next != j_minus - 1){temp_left = m_M.Product(IntervalProduct(j_minus_next,j_minus - 1),temp_left);j_minus = j_minus_next;}temp_right = m_M.Product(MO(temp_right),IntervalProduct(j,j_next - 1));j = j_next;}j = i + 1;int j_plus = j +(j & -j)- 1;temp_left = m_M.One();temp_right = m_M.Product(ai,IntervalProduct(j,j_plus - 1));WH(j > 0){m_fenwick_1[j]= m_M.Product(temp_left,temp_right);int j_next = j -(j & -j);int j_plus_next = j_next +(j_next & -j_next)- 1;temp_left = m_M.Product(IntervalProduct(j_next - 1,j - 2),temp_left);j = j_next;if(j_plus != j_plus_next - 1){temp_right = m_M.Product(MO(temp_right),IntervalProduct(j_plus,j_plus_next - 1));j_plus = j_plus_next;}}}RE;}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Multiply(CRI i,CO U& u){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);int j = i + 1;WH(j <= m_SZ){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);j +=(j & -j);}j = i + 1;WH(j > 0){U& tj = m_fenwick_1[j];tj = m_M.Product(MO(tj),u);j -=(j & -j);}RE;}TE <TY U> VO IntervalMaxBIT<U>::SetMax(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U> VO IntervalMinBIT<U>::SetMin(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);for(int i = j_min - 1;i < j_max;i++){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);}CO int j_llim = j_min -(j_min & -j_min);CO int j_ulim = min(j_max +(j_max & j_max),m_SZ + 1);if(j_min <= j_max){int j = j_min;WH(j < j_ulim){if(j -(j & -j)< j_max){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j++;}j = j_max;WH(j > j_llim){if(j +(j & -j)> j_min){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j--;}}RE;}TE <TY U> VO IntervalMaxBIT<U>::IntervalSetMax(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U> VO IntervalMinBIT<U>::IntervalSetMin(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U,TY COMM_IDEM_MONOID> IN CRI IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::SZ()CO NE{RE m_SZ;}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE m_a[i];}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::LSBSegmentProduct(CRI j,CO bool& left)CO{AS(0 < j && j <= m_SZ);RE(left?m_fenwick_0:m_fenwick_1)[j];}TE <TY U> CO U& IntervalMaxBIT<U>::LSBSegmentMax(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U> CO U& IntervalMinBIT<U>::LSBSegmentMin(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U,TY COMM_IDEM_MONOID>U IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);if(j_min > j_max){RE m_M.One();}U AN1 = m_M.One();int j = j_min;int j_next = j +(j & -j);WH(j_next <= j_max){AN1 = m_M.Product(MO(AN1),m_fenwick_1[j]);j = j_next;j_next +=(j & -j);}AN1 = m_M.Product(MO(AN1),m_a[j-1]);U AN0 = m_M.One();j = j_max;j_next = j -(j & -j);WH(j_next >= j_min){AN0 = m_M.Product(MO(AN0),m_fenwick_0[j]);j = j_next;j_next -=(j & -j);}RE m_M.Product(MO(AN1),AN0);}TE <TY U> U IntervalMaxBIT<U>::IntervalMax(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U> U IntervalMinBIT<U>::IntervalMin(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U,TY COMM_IDEM_MONOID> TE <TY F,SFINAE_FOR_BIT_BS> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Search(CO F& f){int j = 0;int PW = m_PW;U product = m_M.One();U product_next = product;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){product_next = m_M.Product(product_next,m_fenwick_0[j_next]);if(f(product_next,j_next - 1)){product_next = product;}else{product = product_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY COMM_IDEM_MONOID> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Search(CO U& u){RE Search([&](CO U& prod,CRI){RE prod == m_M.Product(prod,u);});}

TE <TY INT = ll>CL CoordinateCompress{PU:set<INT> m_r;VE<INT*> m_l;IN CoordinateCompress();IN VO SetR(INT t);TE <TY U,TE <TY...> TY V > IN VO SetR(V<U> a);pair<VE<INT>,unordered_map<INT,int>> GetR();IN VO clearR();IN VO SetL(INT& t);TE <TY U,TE <TY...> TY V > IN VO SetL(V<U>& a);VE<INT> GetL();IN VO clearL();};
TE <TY INT> IN CoordinateCompress<INT>::CoordinateCompress():m_r(),m_l(){}TE <TY INT> IN VO CoordinateCompress<INT>::SetR(INT t){m_r.insert(MO(t));}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetR(V<U> a){for(auto& t:a){SetR(MO(t));}}TE <TY INT>pair<VE<INT>,unordered_map<INT,int>> CoordinateCompress<INT>::GetR(){pair<VE<INT>,unordered_map<INT,int>> AN{};AN.first.resize(m_r.SZ());int i = 0;for(auto t:m_r){AN.first[i]= t;AN.second[t]= i++;}RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearR(){m_r.clear();}TE <TY INT> IN VO CoordinateCompress<INT>::SetL(INT& t){m_l.push_back(&t);}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetL(V<U>& a){for(auto& t:a){SetL(t);}}TE <TY INT>VE<INT> CoordinateCompress<INT>::GetL(){int i = -1;VE<INT> AN{};if(!m_l.empty()){auto comp =[](INT* CO& p0,INT* CO& p1){RE *p0 < *p1;};sort(m_l.BE(),m_l.EN(),comp);INT temp = *(m_l[0])- 1;for(auto p:m_l){*p = temp == *p?i:(AN.push_back(temp = *p),++i);}}RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearL(){m_l.clear();}

TE <TY INT,TY U,TY MONOID>U AbstractGridValueMaximisation_Body(MONOID M,CO INT& W,CO multiset<tuple<INT,INT,U>>& S,CO bool& skippable,CO U& min_U){IntervalMaxBIT a{min_U,VE(W,min_U)};if(skippable){for(auto&[i,j,w]:S){a.SetMax(j,M.Product(a.IntervalMax(0,j),w));}}else{for(auto&[i,j,w]:S){a.Set(j,M.Product(a.IntervalMax(0,j),w));}}RE a.IntervalMax(0,W-1);}TE <TY INT,TY U,TY MONOID>U AbstractGridValueMaximisation(MONOID M,CO INT& W,CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = true,CO U& min_U = U()){multiset<tuple<INT,INT,U>> S{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j && j < W){S.insert({i,j,w});}}RE AbstractGridValueMaximisation_Body<INT,U,MONOID>(MO(M),W,S,skippable,min_U);}TE <TY INT,TY U> IN U GridValueMaximisation(CO INT& W,CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = true,CO U& min_U = U()){RE AbstractGridValueMaximisation<INT,U,AdditiveMonoid<U>>(AdditiveMonoid<U>(),W,v,skippable,min_U);}TE <TY INT,TY U> IN U CompressedGridValueMaximisation(CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = true,CO U& min_U = U()){CoordinateCompress<INT> cc{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j){cc.SetR(j);}}auto[cc_result,cc_result_inv]= cc.GetR();multiset<tuple<INT,INT,U>> S{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j){S.insert({i,cc_result_inv[j],w});}}RE AbstractGridValueMaximisation_Body<INT,U,AdditiveMonoid<U>>(AdditiveMonoid<U>(),INT(cc_result.SZ()),S,skippable,min_U);}
#endif

