#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/DepthFirstSearch/Tree/WeightSum/a_Body.hpp"
#else
TE <TY INT0,TY INT1,TY INT2,TY U = Tuple<INT0,INT1,INT2>>CL TreeWeightGroup:VI PU VirtualGroup<U>,PU PointedSet<U>{PU:IN TreeWeightGroup(CO INT0& zero0,CO INT1& one1,CO INT2& zero2);IN U Product(U u0,CO U& u1);IN U Transfer(CO U& u);IN U ExtEN(U u,CO INT2& w = 1);IN U Cut(U u,CO INT2& w = 1);};TE <TY INT0,TY INT1,TY INT2,TY U> IN TreeWeightGroup<INT0,INT1,INT2,U>::TreeWeightGroup(CO INT0& one0,CO INT1& zero1,CO INT2& zero2):PointedSet<U>({one0,zero1,zero2}){ST_AS(is_same_v<U,Tuple<INT0,INT1,INT2>>);AS(one0 == 1 && zero1 == 0 && zero2 == 0);}TE <TY INT0,TY INT1,TY INT2,TY U> IN U TreeWeightGroup<INT0,INT1,INT2,U>::Product(U u0,CO U& u1){auto&[u00,u01,u02]= u0;auto&[u10,u11,u12]= u1;u02 += u01 *(u10 - 1)+((--u00)* u11 + u12);u01 += u11;u00 += u10;RE MO(u0);}TE <TY INT0,TY INT1,TY INT2,TY U> IN U TreeWeightGroup<INT0,INT1,INT2,U>::Transfer(CO U& u){auto&[u0,u1,u2]= u;INT0 a0 = -u0 + 2;INT1 a1 = -u1;INT2 a2 = -((u2 + u1 *(a0 - 1))+(u0 - 1)* a1);RE{MO(a0),MO(a1),MO(a2)};}TE <TY INT0,TY INT1,TY INT2,TY U> IN U TreeWeightGroup<INT0,INT1,INT2,U>::ExtEN(U u,CO INT2& w){auto&[u0,u1,u2]= u;u2 += u1 +=(u0++)* w;RE MO(u);}TE <TY INT0,TY INT1,TY INT2,TY U> IN U TreeWeightGroup<INT0,INT1,INT2,U>::Cut(U u,CO INT2& w){auto&[u0,u1,u2]= u;--u0;u2 -= u1;u1 -= u0 * w;RE MO(u);}

TE <TY TREE,TY F>ret_t<F> RecursionRootingDP_Body(TREE& T,F& f,CRI i,VE<bool>& checked){US U = ret_t<F>;ST_AS(is_invocable_r_v<U,F,VE<U>,int>);checked[i]= true;auto& ei = T.Edge(i);CO int ei_SZ = ei.SZ();VE<U> temp{};for(int m = 0;m < ei_SZ;m++){auto&& j = T.Vertex(ei[m]);if(checked[j]){continue;}temp.push_back(RootingDP_Body(T,f,j,checked));}RE f(temp,i);}TE <TY TREE,TY F> IN ret_t<F> RecursionRootingDP(TREE& T,F& f,CRI root){VE<bool> checked(T.SZ());RE RecursionRootingDP_Body(T,f,root,checked);}TE <TY TREE,TY VAL,TY RIGHT_ACTION>ret_t<VAL,int> BinaryRootingDP_Body(TREE& T,VAL& val,RIGHT_ACTION& prod,CRI i,VE<bool>& checked){US U = ret_t<VAL,int>;ST_AS(is_invocable_r_v<U,RIGHT_ACTION,U,U,int,int>);checked[i]= true;auto& ei = T.Edge(i);CO int ei_SZ = ei.SZ();U AN = val(i);for(int m = 0;m < ei_SZ;m++){auto&& j = T.Vertex(ei[m]);if(checked[j]){continue;}AN = prod(MO(AN),BinaryRootingDP_Body(T,val,prod,j,checked),i,j);}RE AN;}TE <TY TREE,TY VAL,TY RIGHT_ACTION> IN ret_t<VAL,int> BinaryRootingDP(TREE& T,VAL& val,RIGHT_ACTION& prod,CRI root){VE<bool> checked(T.SZ());RE BinaryRootingDP_Body(T,val,prod,root,checked);}

TE <TY TREE,TY PREV_WEIGHT,TY INT>Tuple<int,INT,INT> TreeWeightSum(CO TREE& T,PREV_WEIGHT pw){TreeWeightGroup twg{0,INT{1},INT{1}};US U = twg::type;auto prod =[&](U u0,CO U& u1,CRI i,CRI j){RE twg.Product(MO(u0),twg.ExtEN(u1,pw(j)));};auto val =[&](CRI i){RE twg.One();};RE BinaryRootingDP(T,val,prod,0);}TE <TY TREE,TY INT> IN Tuple<int,INT,INT> TreeWeightSum(CO TREE& T){RE TreeWeightSum(T,[&](CRI j){RE 1;});}
#endif

