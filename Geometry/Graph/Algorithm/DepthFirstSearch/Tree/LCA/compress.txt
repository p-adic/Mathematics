#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/DepthFirstSearch/Tree/LCA/a_Body.hpp"
#else
// êÊÇ…DepthFirstSearchOnTreeÇì\ÇÈÅB

TE <TY DFST>CL AncestorDoubling{PU:DFST* m_p_dfst;int m_SZ;VE<VE<int>> m_doubling;IN AncestorDoubling(DFST& dfst);int Ancestor(DFST& dfst,int i,int n);tuple<int,int,int> LCA(DFST& dfst,int i,int j);CO VE<int>& Get(CRI d);};
TE <TY DFST> IN AncestorDoubling<DFST>::AncestorDoubling(DFST& dfst):m_p_dfst{&m_dfst},m_SZ(m_p_dfst->SZ()),m_doubling(1,VE<int>(m_SZ,-1)){}TE <TY DFST>int AncestorDoubling<DFST>::Ancestor(int i,int n){AS(0 <= i && i < m_SZ);int d = 0;WH(i != -1 && n != 0){(n & 1)== 1?i = Get(d)[i]):i;d++;n >>= 1;}RE i;}TE <TY DFST>tuple<int,int,int> AncestorDoubling<DFST>::LCA(int i,int j){int i_prev = -1,j_prev = -1;CO int diff = m_p_dfst->Depth(i)- m_p_dfst->Depth(j);if(diff > 0){i = m_p_dfst->Parent(i_prev = Ancestor(i,diff - 1));}else if(diff < 0){j = m_p_dfst->Parent(j_prev = Ancestor(j,- diff - 1));}if(i != j){int d = int(m_doubling.SZ())- 1;WH(Get(d)[i]!= Get(d)[j]){Get(++d);}WH(--d >= 0){if(m_doubling[d][i]!= m_doubling[d][j]){i = m_doubling[d][i];j = m_doubling[d][j];}}i = m_p_dfst->Parent(i_prev = i);j = m_p_dfst->Parent(j_prev = j);AS(i == j);}RE{i,i_prev,j_prev};}TE <TY DFST>CO VE<int>& AncestorDoubling<DFST>::Get(CRI d){AS(d >= 0);int digit = m_doubling.SZ();WH(digit <= d){m_doubling.push_back(VE<int>(m_SZ,-1));for(int i = 0;i < m_SZ;i++){if(m_doubling[digit-1][i]!= -1){m_doubling[digit][i]= m_doubling[digit-1][m_doubling[digit-1][i]];}}digit++;}RE m_doubling[d];}
#endif

