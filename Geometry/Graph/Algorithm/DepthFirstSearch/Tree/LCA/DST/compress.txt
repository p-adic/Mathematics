#define DFS DepthFirstSearch
#define DFST DepthFirstSearchOnTree
#define DST DisjointSparseTable
#define DSTT DisjointSparseTableOnTree
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/DepthFirstSearch/Tree/LCA/DST/a_Body.hpp"
#else
#define VBFS VirtualBreadthFirstSearch

TE <TY T,TY GRAPH>CL VBFS{PU:GRAPH& m_G;T m_not_found;bool m_initialised;LI<T> m_next;VE<bool> m_found;VE<T> m_prev;IN VBFS(GRAPH& G,CO T& not_found);TE <TY Arg> IN VBFS(GRAPH& G,CO T& not_found,Arg&& init);IN VO Initialise();IN VO Initialise(CO T& init);TE <TE <TY...> TY VEC> IN VO Initialise(VEC<T> inits);IN VO Shift(CO T& init);TE <TE <TY...> TY VEC> IN VO Shift(VEC<T> inits);IN CRI SZ()CO NE;IN VE<bool>::reference found(CO T& t);IN CO T& prev(CO T& t);IN T Next();TE <TY U = T> auto GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>;TE <TY U = T> auto GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>;tuple<VE<int>,VE<VE<T>>,int> GetConnectedComponent();VE<T> GetNodeEnumeration();VE<T> GetReversedNodeEnumeration();VI VO Push(LI<T>& next,CO T& t)= 0;TE <TY PATH> IN VO Push(LI<T>& next,CO PATH& p);};
TE <TY T,TY GRAPH> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found):m_G(G),m_not_found(not_found),m_initialised(false),m_next(),m_found(),m_prev(){ST_AS(is_same_v<inner_t<GRAPH>,T>);}TE <TY T,TY GRAPH> TE <TY Arg> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found,Arg&& init):VBFS<T,GRAPH>(G,not_found){Initialise(forward<Arg>(init));}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(){m_initialised = true;CRI V = SZ();m_next.clear();m_found = VE<bool>(V);m_prev = VE<T>(V,m_not_found);}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(CO T& init){auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < SZ());Initialise();m_next.push_back(init);m_found[i]= true;}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Initialise(VEC<T> inits){Initialise();for(auto& init:inits){m_next.push_back(MO(init));}CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);m_found[i]= true;}}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Shift(CO T& init){if(m_initialised){CRI V = SZ();auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < V);m_next.clear();if(! m_found[i]){m_next.push_back(init);m_found[i]= true;}}else{Initialise(init);}}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Shift(VEC<T> inits){if(m_initialised){m_next.clear();CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);if(! m_found[i]){m_next.push_back(u);m_found[i]= true;}}}else{Initialise(MO(inits));}}TE <TY T,TY GRAPH> IN CRI VBFS<T,GRAPH>::SZ()CO NE{RE m_G.SZ();}TE <TY T,TY GRAPH> IN VE<bool>::reference VBFS<T,GRAPH>::found(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_found[i];}TE <TY T,TY GRAPH> IN CO T& VBFS<T,GRAPH>::prev(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_prev[i];}TE <TY T,TY GRAPH> IN T VBFS<T,GRAPH>::Next(){if(m_next.empty()){RE m_not_found;}CO T t_curr = m_next.front();m_next.pop_front();for(auto& t:m_G.Edge(t_curr)){auto&& i = m_G.Enumeration_inv(t);auto&& found_i = m_found[i];if(! found_i){Push(m_next,t);m_prev[i]= t_curr;found_i = true;}}RE t_curr;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>{Map<T,int> AN{};for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[*IT]= 0;}T t;WH((t = Next())!= m_not_found){if(AN.count(t)== 0){AN[t]= AN[m_prev[m_G.Enumeration_inv(t)]]+ 1;}}RE AN;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>{VE AN(SZ(),-1);for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[m_G.Enumeration_inv(*IT)]= 0;}T t;WH((t = Next())!= m_not_found){auto&& i = m_G.Enumeration_inv(t);AN[i]== -1?AN[i]= AN[m_G.Enumeration_inv(m_prev[i])]+ 1:AN[i];}RE AN;}TE <TY T,TY GRAPH>tuple<VE<int>,VE<VE<T>>,int> VBFS<T,GRAPH>::GetConnectedComponent(){ST_AS(!is_same_v<GRAPH,MemorisationGraph<T,decldecay_t(m_G.edge())>>);CRI V = SZ();VE cc_num(V,-1);VE<VE<T>> cc_num_inv{};int count = 0;for(int i = 0;i < V;i++){if(cc_num[i]== -1){Shift(m_G.Enumeration(i));T t = Next();if(t != m_not_found){cc_num_inv.push_back({});WH(t != m_not_found){cc_num[m_G.Enumeration_inv(t)]= count;cc_num_inv[count].push_back(t);t = Next();}count++;}}}RE{MO(cc_num),MO(cc_num_inv),count};}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetNodeEnumeration(){VE<T> AN{};T t = Next();WH(t != m_not_found){AN.push_back(t);t = Next();}RE AN;}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetReversedNodeEnumeration(){VE<T> AN{};VE<T> next{};T t;bool searched;WH(!(searched =(t = Next())== m_not_found)|| !next.empty()){WH(!next.empty()&&(searched || next.back()!= m_prev[m_G.Enumeration_inv(t)])){AN.push_back(next.back());next.pop_back();}if(!searched){next.push_back(t);}}RE AN;}TE <TY T,TY GRAPH> TE <TY PATH> IN VO VBFS<T,GRAPH>::Push(LI<T>& next,CO PATH& p){Push(next,get<0>(p));}

TE <TY T,TY GRAPH>CL DFS:PU VirtualBreadthFirstSearch<T,GRAPH>{PU:TE <TY...Args> IN DFS(GRAPH& G,CO T& not_found,Args&&... args);IN VO Push(LI<T>& next,CO T& t);};
TE <TY T,TY GRAPH> TE <TY...Args> IN DFS<T,GRAPH>::DFS(GRAPH& G,CO T& not_found,Args&&... args):VirtualBreadthFirstSearch<T,GRAPH>(G,not_found,forward<Args>(args)...){}TE <TY T,TY GRAPH> IN VO DFS<T,GRAPH>::Push(LI<T>& next,CO T& t){next.push_front(t);}

TE <TY TREE>CL DFST:PU DFS<int,TREE>,PU PointedSet<int>{PU:VE<int> m_node_num;VE<VE<int>> m_children;VE<int> m_children_num;bool m_set_children;VE<int> m_depth;bool m_set_depth;VE<int> m_height_max;VE<int> m_height_min;bool m_set_height;VE<int> m_heaviness;bool m_set_heaviness;IN DFST(TREE& T,CRI root = 0);IN VO Initialise()= delete;IN VO Initialise(CRI init)= delete;IN VO Shift(CRI init)= delete;IN CRI Root()CO;IN CRI Parent(CRI i);IN CO VE<int>& Children(CRI i);IN CRI Depth(CRI i);IN CRI Height(CRI i,CO bool& maximum = true);IN CRI Heaviness(CRI i);IN int Degree(CRI i);IN bool IsLeaf(CRI i,CRI root = -1);IN CRI NodeNumber(CRI i,CO bool& reversed = false)CO;IN CRI ChildrenNumber(CRI i);TE <TY Ord> IN VO ReorderChildren(Ord& ord);VO SetChildren();VO SetDepth();VO SetHeight();VO SetHeaviness();};
TE <TY TREE> IN DFST<TREE>::DFST(TREE& T,CRI root):DFS<int,TREE>(T,-1,root),PointedSet<int>(root),m_node_num(),m_children(),m_set_children(),m_depth(),m_set_depth(),m_height_max(),m_height_min(),m_set_height(),m_heaviness(),m_set_heaviness(){ST_AS(is_same_v<TREE,Graph<decldecay_t(declval<TREE>().edge())>>);AS(int((m_node_num = TH->GetNodeEnumeration()).SZ())== TH->SZ());}TE <TY TREE> IN CRI DFST<TREE>::Root()CO{RE TH->Point();}TE <TY TREE> IN CRI DFST<TREE>::Parent(CRI i){RE TH->prev(i);}TE <TY TREE> IN CO VE<int>& DFST<TREE>::Children(CRI i){if(!m_set_children){SetChildren();}RE m_children[i];}TE <TY TREE> IN CRI DFST<TREE>::Depth(CRI i){if(!m_set_depth){SetDepth();}RE m_depth[i];}TE <TY TREE> IN CRI DFST<TREE>::Height(CRI i,CO bool& maximum){if(!m_set_height){SetHeight();}RE(maximum?m_height_max:m_height_min)[i];}TE <TY TREE> IN CRI DFST<TREE>::Heaviness(CRI i){if(!m_set_heaviness){SetHeaviness();}RE m_heaviness[i];}TE <TY TREE> IN int DFST<TREE>::Degree(CRI i){RE Children(i).SZ()+(i == Root()?0:1);}TE <TY TREE> IN bool DFST<TREE>::IsLeaf(CRI i,CRI root){AS(-1 <= root && root < TH->SZ());RE Degree(i)== 1 && i !=(root == -1?Root():root);}TE <TY TREE> IN CRI DFST<TREE>::NodeNumber(CRI i,CO bool& reversed)CO{CRI V = TH->SZ();AS(i < V);RE m_node_num[reversed?V - 1 - i:i];}TE <TY TREE> IN CRI DFST<TREE>::ChildrenNumber(CRI i){if(! m_set_children){SetChildren();}RE m_children_num[i];}TE <TY TREE> TE <TY Ord> IN VO DFST<TREE>::ReorderChildren(Ord& ord){CRI V = TH->SZ();for(int i = 0;i < V;i++){sort(m_children[i].BE(),m_children[i].EN(),[&](CRI j,CRI k){RE ord(i,j,k);});CO int L = m_children[i].SZ();for(int j = 0;j < L;j++){m_children_num[m_children[i][j]]= j;}}}TE <TY TREE>VO DFST<TREE>::SetChildren(){AS(!m_set_children);m_set_children = true;CRI V = TH->SZ();m_children.resize(V);m_children_num.resize(V);for(int i = 0;i < V;i++){CRI j = Parent(i);if(j == -1){m_children_num[i]= -1;}else{m_children_num[i]= m_children[j].SZ();m_children[j].push_back(i);}}RE;}TE <TY TREE>VO DFST<TREE>::SetDepth(){AS(!m_set_depth);m_set_depth = true;CRI V = TH->SZ();m_depth.resize(V);for(int n = 1;n < V;n++){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_depth[i]+= m_depth[j]+ 1;}RE;}TE <TY TREE>VO DFST<TREE>::SetHeight(){AS(!m_set_height);m_set_height = true;CRI V = TH->SZ();m_height_max.resize(V);m_height_min.resize(V);for(int n = V - 1;n > 0;n--){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_height_max[j]= max(m_height_max[j],m_height_max[i]+ 1);m_height_min[j]= m_height_min[j]== 0?m_height_min[i]+ 1:min(m_height_min[j],m_height_min[i]+ 1);}RE;}TE <TY TREE>VO DFST<TREE>::SetHeaviness(){AS(!m_set_heaviness);m_set_heaviness = true;CRI V = TH->SZ();m_heaviness.resize(V);for(int n = V - 1;n > 0;n--){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_heaviness[j]+= m_heaviness[i]+ 1;}RE;}

TE <TY TREE>CL EulerTour{PU:TREE& m_T;int m_le;VE<int> m_vertex;VE<VE<int>> m_vertex_inv;EulerTour(TREE& T,CRI root = 0);IN CRI Length()CO NE;IN T2<int> Subtree(CRI t)CO;IN CO VE<int>& Vertex()CO NE;IN CO VE<int>& Vertex_inv(CRI t)CO;};
TE <TY TREE>EulerTour<TREE>::EulerTour(TREE& T,CRI root):m_T(T),m_le(),m_vertex(),m_vertex_inv(T.SZ()){VE<bool> found(T.SZ());VE<int> dfs ={root};int i = 0;WH(!dfs.empty()){CO int t = pop(dfs);m_vertex <<= t;if(!found[t]){found[t]= true;for(auto& v:T.Edge(t)){if(!found[v]){(dfs <<= t)<<= v;}}}m_vertex_inv[t]<<= i++;}m_le = i;}TE <TY TREE> IN CRI EulerTour<TREE>::Length()CO NE{RE m_le;}TE <TY TREE> IN T2<int> EulerTour<TREE>::Subtree(CRI t)CO{RE{m_vertex_inv[t][0],m_vertex_inv[t].back()};}TE <TY TREE> IN CO VE<int>& EulerTour<TREE>::Vertex()CO NE{RE m_vertex;}TE <TY TREE> IN CO VE<int>& EulerTour<TREE>::Vertex_inv(CRI t)CO{RE m_vertex_inv[t];}

TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

TE <TY U,TY MONOID>CL AbstractDST{PU:MONOID m_M;int m_SZ;VE<VE<U>> m_prod;IN AbstractDST(MONOID M,CRI SZ = 0);IN AbstractDST(MONOID M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN U IntervalProduct(CRI i_start,CRI i_final);};TE <TY MONOID,TY...Args> AbstractDST(MONOID M,CO Args&... args)-> AbstractDST<inner_t<MONOID>,MONOID>;TE <TY U>CL DST:PU AbstractDST<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN DST(CO U& zero_U,CO Args&... args);IN U IntervalMax(CRI i_start,CRI i_final);};
TE <TY U,TY MONOID> IN AbstractDST<U,MONOID>::AbstractDST(MONOID M,CRI SZ):AbstractDST(M,VE<U>(SZ,M.One())){}TE <TY U,TY MONOID> IN AbstractDST<U,MONOID>::AbstractDST(MONOID M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_prod(){ST_AS(is_same_v<U,inner_t<MONOID>>);int digit = 1;WH(m_SZ >= 1 << digit){++digit;}m_prod.resize(digit,VE(m_SZ,m_M.One()));for(int v = 0;v < digit;v++){auto& m_prod_v = m_prod[v];int p = 1 << v,p2 = p << 1;for(int j = p;j <= m_SZ;j += p2){CO int i_ulim = min(j + p,m_SZ);if(j < m_SZ){m_prod_v[j]= a[j];for(int i = j + 1;i < i_ulim;i++){m_prod_v[i]= m_M.Product(m_prod_v[i-1],a[i]);}}CO int i_min = j - p;m_prod_v[j-1]= a[j-1];for(int i = j - 2;i >= i_min;i--){m_prod_v[i]= m_M.Product(a[i],m_prod_v[i+1]);}}}}TE <TY U> TE <TY...Args> IN DST<U>::DST(CO U& zero_U,CO Args&... args):AbstractDST<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),args...){}TE <TY U,TY MONOID> TE <TY...Args> IN VO AbstractDST<U,MONOID>::Initialise(CO Args&... args){*TH = AbstractDST(MO(m_M),args...);}TE <TY U,TY MONOID> IN CO U& AbstractDST<U,MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE IntervalProduct(i,i);}TE <TY U,TY MONOID> IN CO U& AbstractDST<U,MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY MONOID> IN U AbstractDST<U,MONOID>::IntervalProduct(CRI i_start,CRI i_final){AS(0 <= i_start && i_start <= i_final && i_final < m_SZ);CO int v = 31 - __builtin_clz(i_start ^(i_final + 1));RE i_final <((i_final + 1)>> v)<< v?m_prod[v][i_start]:m_M.Product(m_prod[v][i_start],m_prod[v][i_final]);}TE <TY U> IN U DST<U>::IntervalMax(CRI i_start,CRI i_final) {RE TH->IntervalProduct(i_start,i_final);}

TE <TY TREE>CL DSTT:PU DFST<TREE>,PU EulerTour<TREE>{PU:VE<int> m_vertex;DST<int> m_dst;IN DSTT(TREE& T,CRI root = 0);IN int LCA(CRI i,CRI j);IN int d(CRI i,CRI j);VE<int> HeightArray();};
TE <TY TREE> IN DSTT<TREE>::DSTT(TREE& T,CRI root):DFST<TREE>(T,root),EulerTour<TREE>(T,root),m_vertex(id<int>(T.SZ())),m_dst(0,HeightArray()){}TE <TY TREE>VE<int> DSTT<TREE>::HeightArray(){sort(m_vertex.BE(),m_vertex.EN(),[&](CRI i,CRI j){RE TH->Depth(i)> TH->Depth(j);});CRI SZ0 = TH->SZ();auto& et = TH->Vertex();CO int SZ1 = et.SZ();VE<int> index(SZ0),AN(SZ1);for(int i = 0;i < SZ0;i++){index[m_vertex[i]]= i;}for(int i = 0;i < SZ1;i++){AN[i]= index[et[i]];}RE AN;}TE <TY TREE> IN int DSTT<TREE>::LCA(CRI i,CRI j){auto[li,ri]= TH->Subtree(i);auto[lj,rj]= TH->Subtree(j);RE m_vertex[m_dst.IntervalMax(min(li,lj),max(ri,rj))];}TE <TY TREE> IN int DSTT<TREE>::d(CRI i,CRI j){RE TH->Depth(i)- 2 * TH->Depth(LCA(i,j))+ TH->Depth(j);}
#endif

