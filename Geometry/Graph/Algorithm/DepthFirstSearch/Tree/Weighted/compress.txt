#define DFS DepthFirstSearch
#define DFST DepthFirstSearchOnTree
#define DFSWT DepthFirstSearchOnWeightedTree
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/DepthFirstSearch/Tree/Weighted/a_Body.hpp"
#else
#define VBFS VirtualBreadthFirstSearch

TE <TY T,TY GRAPH>CL VBFS{PU:GRAPH& m_G;T m_not_found;bool m_initialised;LI<T> m_next;VE<bool> m_found;VE<T> m_prev;IN VBFS(GRAPH& G,CO T& not_found);TE <TY Arg> IN VBFS(GRAPH& G,CO T& not_found,Arg&& init);IN VO Initialise();IN VO Initialise(CO T& init);TE <TE <TY...> TY VEC> IN VO Initialise(VEC<T> inits);IN VO Shift(CO T& init);TE <TE <TY...> TY VEC> IN VO Shift(VEC<T> inits);IN CRI SZ()CO NE;IN VE<bool>::reference found(CO T& t);IN CO T& prev(CO T& t);IN T Next();TE <TY U = T> auto GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>;TE <TY U = T> auto GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>;tuple<VE<int>,VE<VE<T>>,int> GetConnectedComponent();VE<T> GetNodeEnumeration();VE<T> GetReversedNodeEnumeration();VI VO Push(LI<T>& next,CO T& t)= 0;TE <TY PATH> IN VO Push(LI<T>& next,CO PATH& p);};
TE <TY T,TY GRAPH> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found):m_G(G),m_not_found(not_found),m_initialised(false),m_next(),m_found(),m_prev(){ST_AS(is_same_v<inner_t<GRAPH>,T>);}TE <TY T,TY GRAPH> TE <TY Arg> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found,Arg&& init):VBFS<T,GRAPH>(G,not_found){Initialise(forward<Arg>(init));}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(){m_initialised = true;CRI V = SZ();m_next.clear();m_found = VE<bool>(V);m_prev = VE<T>(V,m_not_found);}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(CO T& init){auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < SZ());Initialise();m_next.push_back(init);m_found[i]= true;}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Initialise(VEC<T> inits){Initialise();for(auto& init:inits){m_next.push_back(MO(init));}CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);m_found[i]= true;}}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Shift(CO T& init){if(m_initialised){CRI V = SZ();auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < V);m_next.clear();if(! m_found[i]){m_next.push_back(init);m_found[i]= true;}}else{Initialise(init);}}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Shift(VEC<T> inits){if(m_initialised){m_next.clear();CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);if(! m_found[i]){m_next.push_back(u);m_found[i]= true;}}}else{Initialise(MO(inits));}}TE <TY T,TY GRAPH> IN CRI VBFS<T,GRAPH>::SZ()CO NE{RE m_G.SZ();}TE <TY T,TY GRAPH> IN VE<bool>::reference VBFS<T,GRAPH>::found(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_found[i];}TE <TY T,TY GRAPH> IN CO T& VBFS<T,GRAPH>::prev(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_prev[i];}TE <TY T,TY GRAPH> IN T VBFS<T,GRAPH>::Next(){if(m_next.empty()){RE m_not_found;}CO T t_curr = m_next.front();m_next.pop_front();for(auto& t:m_G.Edge(t_curr)){auto&& i = m_G.Enumeration_inv(t);auto&& found_i = m_found[i];if(! found_i){Push(m_next,t);m_prev[i]= t_curr;found_i = true;}}RE t_curr;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>{Map<T,int> AN{};for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[*IT]= 0;}T t;WH((t = Next())!= m_not_found){if(AN.count(t)== 0){AN[t]= AN[m_prev[m_G.Enumeration_inv(t)]]+ 1;}}RE AN;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>{VE AN(SZ(),-1);for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[m_G.Enumeration_inv(*IT)]= 0;}T t;WH((t = Next())!= m_not_found){auto&& i = m_G.Enumeration_inv(t);int& AN_i = AN[i];AN_i == -1?AN_i = AN[m_G.Enumeration_inv(m_prev[i])]+ 1:AN_i;}RE AN;}TE <TY T,TY GRAPH>tuple<VE<int>,VE<VE<T>>,int> VBFS<T,GRAPH>::GetConnectedComponent(){ST_AS(!is_same_v<GRAPH,MemorisationGraph<T,decldecay_t(m_G.edge())>>);CRI V = SZ();VE cc_num(V,-1);VE<VE<T>> cc_num_inv{};int count = 0;for(int i = 0;i < V;i++){if(cc_num[i]== -1){Shift(m_G.Enumeration(i));T t = Next();if(t != m_not_found){cc_num_inv.push_back({});WH(t != m_not_found){cc_num[m_G.Enumeration_inv(t)]= count;cc_num_inv[count].push_back(t);t = Next();}count++;}}}RE{MO(cc_num),MO(cc_num_inv),count};}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetNodeEnumeration(){VE<T> AN{};T t = Next();WH(t != m_not_found){AN.push_back(t);t = Next();}RE AN;}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetReversedNodeEnumeration(){VE<T> AN{};VE<T> next{};T t;bool searched;WH(!(searched =(t = Next())== m_not_found)|| !next.empty()){WH(!next.empty()&&(searched || next.back()!= m_prev[m_G.Enumeration_inv(t)])){AN.push_back(next.back());next.pop_back();}if(!searched){next.push_back(t);}}RE AN;}TE <TY T,TY GRAPH> TE <TY PATH> IN VO VBFS<T,GRAPH>::Push(LI<T>& next,CO PATH& p){Push(next,get<0>(p));}

TE <TY T,TY GRAPH>CL DFS:PU VirtualBreadthFirstSearch<T,GRAPH>{PU:TE <TY...Args> IN DFS(GRAPH& G,CO T& not_found,Args&&... args);IN VO Push(LI<T>& next,CO T& t);};
TE <TY T,TY GRAPH> TE <TY...Args> IN DFS<T,GRAPH>::DFS(GRAPH& G,CO T& not_found,Args&&... args):VirtualBreadthFirstSearch<T,GRAPH>(G,not_found,forward<Args>(args)...){}TE <TY T,TY GRAPH> IN VO DFS<T,GRAPH>::Push(LI<T>& next,CO T& t){next.push_front(t);}

TE <TY TREE>CL DFST:PU DFS<int,TREE>,PU PointedSet<int>{PU:VE<int> m_node_num;VE<VE<int>> m_children;VE<int> m_children_num;bool m_set_children;VE<int> m_depth;bool m_set_depth;VE<int> m_height_max;VE<int> m_height_min;bool m_set_height;VE<int> m_heaviness;bool m_set_heaviness;int m_digit;VE<VE<int>> m_doubling;bool m_set_doubling;IN DFST(TREE& T,CRI root = 0,CRI digit = 0);IN VO Initialise()= delete;IN VO Initialise(CRI init)= delete;IN VO Shift(CRI init)= delete;IN CRI Root()CO;IN CRI Parent(CRI i);IN CO VE<int>& Children(CRI i);IN CRI Depth(CRI i);IN CRI Height(CRI i,CO bool& maximum = true);IN CRI Heaviness(CRI i);IN int Degree(CRI i);IN bool IsLeaf(CRI i,CRI root = -1);IN CRI NodeNumber(CRI i,CO bool& reversed = false)CO;IN CRI ChildrenNumber(CRI i);TE <TY Ord> IN VO ReorderChildren(Ord& ord);int Ancestor(int i,int n);IN int LCA(int i,int j);int LCA(int i,int j,int& i_prev,int& j_prev);TE <TY F> ret_t<F> RootingDP(F& f);TE <TY MONOID,TY F,TY G> VE<inner_t<MONOID>> RerootingDP(MONOID M,F& f,G& g);IN tuple<int,int,int> Diameter();VO SetChildren();VO SetDepth();VO SetHeight();VO SetHeaviness();VO SetDoubling();};
TE <TY TREE> IN DFST<TREE>::DFST(TREE& T,CRI root,CRI digit):DFS<int,TREE>(T,-1,root),PointedSet<int>(root),m_node_num(),m_children(),m_set_children(),m_depth(),m_set_depth(),m_height_max(),m_height_min(),m_set_height(),m_heaviness(),m_set_heaviness(),m_digit(digit),m_doubling(m_digit),m_set_doubling(){ST_AS(is_same_v<TREE,Graph<decldecay_t(declval<TREE>().edge())>>);AS(int((m_node_num = TH->GetNodeEnumeration()).SZ())== TH->SZ());}TE <TY TREE> IN CRI DFST<TREE>::Root()CO{RE TH->Point();}TE <TY TREE> IN CRI DFST<TREE>::Parent(CRI i){RE TH->prev(i);}TE <TY TREE> IN CO VE<int>& DFST<TREE>::Children(CRI i){if(! m_set_children){SetChildren();}RE m_children[i];}TE <TY TREE> IN CRI DFST<TREE>::Depth(CRI i){if(!m_set_depth){SetDepth();}RE m_depth[i];}TE <TY TREE> IN CRI DFST<TREE>::Height(CRI i,CO bool& maximum){if(!m_set_height){SetHeight();}RE(maximum?m_height_max:m_height_min)[i];}TE <TY TREE> IN CRI DFST<TREE>::Heaviness(CRI i){if(!m_set_heaviness){SetHeaviness();}RE m_heaviness[i];}TE <TY TREE> IN int DFST<TREE>::Degree(CRI i){RE Children(i).SZ()+(i == Root()?0:1);}TE <TY TREE> IN bool DFST<TREE>::IsLeaf(CRI i,CRI root){AS(-1 <= root && root < TH->SZ());RE Degree(i)== 1 && i !=(root == -1?Root():root);}TE <TY TREE> IN CRI DFST<TREE>::NodeNumber(CRI i,CO bool& reversed)CO{CRI V = TH->SZ();AS(i < V);RE m_node_num[reversed?V - 1 - i:i];}TE <TY TREE> IN CRI DFST<TREE>::ChildrenNumber(CRI i){if(! m_set_children){SetChildren();}RE m_children_num[i];}TE <TY TREE> TE <TY Ord> IN VO DFST<TREE>::ReorderChildren(Ord& ord){CRI V = TH->SZ();for(int i = 0;i < V;i++){sort(m_children[i].BE(),m_children[i].EN(),[&](CRI j,CRI k){RE ord(i,j,k);});CO int L = m_children[i].SZ();for(int j = 0;j < L;j++){m_children_num[m_children[i][j]]= j;}}}TE <TY TREE>int DFST<TREE>::Ancestor(int i,int n){if(!m_set_doubling){SetDoubling();}AS((n >> m_digit)== 0);int d = 0;WH(n != 0){AS((n & 1)== 1?(i = m_doubling[d][i])!= -1:true);d++;n >>= 1;}RE i;}TE <TY TREE> IN int DFST<TREE>::LCA(int i,int j){int i_prev;int j_prev;RE LCA(i,j,i_prev,j_prev);}TE <TY TREE>int DFST<TREE>::LCA(int i,int j,int& i_prev,int& j_prev){i_prev = j_prev = -1;CO int diff = Depth(i)- Depth(j);AS(diff > 0?(i = Parent(i_prev = Ancestor(i,diff - 1)))!= -1:diff < 0?(j = Parent(j_prev = Ancestor(j,- diff - 1)))!= -1:true);if(i != j){if(!m_set_doubling){SetDoubling();}int d = m_digit;WH(--d >= 0){AS(m_doubling[d][i]!= m_doubling[d][j]?(i = m_doubling[d][i])!= -1 &&(j = m_doubling[d][j])!= -1:true);}AS((i = Parent(i_prev = i))==(j = Parent(j_prev = j)));}RE i;}TE <TY TREE>VO DFST<TREE>::SetChildren(){AS(!m_set_children);m_set_children = true;CRI V = TH->SZ();m_children.resize(V);m_children_num.resize(V);for(int i = 0;i < V;i++){CRI j = Parent(i);if(j == -1){m_children_num[i]= -1;}else{m_children_num[i]= m_children[j].SZ();m_children[j].push_back(i);}}RE;}TE <TY TREE>VO DFST<TREE>::SetDepth(){AS(!m_set_depth);m_set_depth = true;CRI V = TH->SZ();m_depth.resize(V);for(int n = 1;n < V;n++){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_depth[i]+= m_depth[j]+ 1;}RE;}TE <TY TREE>VO DFST<TREE>::SetHeight(){AS(!m_set_height);m_set_height = true;CRI V = TH->SZ();m_height_max.resize(V);m_height_min.resize(V);for(int n = V - 1;n > 0;n--){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_height_max[j]= max(m_height_max[j],m_height_max[i]+ 1);m_height_min[j]= m_height_min[j]== 0?m_height_min[i]+ 1:min(m_height_min[j],m_height_min[i]+ 1);}RE;}TE <TY TREE>VO DFST<TREE>::SetHeaviness(){AS(!m_set_heaviness);m_set_heaviness = true;CRI V = TH->SZ();m_heaviness.resize(V);for(int n = V - 1;n > 0;n--){CRI i = m_node_num[n];CRI j = Parent(i);AS(j != -1);m_heaviness[j]+= m_heaviness[i]+ 1;}RE;}TE <TY TREE>VO DFST<TREE>::SetDoubling(){AS(!m_set_doubling);m_set_doubling = true;CRI V = TH->SZ();{m_doubling[0].reserve(V);for(int i = 0;i < V;i++){m_doubling[0].push_back(Parent(i));}}for(int d = 1;d < m_digit;d++){m_doubling[d].reserve(V);for(int i = 0;i < V;i++){m_doubling[d].push_back(m_doubling[d-1][i]== -1?-1:m_doubling[d-1][m_doubling[d-1][i]]);}}RE;}TE <TY TREE> TE <TY F>ret_t<F> DFST<TREE>::RootingDP(F& f){US U = ret_t<F>;ST_AS(is_invocable_r_v<U,F,VE<U>,int>);if(! m_set_children){SetChildren();}CRI V = TH->SZ();VE<VE<U>> children_value(V);U temp;for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);CRI j = Parent(i);temp = f(children_value[i],i);if(j != -1){children_value[j].push_back(temp);}}RE temp;}TE <TY TREE> TE <TY MONOID,TY F,TY G>VE<inner_t<MONOID>> DFST<TREE>::RerootingDP(MONOID M,F& f,G& g){US U = inner_t<MONOID>;ST_AS(is_invocable_r_v<U,F,U,int> && is_invocable_r_v<U,G,U,bool,int,int>);if(! m_set_children){SetChildren();}CRI V = TH->SZ();CO U& e = M.Unit();VE<VE<U>> children_value(V);VE<VE<U>> l_sum(V);VE<VE<U>> r_sum(V);for(int i = 0;i < V;i++){children_value[i].resize(m_children[i].SZ());}for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);CO VE<U>& children_value_i = children_value[i];CO int SZ_i = children_value_i.SZ();U temp = e;l_sum[i].reserve(SZ_i + 1);l_sum[i].push_back(temp);for(int m = 0;m < SZ_i;m++){l_sum[i].push_back(temp = M.Product(temp,g(children_value_i[m],true,i,m_children[i][m])));}CRI j = Parent(i);if(j != -1){children_value[j][m_children_num[i]]= f(temp,i);}temp = e;r_sum[i].resize(SZ_i);for(int m = 1;m <= SZ_i;m++){r_sum[i][SZ_i - m]= temp;temp = M.Product(g(children_value_i[SZ_i - m],true,i,m_children[i][SZ_i - m]),temp);}}for(int n = 1;n < V;n++){CRI i = NodeNumber(n);CRI j = Parent(i);CRI k = ChildrenNumber(i);CO int SZ_i = r_sum[i].SZ();CO U rest_i = g(f(M.Product(l_sum[j][k],r_sum[j][k]),j),false,i,j);for(int m = 0;m <= SZ_i;m++){l_sum[i][m]= M.Product(rest_i,l_sum[i][m]);}}VE<U> AN(V);for(int i = 0;i < V;i++){AN[i]= f(l_sum[i].back(),i);}RE AN;}TE <TY TREE> IN tuple<int,int,int> DFST<TREE>::Diameter(){auto& V = TH->SZ();int i_opt[2]={-1,-1};int d_opt = SZ;for(int i = 0;i < V;i++){auto& d = Depth(i);if(d_opt > d){d_opt = d;i_opt[0]= i;}}DFST<TREE> dfs{TH->m_G,i_opt};d_opt = SZ;for(int i = 0;i < V;i++){auto& d = dfs.Depth(i);if(d_opt > d){d_opt = d;i_opt[1]= i;}}RE{i_opt[0],i_opt[1],d_opt};}

TE <TY TREE,TY U,TY MONOID>CL DFSWT:PU DFST<TREE>{PU:MONOID m_M;VE<U> m_wprev;VE<U> m_wdepth_r;VE<U> m_wdepth_l;bool m_set_wdepth;VE<U> m_wheight_max_r;VE<U> m_wheight_max_l;VE<U> m_wheight_min_r;VE<U> m_wheight_min_l;bool m_set_wheight;VE<U> m_wheaviness;bool m_set_wheaviness;VE<VE<tuple<int,U,U>>> m_wdoubling;bool m_set_wdoubling;IN DFSWT(TREE& T,MONOID M,CRI root = 0,CRI digit = 0);IN CO U& WDepth(CRI i,CO bool& right = true);IN CO U& WHeight(CRI i,CO bool& maximum = true,CO bool& right = true);IN CO U& WHeaviness(CRI i);pair<int,U> WAncestor(int i,int n,CO bool& right = true);tuple<int,U,U> WLCA(int i,int j);tuple<int,U,U> WLCA(int i,int j,int& i_prev,int& j_prev);tuple<int,int,U> WDiameter();VO SetWDepth();VO SetWHeight();VO SetWHeaviness();VO SetWDoubling();};TE <TY TREE,TY MONOID,TY...Args> DFSWT(TREE& T,MONOID M,CO Args&... args)-> DFSWT<TREE,inner_t<MONOID>,MONOID>;
TE <TY TREE,TY U,TY MONOID> IN DFSWT<TREE,U,MONOID>::DFSWT(TREE& T,MONOID M,CRI root,CRI digit):DFST<TREE>(T,root,digit),m_M(MO(M)),m_wprev(TH->SZ(),m_M.One()),m_wdepth_r(),m_wdepth_l(),m_set_wdepth(),m_wheight_max_r(),m_wheight_max_l(),m_wheight_min_r(),m_wheight_min_l(),m_set_wheight(),m_wheaviness(),m_set_wheaviness(),m_wdoubling(TH->m_digit),m_set_wdoubling(){ST_AS(is_same_v<U,inner_t<MONOID>>);CRI V = TH->SZ();for(int i = 0;i < V;i++){auto&& edge_i = TH->m_G.Edge(i);for(auto& p:edge_i){CRI j = get<0>(p);if(i == TH->Parent(j)){m_wprev[j]= get<1>(p);}}}}TE <TY TREE,TY U,TY MONOID> IN CO U& DFSWT<TREE,U,MONOID>::WDepth(CRI i,CO bool& right){AS(i < TH->SZ());if(!m_set_wdepth){SetWDepth();}RE(right?m_wdepth_r:m_wdepth_l)[i];}TE <TY TREE,TY U,TY MONOID> IN CO U& DFSWT<TREE,U,MONOID>::WHeight(CRI i,CO bool& maximum,CO bool& right){AS(i < TH->SZ());if(!m_set_wheight){SetWHeight();}RE(maximum?(right?m_wheight_max_r:m_wheight_max_l):(right?m_wheight_min_r:m_wheight_min_l))[i];}TE <TY TREE,TY U,TY MONOID> IN CO U& DFSWT<TREE,U,MONOID>::WHeaviness(CRI i){AS(i < TH->SZ());if(!m_set_wheaviness){SetWHeaviness();}RE m_wheaviness[i];}TE <TY TREE,TY U,TY MONOID>pair<int,U> DFSWT<TREE,U,MONOID>::WAncestor(int i,int n,CO bool& right){if(! m_set_wdoubling){SetWDoubling();}AS((n >> TH->m_digit)== 0);int d = 0;U temp = m_M.One();WH(n != 0){if((n & 1)== 1){auto&[j,u_r,u_l]= m_wdoubling[d][i];AS((i = j)!= -1);temp = right?m_M.Product(temp,u_r):m_M.Product(u_l,temp);}d++;n >>= 1;}RE{i,MO(temp)};}TE <TY TREE,TY U,TY MONOID> IN tuple<int,U,U> DFSWT<TREE,U,MONOID>::WLCA(int i,int j){int i_prev;int j_prev;RE WLCA(i,j,i_prev,j_prev);}TE <TY TREE,TY U,TY MONOID>tuple<int,U,U> DFSWT<TREE,U,MONOID>::WLCA(int i,int j,int& i_prev,int& j_prev){i_prev = j_prev = -1;CO int diff = TH->Depth(i)- TH->Depth(j);U u_ir = m_M.One();U u_jl = u_ir;if(diff > 0){auto[k,v]= WAncestor(i,diff - 1,true);u_ir = m_M.Product(v,m_wprev[k]);AS((i = TH->Parent(i_prev = k))!= -1);}else if(diff < 0){auto[k,v]= WAncestor(j,- diff - 1,false);u_jl = m_M.Product(m_wprev[k],v);AS((j = TH->Parent(j_prev = k))!= -1);}if(i != j){if(!m_set_wdoubling){SetWDoubling();}int d = TH->m_digit;WH(--d >= 0){auto&[k_i,v_ir,v_il]= m_wdoubling[d][i];auto&[k_j,v_jr,v_jl]= m_wdoubling[d][j];if(k_i != k_j){AS((i = k_i)!= -1 &&(j = k_j)!= -1);u_ir = m_M.Product(u_ir,v_ir);u_jl = m_M.Product(v_jl,u_jl);}}u_ir = m_M.Product(u_ir,m_wprev[i]);u_jl = m_M.Product(m_wprev[j],u_jl);AS((i = TH->Parent(i_prev = i))==(j = TH->Parent(j_prev = j)));}RE{i,MO(u_ir),MO(u_jl)};}TE <TY TREE,TY U,TY MONOID> IN tuple<int,int,U> DFSWT<TREE,U,MONOID>::WDiameter(){auto& V = TH->SZ();VE<pair<pair<int,U>,pair<int,U>>> dp(V);int l0_opt = TH->Root(),l1_opt = l0_opt;U u_opt = TH->m_M.One();for(int i = 0;i < V;i++){auto& j = TH->NodeNumber(i,true);auto&[dpj0,dpj1]= dp[j];dpj0 = dpj1 ={j,TH->m_M.One()};auto&[l0,u0]= dpj0;auto&[l1,u1]= dpj1;for(auto& k:TH->Children(j)){auto&[l,u]= get<1>(dp[k]);U temp = TH->m_M.Product(m_wprev[k],u);if(u0 < temp){if(u1 < temp){dp[j]={MO(dpj1),{l,MO(temp)}};}else{dp[j]={{l,MO(temp)},MO(dpj1)};}}}U temp = TH->m_M.Product(u0,u1);if(u_opt < temp){u_opt = MO(temp);l0_opt = l0;l1_opt = l1;}}RE{l0_opt,l1_opt,MO(u_opt)};}TE <TY TREE,TY U,TY MONOID>VO DFSWT<TREE,U,MONOID>::SetWDepth(){AS(!m_set_wdepth);m_set_wdepth = true;CRI V = TH->SZ();CO U& one = m_M.One();m_wdepth_r.resize(V,one);m_wdepth_l.resize(V,one);for(int n = 1;n < V;n++){CRI i = TH->m_node_num[n];CRI j = TH->Parent(i);AS(j != -1);m_wdepth_r[i]= m_M.Product(m_wdepth_r[j],m_wprev[i]);m_wdepth_l[i]= m_M.Product(m_wprev[i],m_wdepth_l[j]);}RE;}TE <TY TREE,TY U,TY MONOID>VO DFSWT<TREE,U,MONOID>::SetWHeight(){AS(!m_set_wheight);m_set_wheight = true;CRI V = TH->SZ();CO U& one = m_M.One();m_wheight_max_r.resize(V,one);m_wheight_max_l.resize(V,one);m_wheight_min_r.resize(V,one);m_wheight_min_l.resize(V,one);VE<bool> found(V);for(int n = V - 1;n > 0;n--){CRI i = TH->m_node_num[n];CRI j = TH->Parent(i);AS(j != -1);m_wheight_max_r[j]= max(m_wheight_max_r[j],m_M.Product(m_wheight_max_r[i],m_wprev[i]));m_wheight_max_l[j]= max(m_wheight_max_l[j],m_M.Product(m_wprev[i],m_wheight_max_l[i]));if(found[j]){m_wheight_min_r[j]= min(m_wheight_min_r[j],m_M.Product(m_wheight_min_r[i],m_wprev[i]));m_wheight_min_l[j]= min(m_wheight_min_l[j],m_M.Product(m_wprev[i],m_wheight_min_l[i]));}else{m_wheight_min_r[j]= m_M.Product(m_wheight_min_r[i],m_wprev[i]);m_wheight_min_l[j]= m_M.Product(m_wprev[i],m_wheight_min_l[i]);found[j]= true;}}RE;}TE <TY TREE,TY U,TY MONOID>VO DFSWT<TREE,U,MONOID>::SetWHeaviness(){AS(!m_set_wheaviness);m_set_wheaviness = true;CRI V = TH->SZ();m_wheaviness.resize(V,m_M.One());for(int n = V - 1;n > 0;n--){CRI i = TH->m_node_num[n];CRI j = TH->Parent(i);AS(j != -1);m_wheaviness[j]= m_M.Product(m_wheaviness[j],m_M.Product(m_wheaviness[i],m_wprev[i]));}RE;}TE <TY TREE,TY U,TY MONOID>VO DFSWT<TREE,U,MONOID>::SetWDoubling(){AS(!m_set_wdoubling);m_set_wdoubling = true;CRI V = TH->SZ();{m_wdoubling[0].reserve(V);for(int i = 0;i < V;i++){m_wdoubling[0].push_back({TH->Parent(i),m_wprev[i],m_wprev[i]});}}for(int d = 1;d < TH->m_digit;d++){m_wdoubling[d].reserve(V);for(int i = 0;i < V;i++){auto[j,u_ir,u_il]= m_wdoubling[d-1][i];if(j != -1){auto&[k,v_jr,v_jl]= m_wdoubling[d-1][j];j = k;u_ir = m_M.Product(u_ir,v_jr);u_il = m_M.Product(v_jl,u_il);}m_wdoubling[d].push_back({j,u_ir,u_il});}}RE;}
#endif

