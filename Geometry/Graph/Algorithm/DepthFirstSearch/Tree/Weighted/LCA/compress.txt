#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/DepthFirstSearch/Tree/Weighted/LCA/a_Body.hpp"
#else
// êÊÇ…DepthFirstSearchOnWeightedTreeÇì\ÇÈÅB

TE <TY DFST,TY MONOID,TY U>CL WAncestorDoubling{PU:DFST* m_p_dfst;MONOID* m_p_M;int m_SZ;VE<VE<tuple<int,U,U>>> m_wdoubling;IN WAncestorDoubling(DFST& dfst);pair<int,U> WAncestor(DFST& dfst,int i,int n,CO bool& right = true);tuple<int,int,int,U,U> WLCA(DFST& dfst,int i,int j);CO VE<int>& Get(CRI d);};TE <TY DFSWT> WAncestorDoublng(DFSWT)-> WAcestorDoubling<DFSWT,decldecay_t(declval<DSFWT>().Monoid()),decldecay_t(declval<DSFWT>().WDepth(0))>;
TE <TY DFST,TY MONOID,TY U> IN WAncestorDoubling<DFSWT,MONOID,U>::WAncestorDoubling(DFST& dfst):m_p_dfswt{&m_dfswt},m_p_M(m_p_dfswt->Monoid()),m_SZ(m_p_dfswt->SZ()),m_wdoubling(1,VE<tuple<int,U,U>>(SZ,{-1,m_p_M->One(),m_p_M->One()})){ST_AS(is_same_v<MONOID,decldecay_t(m_dfswt.Monoid())> && is_same_v<U,inner_t<MONOID>>);}TE <TY DFST,TY MONOID,TY U>pair<int,U> WAncestorDoubling<DFSWT,MONOID,U>::WAncestor(int i,int n,CO bool& right){AS(0 <= i && i < m_SZ);int d = 0;U temp = m_p_M->One();WH(i != -1 && n != 0){if((n & 1)== 1){auto&[j,u_r,u_l]= Get(d)[i];i = j;temp = right?m_p_M->Product(temp,u_r):m_p_M->Product(u_l,temp);}d++;n >>= 1;}if(i == -1){temp = m_p_M->One();}RE{i,MO(temp)};}TE <TY DFST,TY MONOID,TY U>tuple<int,int,int,U,U> WAncestorDoubling<DFSWT,MONOID,U>::WLCA(int i,int j){int i_prev = -1,j_prev = -1;CO int diff = m_p_dfswt->Depth(i)- m_p_dfswt->Depth(j);U u_ir = m_p_M->One();U u_jl = u_ir;if(diff > 0){auto[k,v]= WAncestor(i,diff - 1,true);u_ir = m_p_M->Product(v,m_wprev[k]);i = m_p_dfswt->Parent(i_prev = k);}else if(diff < 0){auto[k,v]= WAncestor(j,- diff - 1,false);u_jl = m_p_M->Product(m_wprev[k],v);j = m_p_dfswt->Parent(j_prev = k);}if(i != j){int d = int(m_doubling.SZ())- 1;WH(get<0>(Get(d)[i])!= get<0>(Get(d)[j])){Get(++d);}WH(--d >= 0){auto&[k_i,v_ir,v_il]= m_wdoubling[d][i];auto&[k_j,v_jr,v_jl]= m_wdoubling[d][j];if(k_i != k_j){i = k_i;j = k_j;u_ir = m_p_M->Product(MO(u_ir),v_ir);u_jl = m_p_M->Product(v_jl,u_jl);}}u_ir = m_p_M->Product(MO(u_ir),m_p_dfswt->PrevWeight(i));u_jl = m_p_M->Product(m_p_dfswt->PrevWeight(j),u_jl);i = m_p_dfswt->Parent(i_prev = i);j = m_p_dfswt->Parent(j_prev = j);AS(i == j);}RE{i,MO(u_ir),MO(u_jl)};}TE <TY DFST,TY MONOID,TY U>CO VE<tuple<int,U,U>>& WAncestorDoubling<DFSWT,MONOID,U>::Get(CRI d){AS(d >= 0);int digit = m_wdoubling.SZ();CO U& one = m_p_M->One();WH(digit <= d){m_wdoubling.push_back(VE(m_SZ,{-1,one,one});for(int i = 0;i < m_SZ;i++){auto&[j,u_ir,u_il]= m_wdoubling[digit][i]= m_wdoubling[digit-1][i];if(j != -1){auto&[k,v_jr,v_jl]= m_wdoubling[d-1][j];j = k;if(j == -1){u_ir = u_il = one;}else{u_ir = m_p_M->Product(MO(u_ir),v_jr);u_il = m_p_M->Product(v_jl,u_il);}}}digit++;}RE m_wdoubling[d];}
#endif

