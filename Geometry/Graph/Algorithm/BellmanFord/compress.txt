#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/BellmanFord/a_Body.hpp"
#else
#define BELLMAN_FORD_BODY(INITIALISE_PREV,SET_PREV)CO U& one = m_M.One();CO U& infty = TH->Infty();AS(one < infty);CRI SZ = m_G.SZ();auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);VE<U> weight(SZ,infty),weight_copy;weight[i_start]= one;VE<bool> found(SZ);found[i_start]= true;INITIALISE_PREV;if(path_LE == -1){path_LE = min(SZ - 1,int(m_edge.SZ()));}else{AS(many_edges);}for(int num = 0;num < path_LE;num++){for(auto&[i,j,w]:m_edge){if(found[i]){U temp = m_M.Product(weight[i],w);U& weight_j = weight[j];if(temp < weight_j){weight_j = MO(temp);found[j]= true;SET_PREV;}}}}VE<bool> valid(SZ,true);for(auto&[i,j,w]:m_edge){valid[i]= valid[i]&&(!found[i]|| !(m_M.Product(weight[i],w)< weight[j]));}VE<int> dfs{};for(int i = 0;i < SZ;i++){if(!valid[i]){dfs.push_back(i);}}WH(!dfs.empty()){CO int i = dfs.back();dfs.pop_back();auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(edge_ij);if(valid[j]){valid[j]= false;dfs.push_back(j);}}}
TE <TY T,TY GRAPH,TY U,TY MONOID>CL AbstractBellmanFord:PU PointedSet<U>{PU:GRAPH& m_G;MONOID m_M;VE<tuple<int,int,U>> m_edge;AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty);tuple<VE<bool>,VE<U>> GetDistance(CO T& t_start,CO bool& many_edges = false,int path_LE = -1);TE <TE <TY...> TY V> tuple<VE<bool>,VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges = false,int path_LE = -1);tuple<VE<bool>,VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO bool& many_edges = false,int path_LE = -1);};TE <TY GRAPH,TY U,TY MONOID> AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty)-> AbstractBellmanFord<inner_t<GRAPH>,GRAPH,U,MONOID>;TE <TY T,TY GRAPH>CL BellmanFord:PU AbstractBellmanFord<T,GRAPH,ll,AdditiveMonoid<>>{PU:IN BellmanFord(GRAPH& G);};TE <TY GRAPH> BellmanFord(GRAPH& G)-> BellmanFord<inner_t<GRAPH>,GRAPH>;
TE <TY T,TY GRAPH,TY U,TY MONOID>AbstractBellmanFord<T,GRAPH,U,MONOID>::AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)),m_edge(){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<U,inner_t<MONOID>> && !is_same_v<U,int>);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto& edge_ij:edge_i){m_edge.push_back({i,m_G.Enumeration_inv(get<0>(edge_ij)),get<1>(edge_ij)});}}}TE <TY T,TY GRAPH> IN BellmanFord<T,GRAPH>::BellmanFord(GRAPH& G):AbstractBellmanFord<T,GRAPH,ll,AdditiveMonoid<>>(G,AdditiveMonoid<>(),1e18){}TE <TY T,TY GRAPH,TY U,TY MONOID>tuple<VE<bool>,VE<U>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetDistance(CO T& t_start,CO bool& many_edges,int path_LE){BELLMAN_FORD_BODY(,);RE{MO(valid),MO(weight)};}TE <TY T,TY GRAPH,TY U,TY MONOID> TE <TE <TY...> TY V>tuple<VE<bool>,VE<U>,VE<LI<T>>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges,int path_LE){BELLMAN_FORD_BODY(VE<int> prev(SZ),prev[j]= i);VE<LI<T>> path{};CO int path_SZ = t_finals.SZ();path.reserve(path_SZ);for(auto& t_final:t_finals){LI<T> path_j{};path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]&& valid[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(valid),MO(weight),MO(path)};}TE <TY T,TY GRAPH,TY U,TY MONOID>tuple<VE<bool>,VE<U>,VE<LI<T>>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetPath(CO T& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();VE<T> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals);}
#endif

