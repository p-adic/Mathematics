#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/MaximumFlow/a_Body.hpp"
#else
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractMaximumFlow{PU:GRAPH& m_G;ABEL_GROUP m_M;IN AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M);pair<U,VE<VE<tuple<T,U>>>> GetFlow(CO T& t_start,CO T& t_final);};TE <TY GRAPH,TY ABEL_GROUP> AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M)-> AbstractMaximumFlow<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY T,TY GRAPH,TY U>CL MaximumFlow:PU AbstractMaximumFlow<T,GRAPH,U,AdditiveGroup<U>>{PU:IN MaximumFlow(GRAPH& G,CO U& dummy);};TE <TY GRAPH,TY U> MaximumFlow(GRAPH& G,CO U& dummy)-> MaximumFlow<inner_t<GRAPH>,GRAPH,U>;
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN AbstractMaximumFlow<T,GRAPH,U,ABEL_GROUP>::AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)){}TE <TY T,TY GRAPH,TY U> IN MaximumFlow<T,GRAPH,U>::MaximumFlow(GRAPH& G,CO U& dummy):AbstractMaximumFlow<T,GRAPH,U,AdditiveGroup<U>>(G,AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>pair<U,VE<VE<tuple<T,U>>>> AbstractMaximumFlow<T,GRAPH,U,ABEL_GROUP>::GetFlow(CO T& t_start,CO T& t_final){CO U& zero = m_M.Zero();CRI SZ = m_G.SZ();VE<VE<tuple<int,U,int,int>>> rest(SZ);VE<VE<tuple<T,U>>> flow(SZ);for(int i = 0;i < SZ;i++){auto&& vi = m_G.Enumeration(i);for(auto&[vj,fj]:m_G.Edge(vi)){AS(vi != vj && !(fj < zero));if(zero < fj){auto&& j = m_G.Enumeration_inv(vj);rest[i].push_back({j,fj,rest[j].SZ(),flow[i].SZ()});rest[j].push_back({i,zero,rest[i].SZ()- 1,-1});flow[i].push_back({vj,zero});}}}VE<int> edge_num_max(SZ);for(int i = 0;i < SZ;i++){edge_num_max[i]= rest[i].SZ()- 1;}auto&& i_start = m_G.Enumeration_inv(t_start);auto&& i_final = m_G.Enumeration_inv(t_final);U flow_sum = zero;bool updated = true;for(int LE = 1;LE < SZ && updated;LE++){updated = false;LI<int> bfs ={i_start};VE<int> distance = VE(SZ,-1);distance[i_start]= 0;WH(!bfs.empty()){CO int i = bfs.back();bfs.pop_back();for(auto& e:rest[i]){auto& j = get<0>(e);if(distance[j]== -1 && zero < get<1>(e)){distance[j]= distance[i]+ 1;bfs.push_front(j);}}}if(distance[i_final]== -1){break;}VE<int> path{i_start};auto edge_num = edge_num_max;WH(true){CO int i = path.back();WH(edge_num[i]>= 0){auto& rest_i_curr = rest[i][edge_num[i]];auto& j = get<0>(rest_i_curr);if(distance[i]+ 1 == distance[j]&& zero < get<1>(rest_i_curr)){path.push_back(j);break;}else{edge_num[i]--;}}if(edge_num[i]>= 0){continue;}path.pop_back();if(i == i_start){break;}else if(i != i_final){edge_num[path.back()]--;}else{updated = true;auto IT = path.BE(),EN = path.EN();U f_min = get<1>(rest[*IT][edge_num[*IT]]);WH(++IT != EN){f_min = min(f_min,get<1>(rest[*IT][edge_num[*IT]]));}flow_sum = m_M.Sum(MO(flow_sum),f_min);CO U f_min_inv = m_M.Inverse(f_min);for(auto& s:path){auto&[t,f_rest,rev_num,flow_num_s]= rest[s][edge_num[s]];auto&[s_copy,f_rest_rev,edge_num_s_copy,flow_num_t]= rest[t][rev_num];if(flow_num_s >= 0){U& f_curr = get<1>(flow[s][flow_num_s]);f_curr = m_M.Sum(MO(f_curr),f_min);}else{U& f_curr = get<1>(flow[t][flow_num_t]);AS(!((f_curr = m_M.Sum(MO(f_curr),f_min_inv))< zero));}f_rest = m_M.Sum(MO(f_rest),f_min_inv);f_rest_rev = m_M.Sum(MO(f_rest_rev),f_min);}path ={i_start};}}}RE{MO(flow_sum),MO(flow)};}
#endif
