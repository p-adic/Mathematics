#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/MaximumFlow/ProjectSelectionProblem/a_Body.hpp"
#else
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractMaximumFlow{PU:GRAPH& m_G;ABEL_GROUP m_M;IN AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M);pair<U,VE<VE<tuple<T,U>>>> GetFlow(CO T& t_start,CO T& t_final);};TE <TY GRAPH,TY ABEL_GROUP> AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M)-> AbstractMaximumFlow<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY T,TY GRAPH,TY U>CL MaximumFlow:PU AbstractMaximumFlow<T,GRAPH,U,AdditiveGroup<U>>{PU:IN MaximumFlow(GRAPH& G,CO U& dummy);};TE <TY GRAPH,TY U> MaximumFlow(GRAPH& G,CO U& dummy)-> MaximumFlow<inner_t<GRAPH>,GRAPH,U>;
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN AbstractMaximumFlow<T,GRAPH,U,ABEL_GROUP>::AbstractMaximumFlow(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)){}TE <TY T,TY GRAPH,TY U> IN MaximumFlow<T,GRAPH,U>::MaximumFlow(GRAPH& G,CO U& dummy):AbstractMaximumFlow<T,GRAPH,U,AdditiveGroup<U>>(G,AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>pair<U,VE<VE<tuple<T,U>>>> AbstractMaximumFlow<T,GRAPH,U,ABEL_GROUP>::GetFlow(CO T& t_start,CO T& t_final){CO U& zero = m_M.Zero();CRI SZ = m_G.SZ();VE<VE<tuple<int,U,int,int>>> rest(SZ);VE<VE<tuple<T,U>>> flow(SZ);for(int i = 0;i < SZ;i++){auto&& vi = m_G.Enumeration(i);for(auto&[vj,fj]:m_G.Edge(vi)){AS(vi != vj && !(fj < zero));if(zero < fj){auto&& j = m_G.Enumeration_inv(vj);rest[i].push_back({j,fj,rest[j].SZ(),flow[i].SZ()});rest[j].push_back({i,zero,rest[i].SZ()- 1,-1});flow[i].push_back({vj,zero});}}}VE<int> edge_num_max(SZ);for(int i = 0;i < SZ;i++){edge_num_max[i]= rest[i].SZ()- 1;}auto&& i_start = m_G.Enumeration_inv(t_start);auto&& i_final = m_G.Enumeration_inv(t_final);U flow_sum = zero;bool updated = true;for(int LE = 1;LE < SZ && updated;LE++){updated = false;LI<int> bfs ={i_start};VE<int> distance = VE(SZ,-1);distance[i_start]= 0;WH(!bfs.empty()){CO int i = bfs.back();bfs.pop_back();for(auto& e:rest[i]){auto& j = get<0>(e);if(distance[j]== -1 && zero < get<1>(e)){distance[j]= distance[i]+ 1;bfs.push_front(j);}}}if(distance[i_final]== -1){break;}VE<int> path{i_start};auto edge_num = edge_num_max;WH(true){CO int i = path.back();WH(edge_num[i]>= 0){auto& rest_i_curr = rest[i][edge_num[i]];auto& j = get<0>(rest_i_curr);if(distance[i]+ 1 == distance[j]&& zero < get<1>(rest_i_curr)){path.push_back(j);break;}else{edge_num[i]--;}}if(edge_num[i]>= 0){continue;}path.pop_back();if(i == i_start){break;}else if(i != i_final){edge_num[path.back()]--;}else{updated = true;auto IT = path.BE(),EN = path.EN();U f_min = get<1>(rest[*IT][edge_num[*IT]]);WH(++IT != EN){f_min = min(f_min,get<1>(rest[*IT][edge_num[*IT]]));}flow_sum = m_M.Sum(MO(flow_sum),f_min);CO U f_min_inv = m_M.Inverse(f_min);for(auto& s:path){auto&[t,f_rest,rev_num,flow_num_s]= rest[s][edge_num[s]];auto&[s_copy,f_rest_rev,edge_num_s_copy,flow_num_t]= rest[t][rev_num];if(flow_num_s >= 0){U& f_curr = get<1>(flow[s][flow_num_s]);f_curr = m_M.Sum(MO(f_curr),f_min);}else{U& f_curr = get<1>(flow[t][flow_num_t]);AS(!((f_curr = m_M.Sum(MO(f_curr),f_min_inv))< zero));}f_rest = m_M.Sum(MO(f_rest),f_min_inv);f_rest_rev = m_M.Sum(MO(f_rest_rev),f_min);}path ={i_start};}}}RE{MO(flow_sum),MO(flow)};}

TE <TY U,TY ABEL_GROUP,TY V0,TY V1,TY V2,TY V3>U AbstractProjectSelectionProblem(ABEL_GROUP R,CO U& infty,CO V0& score,CO V1& depENency_penalty,CO V2& pair_accept_score,CO V3& pair_reject_score){CO U& zero = R.Zero();U AN = zero;CO int N = score.SZ();VE<VE<tuple<int,U>>> e(N + 2);for(int i = 0;i < N;i++){if(score[i]< zero){e[i].push_back({N+1,R.Inverse(score[i])});}else{e[N].push_back({i,score[i]});AN = R.Sum(MO(AN),score[i]);}}VE d(N,VE<U>(N,zero));for(auto&[i,j,u]:depENency_penalty){AS(!(u < zero || i == j));d[i][j]= R.Sum(MO(d[i][j]),u);}VE a(N,VE<U>(N,zero));for(auto&[i,j,u]:pair_accept_score){AS(!(u < zero || i == j));a[j][i]= a[i][j]= R.Sum(MO(a[i][j]),u);}VE r(N,VE<U>(N,zero));for(auto&[i,j,u]:pair_reject_score){AS(!(u < zero || i == j));r[j][i]= r[i][j]= R.Sum(MO(r[i][j]),u);}for(int i = 0;i < N;i++){for(int j = i + 1;j < N;j++){if(d[i][j]!= zero){if(d[j][i]!= zero){CRI ij_l = d[i][j]< d[j][i]?i:j;CRI ij_r = d[i][j]< d[j][i]?j:i;U& dmin = d[ij_l][ij_r];CO U& dmax = d[ij_r][ij_l];a[i][j]= R.Sum(MO(a[i][j]),dmin);r[i][j]= R.Sum(MO(r[i][j]),dmin);CO bool same = dmin == dmax;dmin = R.Inverse(dmin);AN = R.Sum(MO(AN),dmin);if(!same){e[ij_r].push_back({ij_l,R.Sum(MO(dmin),dmax)});}}else{e[i].push_back({j,d[i][j]});}}else if(d[j][i]!= zero){e[j].push_back({i,d[j][i]});}if(a[i][j]!= zero){CO int k = e.SZ();e.push_back({{i,infty},{j,infty}});e[N].push_back({k,a[i][j]});AN = R.Sum(MO(AN),a[i][j]);}if(r[i][j]!= zero){CO int k = e.SZ();e.push_back({{N+1,r[i][j]}});e[i].push_back({k,infty});e[j].push_back({k,infty});AN = R.Sum(MO(AN),r[i][j]);}}}Graph graph{int(e.SZ()),Get(e)};AbstractMaximumFlow mf(graph,MO(R));auto[loss,flow]= mf.GetFlow(N,N + 1);RE R.Sum(MO(AN),R.Inverse(loss));}TE <TY U,TY V0,TY V1,TY V2,TY V3> IN U ProjectSelectionProblem(CO U& infty,CO V0& score,CO V1& depENency_penalty,CO V2& pair_accept_score,CO V3& pair_reject_score){RE AbstractProjectSelectionProblem(AdditiveGroup<U>{},infty,score,depENency_penalty,pair_accept_score,pair_reject_score);}
#endif

