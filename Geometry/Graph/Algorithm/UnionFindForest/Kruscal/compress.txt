#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/UnionFindForest/Kruscal/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<int> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<int> LinearEdge::OP()(CRI t){VE<int> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back(t - 1);}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back(t + 1);}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractUnionFindForest{PU:GRAPH& m_G;ABEL_GROUP m_M;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M);CO decltype((declval<GRAPH>().Enumeration(0)))RootOfNode(CO T&);TE <TE <TY...> TY V> VE<T> GetRoot()CO;IN U Potential(CO T& t0,CO T& t1);IN CRI SZ(CO bool& node = true)CO NE;bool Graft(CO T& t0,CO T& t1,CO U& w = U());TE <TY PATH> IN bool Graft(CO T& t0,CO PATH& t1);};TE <TY GRAPH,TY ABEL_GROUP> AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M)-> AbstractUnionFindForest<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY U = int>CL UnionFindForest:PU AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>{PU:IN UnionFindForest(CRI SZ);};
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)),m_root_SZ(m_G.SZ()),m_pred(m_root_SZ),m_height(m_root_SZ,1),m_w(m_root_SZ,m_M.Zero()){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_pred[i]= i;}for(int i = 0;i < SZ;i++){auto&& s = m_G.Enumeration(i);for(auto& t:m_G.Edge(s)){Graft(s,t);}}}TE <TY U> IN UnionFindForest<U>::UnionFindForest(CRI SZ):AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>(LinearGraph(SZ,0),AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CO decltype((declval<GRAPH>().Enumeration(0)))AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::RootOfNode(CO T& t){auto&& num = m_G.Enumeration_inv(t);int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));pred1 = pred2 = m_pred[pred2];}RE m_G.Enumeration(pred1);}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TE <TY...> TY V>VE<T> AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::GetRoot()CO{VE<T> AN{};AN.reserve(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){if(i == m_pred[i]){AN.push_back(m_G.Enumeration(i));}}RE AN;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>U AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Potential(CO T& t0,CO T& t1){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);AS(root0 == root1);RE m_M.Sum(m_w[m_G.Enumeration_inv(t0)],m_M.Inverse(m_w[m_G.Enumeration_inv(t1)]));}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN CRI AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::SZ(CO bool& node)CO NE{RE node?m_G.SZ():m_root_SZ;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO T& t1,CO U& w){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);if(root0 == root1){RE Potential(t0,t1)== w;}auto&& num0 = m_G.Enumeration_inv(t0);auto&& num1 = m_G.Enumeration_inv(t1);auto&& rnum0 = m_G.Enumeration_inv(root0);auto&& rnum1 = m_G.Enumeration_inv(root1);int& height0 = m_height[rnum0];CRI height1 = m_height[rnum1];CO int* p_reMOd_root;CO int* p_reMOd_node;CO int* p_kept_root;if(height0 < height1){p_reMOd_root = &rnum0;p_reMOd_node = &num0;p_kept_root = &rnum1;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}p_reMOd_root = &rnum1;p_reMOd_node = &num1;p_kept_root = &rnum0;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(*p_reMOd_node != *p_reMOd_root){m_w[*p_reMOd_node]= m_M.Sum(m_w[*p_reMOd_node],m_w[*p_reMOd_root]);}m_pred[*p_reMOd_node]= m_pred[*p_reMOd_root]= *p_kept_root;m_root_SZ--;RE true;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TY PATH> IN bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO PATH& t1){RE Graft(t0,get<0>(t1),get<1>(t1));}

TE <TY GRAPH>LI<tuple<int,int,int>> SortedEdge(GRAPH& G,CO VE<pair<int,int>>& E){US PATH = decldecay_t(declval<GRAPH>().edge()(0).back());US T = inner_t<GRAPH>;US U = decldecay_t(get<1>(declval<PATH>()));ST_AS(is_same_v<T,decldecay_t(get<0>(declval<PATH>()))> && is_same_v<int,decldecay_t(get<2>(declval<PATH>()))>);CRI V = G.SZ();LI<pair<U,int>> weight{};for(int i = 0;i < V;i++){auto&& t = G.Enumeration(i);auto&& edge_i = G.Edge(t);for(auto& edge_ij:edge_i){weight.push_back({get<1>(edge_ij),get<2>(edge_ij)});}}weight.sort();LI<tuple<int,int,int>> E_sorted{};for(auto& weight_n:weight){int& n = weight_n.second;auto&[i,j]= E[n];E_sorted.push_back({i,j,n});}RE E_sorted;}TE <TY On>pair<VE<int>,int> Kruscal(CRI V,CO VE<pair<int,int>>& E,CO LI<tuple<int,int,int>>& E_sorted,CO On& on,VE<int> AN ={}){ST_AS(is_invocable_r_v<bool,On,int>);UnionFindForest<> uff{V};for(auto& n:AN){auto&[i,j]= E[n];if(! on(n)|| uff.RootOfNode(i)== uff.RootOfNode(j)){RE{{},-1};}else{uff.Graft(i,j);}}AN.reserve(V - 1);for(auto&[i,j,n]:E_sorted){if(on(n)){if(uff.RootOfNode(i)!= uff.RootOfNode(j)){uff.Graft(i,j);AN.push_back(n);}}}RE{MO(AN),uff.SZ(false)};}TE <TY GRAPH> IN pair<VE<int>,int> Kruscal(GRAPH& G,CO VE<pair<int,int>>& E,VE<int> AN ={}){RE Kruscal(G.SZ(),E,SortedEdge(G,E),[&](CRI){RE true;},AN);}
#endif
