#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/UnionFindForest/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<pair<int,int>> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<pair<int,int>> LinearEdge::OP()(CRI t){VE<pair<int,int>> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back({t - 1,1});}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back({t + 1,1});}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractUnionFindForest{PU:GRAPH& m_G;ABEL_GROUP m_M;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;bool m_solvable;AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M);CO decltype((declval<GRAPH>().Enumeration(0)))RootOfNode(CO T&);TE <TE <TY...> TY V> VE<T> GetRoot()CO;IN U Potential(CO T& t0,CO T& t1);IN CRI NodeSize()CO NE;IN CRI RootSize()CO NE;CO bool& Graft(CO T& t0,CO T& t1,CO U& w = U());TE <TY PATH> IN CO bool& Graft(CO T& t0,CO PATH& t1);CO bool& Solvable()CO NE;};TE <TY GRAPH,TY ABEL_GROUP> AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M)-> AbstractUnionFindForest<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY U = int>CL UnionFindForest:PU LinearGraph,PU AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>{PU:IN UnionFindForest(CRI SZ);};
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)),m_root_SZ(m_G.SZ()),m_pred(m_root_SZ),m_height(m_root_SZ,1),m_w(m_root_SZ,m_M.Zero()),m_solvable(true){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_pred[i]= i;}for(int i = 0;i < SZ;i++){auto&& s = m_G.Enumeration(i);for(auto& t:m_G.Edge(s)){Graft(s,t);}}}TE <TY U> IN UnionFindForest<U>::UnionFindForest(CRI SZ):LinearGraph(SZ,0),AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>(*TH,AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CO decltype((declval<GRAPH>().Enumeration(0)))AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::RootOfNode(CO T& t){auto&& num = m_G.Enumeration_inv(t);int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));pred1 = pred2 = m_pred[pred2];}RE m_G.Enumeration(pred1);}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TE <TY...> TY V>VE<T> AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::GetRoot()CO{VE<T> AN{};AN.reserve(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){if(i == m_pred[i]){AN.push_back(m_G.Enumeration(i));}}RE AN;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>U AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Potential(CO T& t0,CO T& t1){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);AS(root0 == root1);RE m_M.Sum(m_w[m_G.Enumeration_inv(t0)],m_M.Inverse(m_w[m_G.Enumeration_inv(t1)]));}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN CRI AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::NodeSize()CO NE{RE m_G.SZ();}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN CRI AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::RootSize()CO NE{RE m_root_SZ;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CO bool& AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO T& t1,CO U& w){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);if(root0 == root1){RE m_solvable &= Potential(t0,t1)== w;}auto&& num0 = m_G.Enumeration_inv(t0);auto&& num1 = m_G.Enumeration_inv(t1);auto&& rnum0 = m_G.Enumeration_inv(root0);auto&& rnum1 = m_G.Enumeration_inv(root1);int& height0 = m_height[rnum0];CRI height1 = m_height[rnum1];CO int* p_reMOd_root;CO int* p_reMOd_node;CO int* p_kept_root;if(height0 < height1){p_reMOd_root = &rnum0;p_reMOd_node = &num0;p_kept_root = &rnum1;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}p_reMOd_root = &rnum1;p_reMOd_node = &num1;p_kept_root = &rnum0;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(*p_reMOd_node != *p_reMOd_root){m_w[*p_reMOd_node]= m_M.Sum(m_w[*p_reMOd_node],m_w[*p_reMOd_root]);}m_pred[*p_reMOd_node]= m_pred[*p_reMOd_root]= *p_kept_root;m_root_SZ--;RE m_solvable;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TY PATH> IN CO bool& AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO PATH& t1){RE Graft(t0,get<0>(t1),get<1>(t1));}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> CO bool& AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Solvable()CO NE{RE m_solvable;}
#endif

