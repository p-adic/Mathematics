#define BFS BreadthFirstSearch
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/BreadthFirstSearch/ShortestCycle/Odd/a_Body.hpp"
#else
#define VBFS VirtualBreadthFirstSearch

TE <TY T,TY GRAPH>CL VBFS{PU:GRAPH& m_G;T m_not_found;bool m_initialised;LI<T> m_next;VE<bool> m_found;VE<T> m_prev;IN VBFS(GRAPH& G,CO T& not_found);TE <TY Arg> IN VBFS(GRAPH& G,CO T& not_found,Arg&& init);IN VO Initialise();IN VO Initialise(CO T& init);TE <TE <TY...> TY VEC> IN VO Initialise(VEC<T> inits);IN VO Shift(CO T& init);TE <TE <TY...> TY VEC> IN VO Shift(VEC<T> inits);IN CRI SZ()CO NE;IN VE<bool>::reference found(CO T& t);IN CO T& prev(CO T& t);IN T Next();TE <TY U = T> auto GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>;TE <TY U = T> auto GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>;tuple<VE<int>,VE<VE<T>>,int> GetConnectedComponent();VE<T> GetNodeEnumeration();VE<T> GetReversedNodeEnumeration();VI VO Push(LI<T>& next,CO T& t)= 0;TE <TY PATH> IN VO Push(LI<T>& next,CO PATH& p);};
TE <TY T,TY GRAPH> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found):m_G(G),m_not_found(not_found),m_initialised(false),m_next(),m_found(),m_prev(){ST_AS(is_same_v<inner_t<GRAPH>,T>);}TE <TY T,TY GRAPH> TE <TY Arg> IN VBFS<T,GRAPH>::VBFS(GRAPH& G,CO T& not_found,Arg&& init):VBFS<T,GRAPH>(G,not_found){Initialise(forward<Arg>(init));}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(){m_initialised = true;CRI V = SZ();m_next.clear();m_found = VE<bool>(V);m_prev = VE<T>(V,m_not_found);}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Initialise(CO T& init){auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < SZ());Initialise();m_next.push_back(init);m_found[i]= true;}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Initialise(VEC<T> inits){Initialise();for(auto& init:inits){m_next.push_back(MO(init));}CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);m_found[i]= true;}}TE <TY T,TY GRAPH> IN VO VBFS<T,GRAPH>::Shift(CO T& init){if(m_initialised){CRI V = SZ();auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < V);m_next.clear();if(! m_found[i]){m_next.push_back(init);m_found[i]= true;}}else{Initialise(init);}}TE <TY T,TY GRAPH> TE <TE <TY...> TY VEC> IN VO VBFS<T,GRAPH>::Shift(VEC<T> inits){if(m_initialised){m_next.clear();CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);if(! m_found[i]){m_next.push_back(u);m_found[i]= true;}}}else{Initialise(MO(inits));}}TE <TY T,TY GRAPH> IN CRI VBFS<T,GRAPH>::SZ()CO NE{RE m_G.SZ();}TE <TY T,TY GRAPH> IN VE<bool>::reference VBFS<T,GRAPH>::found(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_found[i];}TE <TY T,TY GRAPH> IN CO T& VBFS<T,GRAPH>::prev(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_prev[i];}TE <TY T,TY GRAPH> IN T VBFS<T,GRAPH>::Next(){if(m_next.empty()){RE m_not_found;}CO T t_curr = m_next.front();m_next.pop_front();for(auto& t:m_G.Edge(t_curr)){auto&& i = m_G.Enumeration_inv(t);auto&& found_i = m_found[i];if(! found_i){Push(m_next,t);m_prev[i]= t_curr;found_i = true;}}RE t_curr;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>{Map<T,int> AN{};for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[*IT]= 0;}T t;WH((t = Next())!= m_not_found){if(AN.count(t)== 0){AN[t]= AN[m_prev[m_G.Enumeration_inv(t)]]+ 1;}}RE AN;}TE <TY T,TY GRAPH> TE <TY U>auto VBFS<T,GRAPH>::GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>{VE AN(SZ(),-1);for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[m_G.Enumeration_inv(*IT)]= 0;}T t;WH((t = Next())!= m_not_found){auto&& i = m_G.Enumeration_inv(t);AN[i]== -1?AN[i]= AN[m_G.Enumeration_inv(m_prev[i])]+ 1:AN[i];}RE AN;}TE <TY T,TY GRAPH>tuple<VE<int>,VE<VE<T>>,int> VBFS<T,GRAPH>::GetConnectedComponent(){ST_AS(!is_same_v<GRAPH,MemorisationGraph<T,decldecay_t(m_G.edge())>>);CRI V = SZ();VE cc_num(V,-1);VE<VE<T>> cc_num_inv{};int count = 0;for(int i = 0;i < V;i++){if(cc_num[i]== -1){Shift(m_G.Enumeration(i));T t = Next();if(t != m_not_found){cc_num_inv.push_back({});WH(t != m_not_found){cc_num[m_G.Enumeration_inv(t)]= count;cc_num_inv[count].push_back(t);t = Next();}count++;}}}RE{MO(cc_num),MO(cc_num_inv),count};}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetNodeEnumeration(){VE<T> AN{};T t = Next();WH(t != m_not_found){AN.push_back(t);t = Next();}RE AN;}TE <TY T,TY GRAPH>VE<T> VBFS<T,GRAPH>::GetReversedNodeEnumeration(){VE<T> AN{};VE<T> next{};T t;bool searched;WH(!(searched =(t = Next())== m_not_found)|| !next.empty()){WH(!next.empty()&&(searched || next.back()!= m_prev[m_G.Enumeration_inv(t)])){AN.push_back(next.back());next.pop_back();}if(!searched){next.push_back(t);}}RE AN;}TE <TY T,TY GRAPH> TE <TY PATH> IN VO VBFS<T,GRAPH>::Push(LI<T>& next,CO PATH& p){Push(next,get<0>(p));}

TE <TY T,TY GRAPH>CL BFS:PU VBFS<T,GRAPH>{PU:TE <TY...Args> IN BFS(GRAPH& G,CO T& not_found,Args&&... args);IN VO Push(LI<T>& next,CO T& t);};
TE <TY T,TY GRAPH> TE <TY...Args> IN BFS<T,GRAPH>::BFS(GRAPH& G,CO T& not_found,Args&&... args):VBFS<T,GRAPH>(G,not_found,forward<Args>(args)...){}TE <TY T,TY GRAPH> IN VO BFS<T,GRAPH>::Push(LI<T>& next,CO T& t){next.push_back(t);}

TE <TY GRAPH>VE<inner_t<GRAPH>> ShortestOddCycle(GRAPH& G,CO inner_t<GRAPH>& not_found,CO inner_t<GRAPH>& t_start){US T = inner_t<GRAPH>;CRI SZ = G.SZ();auto Enum =[&](CRI i){RE Pair<T,int>{G.Enumeration(i < SZ?i:i - SZ),i >= SZ};};auto EnumInv =[&](CO Pair<T,bool>& t){RE G.Enumeration_inv(t[O])+(t[I]?SZ:0);};auto edge =[&](CO Pair<T,int>& t){VE<Pair<T,int>> AN{};for(auto& u:G.Edge(t[O])){AN.push_back({G.Vertex(u),!t[I]});}RE AN;};EnumerationGraph G2{SZ * 2,Enum,EnumInv,edge};BFS bfs{G2,Pair<T,int>{not_found,true},Pair<T,int>{t_start,false}};VE<int> d = bfs.GetDistance();VE<T> a{};Pair<T,int> t{t_start,true};WH((t = bfs.prev(t))[O]!= not_found){a.push_back(t[O]);}auto&& i = G.Enumeration_inv(t_start);AS(d[i+SZ]== -1 || int(a.SZ())== d[i+SZ]);RE a;}TE <TY GRAPH>VE<inner_t<GRAPH>> ShortestOddCycle(GRAPH& G,CO inner_t<GRAPH>& not_found){US T = inner_t<GRAPH>;CRI SZ = G.SZ();VE<T> a{};for(int i = 0;i < SZ;i++){auto temp = ShortestOddCycle(G,not_found,G.Enumeration(i));if(!temp.empty()&&(a.empty()|| a.SZ()> temp.SZ())){a = MO(temp);}}RE a;}
#endif

