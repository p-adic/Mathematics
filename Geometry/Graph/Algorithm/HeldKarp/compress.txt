#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/HeldKarp/a_Body.hpp"
#else
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>CL AbstractHeldKarp:PU PointedSet<U>{PU:GRAPH& m_G;COMM_MONOID m_M;IN AbstractHeldKarp(GRAPH& G,COMM_MONOID M,CO U& infty);IN U GetDistance(CO T& t_start,CO VE<T>& t_factor,CO T& t_final,CO bool& revisitable,int factor_count_min = -1,int factor_count_max = -1);VE<U> GetDistance(CO T& t_start,CO VE<T>& t_factor,CO bool& revisitable,int factor_count_min = -1,int factor_count_max = -1);};TE <TY GRAPH,TY U,TY COMM_MONOID> AbstractHeldKarp(GRAPH& G,COMM_MONOID M,CO U& infty)-> AbstractHeldKarp<inner_t<GRAPH>,GRAPH,U,COMM_MONOID>;TE <TY T,TY GRAPH>CL HeldKarp:PU AbstractHeldKarp<T,GRAPH,ll,AdditiveMonoid<ll>>{PU:IN HeldKarp(GRAPH& G,CRL infty = 1e18);};TE <TY GRAPH,TY...ARGS> HeldKarp(GRAPH& G,CO ARGS&... args)-> HeldKarp<inner_t<GRAPH>,GRAPH>;
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> IN AbstractHeldKarp<T,GRAPH,U,COMM_MONOID>::AbstractHeldKarp(GRAPH& G,COMM_MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(is_same_v<T,inner_t<GRAPH>>);}TE <TY T,TY GRAPH> IN HeldKarp<T,GRAPH>::HeldKarp(GRAPH& G,CRL infty):AbstractHeldKarp<T,GRAPH,ll,AdditiveMonoid<ll>>(G,AdditiveMonoid<ll>(),infty){}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> IN U AbstractHeldKarp<T,GRAPH,U,COMM_MONOID>::GetDistance(CO T& t_start,CO VE<T>& t_factor,CO T& t_final,CO bool& revisitable,int factor_count_min,int factor_count_max){RE MO(GetDistance(t_start,t_factor,revisitable,factor_count_min,factor_count_max)[m_G.Enumeration_inv(t_final)]);}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>VE<U> AbstractHeldKarp<T,GRAPH,U,COMM_MONOID>::GetDistance(CO T& t_start,CO VE<T>& t_factor,CO bool& revisitable,int factor_count_min,int factor_count_max){CRI SZ = m_G.SZ();CO int factor_SZ = t_factor.SZ();AS(factor_SZ < 30);if(factor_count_min == -1){factor_count_min = factor_SZ;}if(factor_count_max == -1){factor_count_max = factor_SZ;}VE<int> t_factor_inv(SZ,-1);for(int i = 0;i < factor_SZ;i++){AS(t_factor_inv[t_factor[i]]== -1);t_factor_inv[t_factor[i]]= i;}CO int pw = 1 << factor_SZ;CO U& infty = TH->Infty();VE dp(pw,VE<U>(SZ,infty));VE<int> valid_factorisation{};auto&& i_start = m_G.Enumeration_inv(t_start);dp[t_factor_inv[i_start]== -1?0:1 << t_factor_inv[i_start]][i_start]= m_M.One();for(int S = 0;S < pw;S++){int c = __builtin_popcount(S);if(factor_count_max < c){continue;}if(factor_count_min <= c){valid_factorisation.push_back(S);}for(int i = 0;i < SZ;i++){if(dp[S][i]< infty){for(auto&[t,w]:m_G.Edge(m_G.Enumeration(i))){auto&& j = m_G.Enumeration_inv(t);auto&& k = t_factor_inv[j];if(revisitable || k == -1 ||((S >> k)& 1)== 0){CO int S_sup = S |(k == -1?0:(1 << k));dp[S_sup][j]= min(MO(dp[S_sup][j]),m_M.Product(dp[S][i],w));}}}}}VE<U> weight(SZ,infty);for(int i = 0;i < SZ;i++){for(auto& S:valid_factorisation){weight[i]= min(MO(weight[i]),dp[S][i]);}}RE weight;}
#endif

