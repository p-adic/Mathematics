#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/FloydWarshall/a_Body.hpp"
#else
TE <TY U,TY MONOID,TY SEMIGROUP>CL VirtualSemirng{PU:VI U Sum(U u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(U u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY U,TY MONOID,TY SEMIGROUP>CL AbstractSemirng:VI PU VirtualSemirng<U,MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(U u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(U u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY MONOID,TY SEMIGROUP> AbstractSemirng(MONOID R0,SEMIGROUP R1)-> AbstractSemirng<inner_t<MONOID>,MONOID,SEMIGROUP>;TE <TY U>CL Semirng:PU AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY U,TY MONOID,TY SEMIGROUP> IN AbstractSemirng<U,MONOID,SEMIGROUP>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Sum(U u0,CO U& u1){RE m_R0.Sum(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN CO U& AbstractSemirng<U,MONOID,SEMIGROUP>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Product(U u0,CO U& u1){RE m_R1.Product(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN MONOID& AbstractSemirng<U,MONOID,SEMIGROUP>::AdditiveMonoid()NE{RE m_R0;}TE <TY U,TY MONOID,TY SEMIGROUP> IN SEMIGROUP& AbstractSemirng<U,MONOID,SEMIGROUP>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

TE <TY U,TY MEET_SEMILATTICE,TY SEMIGROUP>CL VirtualMeetSemirng:VI PU VirtualSemirng<U,MEET_SEMILATTICE,SEMIGROUP>{PU:IN CO U& Infty()CO NE;IN U Meet(U u0,CO U& u1);};TE <TY U,TY SEMIGROUP>CL AbstractTropicalSemirng:VI PU VirtualMeetSemirng<U,MinSemilattice<U>,SEMIGROUP>,PU AbstractSemirng<U,MinSemilattice<U>,SEMIGROUP>{PU:IN AbstractTropicalSemirng(U infty_U,SEMIGROUP M);IN U Product(U u0,CO U& u1);};TE <TY U>CL AdditiveTropicalSemirng:PU AbstractTropicalSemirng<U,AdditiveMagma<U>>{PU:IN AdditiveTropicalSemirng(U infty_U);};TE <TY U>CL MultiplicativeTropicalSemirng:PU AbstractTropicalSemirng<U,MultiplicativeMagma<U>>{PU:IN MultiplicativeTropicalSemirng(U infty_U);};
TE <TY U,TY SEMIGROUP> IN AbstractTropicalSemirng<U,SEMIGROUP>::AbstractTropicalSemirng(U infty_U,SEMIGROUP M):AbstractSemirng<U,MinSemilattice<U>,SEMIGROUP>(MinSemilattice<U>(MO(infty_U)),MO(M)){}TE <TY U> IN AdditiveTropicalSemirng<U>::AdditiveTropicalSemirng(U infty_U):AbstractTropicalSemirng<U,AdditiveMagma<U>>(MO(infty_U),AdditiveMagma<U>()){}TE <TY U> IN MultiplicativeTropicalSemirng<U>::MultiplicativeTropicalSemirng(U infty_U):AbstractTropicalSemirng<U,MultiplicativeMagma<U>>(MO(infty_U),MultiplicativeMagma<U>()){}TE <TY U,TY MEET_SEMILATTICE,TY SEMIGROUP> IN CO U& VirtualMeetSemirng<U,MEET_SEMILATTICE,SEMIGROUP>::Infty()CO NE{RE TH->Zero();}TE <TY U,TY MEET_SEMILATTICE,TY SEMIGROUP> IN U VirtualMeetSemirng<U,MEET_SEMILATTICE,SEMIGROUP>::Meet(U u0,CO U& u1){RE TH->Sum(MO(u0),u1);}TE <TY U,TY SEMIGROUP> IN U AbstractTropicalSemirng<U,SEMIGROUP>::Product(U u0,CO U& u1){CO U& infty = TH->Infty();RE u0 < infty && u1 < infty?TH->MultiplicativeSemigroup().Product(MO(u0),u1):infty;}

TE <TY U,TY IDEMPOTENT_SEMIRNG>CL AbstractFloydWarshall{PU:IDEMPOTENT_SEMIRNG m_R;int m_SZ;VE<VE<U>> m_weight;VE<VE<int>> m_prev;IN AbstractFloydWarshall(IDEMPOTENT_SEMIRNG R,VE<VE<U>> d ={});VO Initialise(VE<VE<U>> d ={});VO SetMeet(CRI start,CRI goal,U u);IN CO U& Get(CRI start,CRI goal)CO;IN CRI prev(CRI start,CRI goal)CO;IN CO U& infty()CO NE;};TE <TY IDEMPOTENT_SEMIRNG> AbstractFloydWarshall(IDEMPOTENT_SEMIRNG)-> AbstractFloydWarshall<inner_t<IDEMPOTENT_SEMIRNG>,IDEMPOTENT_SEMIRNG>;TE <TY U>CL FloydWarshall:PU AbstractFloydWarshall<U,AdditiveTropicalSemirng<U>>{PU:IN FloydWarshall(U infty_U,VE<VE<U>> d ={});};
TE <TY U,TY IDEMPOTENT_SEMIRNG> IN AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::AbstractFloydWarshall(IDEMPOTENT_SEMIRNG R,VE<VE<U>> d):m_R(MO(R)),m_SZ(),m_weight(),m_prev(){ST_AS(is_same_v<U,inner_t<IDEMPOTENT_SEMIRNG>>);Initialise(MO(d));}TE <TY U> IN FloydWarshall<U>::FloydWarshall(U infty_U,VE<VE<U>> d):AbstractFloydWarshall<U,AdditiveTropicalSemirng<U>>(MO(infty_U),MO(d)){}TE <TY U,TY IDEMPOTENT_SEMIRNG>VO AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::Initialise(VE<VE<U>> d){m_weight = MO(d);m_SZ = m_weight.SZ();m_prev = VE(m_SZ,VE(m_SZ,-1));auto& weight_infty = infty();for(int i = 0;i < m_SZ;i++){AS(int(m_weight[i].SZ())== m_SZ);for(int j = 0;j < m_SZ;j++){if(m_weight[i][j]!= weight_infty){AS(m_weight[i][j]== m_R.Meet(m_weight[i][j],weight_infty));m_prev[i][j]= i;}}}for(int k = 0;k < m_SZ;k++){for(int i = 0;i < m_SZ;i++){for(int j = 0;j < m_SZ;j++){U weight_curr = m_R.Meet(m_R.Product(m_weight[i][k],m_weight[k][j]),m_weight[i][j]);if(m_weight[i][j]!= weight_curr){m_weight[i][j]= MO(weight_curr);m_prev[i][j]= k;}}}}RE;}TE <TY U,TY IDEMPOTENT_SEMIRNG>VO AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::SetMeet(CRI start,CRI goal,U u){AS(start != goal);u = m_R.Meet(MO(u),m_weight[start][goal]);if(u == m_weight[start][goal]){RE;}m_weight[start][goal]= MO(u);m_prev[start][goal]= start;for(int i = 0;i < m_SZ;i++){for(int j = 0;j < m_SZ;j++){U weight_curr = m_R.Meet(i == start?j == goal?u:m_R.Product(u,m_weight[goal][j]):m_R.Product(m_weight[i][start],j == goal?u:m_R.Product(u,m_weight[goal][j])),m_weight[i][j]);if(m_weight[i][j]!= weight_curr){m_weight[i][j]= MO(weight_curr);m_prev[i][j]= m_prev[goal==j?start:goal][j];}}}RE;}TE <TY U,TY IDEMPOTENT_SEMIRNG> IN CO U& AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::Get(CRI start,CRI goal)CO{RE m_weight[start][goal];}TE <TY U,TY IDEMPOTENT_SEMIRNG> IN CRI AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::prev(CRI start,CRI goal)CO{AS(start != goal);RE m_prev[start][goal];}TE <TY U,TY IDEMPOTENT_SEMIRNG> IN CO U& AbstractFloydWarshall<U,IDEMPOTENT_SEMIRNG>::infty()CO NE{RE m_R.Infty();}
#endif

