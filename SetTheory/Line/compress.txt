#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/Line/Debug/a_Body.hpp"
#else
TE <TY INT>CL IteratorOfLineSubset{PU:CO map<INT,INT>* m_p;TY map<INT,INT>::iterator m_IT;INT m_i;IN IteratorOfLineSubset(CO map<INT,INT>& l,TY map<INT,INT>::iterator IT,INT i);IN bool OP==(CO IteratorOfLineSubset<INT>& IT)CO NE;IN bool OP!=(CO IteratorOfLineSubset<INT>& IT)CO NE;IN INT OP*()CO;IN IteratorOfLineSubset<INT>& OP++();IN IteratorOfLineSubset<INT> OP++(int);IN IteratorOfLineSubset<INT>& OP--();IN IteratorOfLineSubset<INT> OP--(int);IN VO Next();IN VO Prev();IN pair<INT,INT> ConnectedComponent()CO;IN IteratorOfLineSubset<INT>& erase_from(map<INT,INT>& l);};
TE <TY INT> IN IteratorOfLineSubset<INT>::IteratorOfLineSubset(CO map<INT,INT>& l,TY map<INT,INT>::iterator IT,INT i):m_p(&l),m_IT(MO(IT)),m_i(MO(i)){}TE <TY INT> IN bool IteratorOfLineSubset<INT>::OP==(CO IteratorOfLineSubset<INT>& IT)CO NE{RE m_p == IT.m_p && m_IT == IT.m_IT && m_i == IT.m_i;}TE <TY INT> IN bool IteratorOfLineSubset<INT>::OP!=(CO IteratorOfLineSubset<INT>& IT)CO NE{RE !(*TH == IT);}TE <TY INT> IN INT IteratorOfLineSubset<INT>::OP*()CO{RE m_i;}TE <TY INT> IN IteratorOfLineSubset<INT>& IteratorOfLineSubset<INT>::OP++(){auto EN = m_p->EN();AS(m_IT != EN);if(m_i < m_IT->first){m_i++;}else{m_i = ++m_IT == EN?0:m_IT->second;}RE *TH;}TE <TY INT> IN IteratorOfLineSubset<INT> IteratorOfLineSubset<INT>::OP++(int){auto IT = *TH;++(*TH);RE IT;}TE <TY INT> IN IteratorOfLineSubset<INT>& IteratorOfLineSubset<INT>::OP--(){auto BE = m_p->BE();AS(m_IT != BE);m_IT->second < m_i?--m_i:m_i =(--m_IT)->first;RE *TH;}TE <TY INT> IN IteratorOfLineSubset<INT> IteratorOfLineSubset<INT>::OP--(int){auto IT = *TH;--(*TH);RE IT;}TE <TY INT> IN VO IteratorOfLineSubset<INT>::Next(){auto EN = m_p->EN();AS(m_IT != EN);m_i = ++m_IT == EN?0:m_IT->second;}TE <TY INT> IN VO IteratorOfLineSubset<INT>::Prev(){auto BE = m_p->BE();if(m_IT == BE){m_IT = m_p->EN();m_i = 0;}else{m_i =(--m_IT)->first;}}TE <TY INT> IN pair<INT,INT> IteratorOfLineSubset<INT>::ConnectedComponent()CO{auto EN = m_p->EN();AS(m_IT != EN);RE{m_IT->second,m_IT->first};}TE <TY INT> IN IteratorOfLineSubset<INT>& IteratorOfLineSubset<INT>::erase_from(map<INT,INT>& l){AS(&l == m_p);auto IT_copy =(*TH)++;l.erase(IT_copy);RE *TH;}

TE <TY INT>CL LineSubset{PU:map<INT,INT> m_l;int m_SZ;US iterator = IteratorOfLineSubset<INT>;VO insert(CO INT& i)NE;VO IntervalInsert(CO INT& i_start,CO INT& i_final)NE;VO erase(CO INT& i)NE;IN iterator& erase(iterator& IT);VO IntervalErase(CO INT& i_start,CO INT& i_final)NE;IN int count(CO INT& i)CO NE;bool find(CO INT& i)CO NE;IN CRI SZ()CO NE;IN bool empty()CO NE;IN VO clear()NE;IN iterator BE()CO NE;IN iterator EN()CO NE;IN iterator MaximumLeq(CO INT& i)CO NE;IN iterator MaximumLt(CO INT& i)CO NE;IN iterator MinimumGeq(CO INT& i)CO NE;IN iterator MinimumGt(CO INT& i)CO NE;IN INT Maximum()CO;IN INT Minimum()CO;pair<INT,INT> ConnectedComponentOf(CO INT& i)CO NE;IN CO map<INT,INT>& GetConnectedComponent()CO NE;};
TE <TY INT>VO LineSubset<INT>::insert(CO INT& i)NE{auto IT0 = m_l.lower_bound(i - 1),EN = m_l.EN();if(IT0 == EN){m_l[i]= i;m_SZ++;RE;}auto&[r0,l0]= *IT0;if(l0 <= i && i <= r0){RE;}m_SZ++;if(i + 1 == l0){l0--;RE;}if(i + 1 < l0){m_l[i]= i;RE;}auto IT1 = m_l.lower_bound(i + 1);if(IT1 == EN){m_l[i]= l0;}else{auto&[r1,l1]= *IT1;if(i + 1 < l1){m_l[i]= l0;}else{l1 = l0;}}m_l.erase(IT0);RE;}TE <TY INT> VO LineSubset<INT>::IntervalInsert(CO INT& i_start,CO INT& i_final)NE{if(i_start > i_final){RE;}insert(i_final);auto IT_i = m_l.lower_bound(i_final),EN_i = m_l.EN();INT& l =(IT_i--)->second = i_start;WH(IT_i != EN_i && i_start - 1 <= IT_i->first){if(IT_i->second < i_start){l = IT_i->second;}(IT_i = m_l.erase(IT_i))--;m_SZ--;}RE;}TE <TY INT>VO LineSubset<INT>::erase(CO INT& i)NE{auto IT = m_l.lower_bound(i);if(IT == m_l.EN()){RE;}auto&[r,l]= *IT;if(i < l){RE;}m_SZ--;if(l < i){m_l[i-1]= l;}if(i == r){m_l.erase(IT);}else{l = i + 1;}RE;}TE <TY INT> IN IteratorOfLineSubset<INT>& LineSubset<INT>::erase(IteratorOfLineSubset<INT>& IT){m_SZ--;RE IT.erase_from(m_l);}TE <TY INT> VO LineSubset<INT>::IntervalErase(CO INT& i_start,CO INT& i_final)NE{if(i_start > i_final){RE;}erase(i_start);auto IT_i = m_l.upper_bound(i_start),EN_i = m_l.EN();WH(IT_i != EN_i && IT_i->second <= i_final){if(i_final < IT_i->first){IT_i->second = i_final + 1;break;}else{IT_i = m_l.erase(IT_i);m_SZ--;}}RE;}TE <TY INT> IN int LineSubset<INT>::count(CO INT& i)CO NE{RE find(i)?1:0;}TE <TY INT>bool LineSubset<INT>::find(CO INT& i)CO NE{auto IT = m_l.lower_bound(i);if(IT == m_l.EN()){RE false;}RE IT->second <= i;}TE <TY INT> IN CRI LineSubset<INT>::SZ()CO NE{RE m_SZ;}TE <TY INT> IN bool LineSubset<INT>::empty()CO NE{RE m_SZ == 0;}TE <TY INT> IN VO LineSubset<INT>::clear()NE{m_l.clear();m_SZ = 0;}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::BE()CO NE{RE IteratorOfLineSubset<INT>{m_l,m_l.BE(),m_l.empty()?0:m_l.BE()->second};}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::EN()CO NE{RE IteratorOfLineSubset<INT>{m_l,m_l.EN(),0};}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::MaximumLeq(CO INT& i)CO NE{auto IT = m_l.lower_bound(i);if(IT != m_l.EN()&& IT->second <= i){RE IteratorOfLineSubset<INT>(m_l,IT,i);}if(IT == m_l.BE()){RE EN();}--IT;RE IteratorOfLineSubset<INT>{m_l,IT,IT->first};}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::MaximumLt(CO INT& i)CO NE{auto IT = m_l.lower_bound(i);if(IT != m_l.EN()&& IT->second < i){RE IteratorOfLineSubset<INT>(m_l,IT,i - 1);}if(IT == m_l.BE()){RE EN();}--IT;RE IteratorOfLineSubset<INT>{m_l,IT,IT->first};}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::MinimumGeq(CO INT& i)CO NE{auto IT = m_l.lower_bound(i);RE IT == m_l.EN()?EN():IteratorOfLineSubset<INT>(m_l,IT,max(i,IT->second));}TE <TY INT> IN IteratorOfLineSubset<INT> LineSubset<INT>::MinimumGt(CO INT& i)CO NE{auto IT = m_l.upper_bound(i);RE IT == m_l.EN()?EN():IteratorOfLineSubset<INT>(m_l,IT,max(i + 1,IT->second));}TE <TY INT> IN INT LineSubset<INT>::Maximum()CO{AS(!m_l.empty());RE(--m_l.EN())->first;}TE <TY INT> IN INT LineSubset<INT>::Minimum()CO{AS(!m_l.empty());RE m_l.BE()->second;}TE <TY INT>pair<INT,INT> LineSubset<INT>::ConnectedComponentOf(CO INT& i)CO NE{auto IT = m_l.lower_bound(i);if(IT == m_l.EN()){RE{i+1,i-1};}RE IT->second <= i?pair<INT,INT>{IT->second,IT->first}:pair<INT,INT>{i+1,i-1};}TE <TY INT> IN CO map<INT,INT>& LineSubset<INT>::GetConnectedComponent()CO NE{RE m_l;}
#endif
