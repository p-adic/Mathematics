#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/Trie/a_Body.hpp"
#else
#define DF_OF_SEARCH_IN_TRIE_TREE(NEW_EDGE,UPDATE_COUNT_IS,UPDATE_COUNT)int node = 0;UPDATE_COUNT_IS;for(auto& i:ToArray(v)){AS(i >= 0);auto& edge = m_edge[node];if(edge.count(i)== 0){NEW_EDGE;}else{node = edge[i];}UPDATE_COUNT_IS;}UPDATE_COUNT;
TE <TY INT = int>CL TrieTree{PU:VE<pair<INT,INT>> m_count;VE<map<int,int>> m_edge;IN TrieTree();TE <TY V> VO insert(CO V& v,CO INT& count = 1);TE <TY V> IN VO erase(CO V& v);TE <TY V> VO erase(CO V& v,CO INT& count);IN VO clear();IN bool empty()CO NE;IN CO INT& SZ()CO NE;TE <TY V> pair<INT,INT> count(CO V& v);VO Increment(VE<int>& v)CO;VO Decrement(VE<int>& v)CO;IN VE<int> Maximum();IN VE<int> Minimum();TE <TY V> VE<int> MaximumLeq(CO V& v);TE <TY V> VE<int> MinimumGeq(CO V& v);TE <TY V> IN VE<int> MaximumLt(CO V& v);TE <TY V> IN VE<int> MinimumGt(CO V& v);VE<int> ReversedMaximum(CO VE<bool>& v);IN VE<int> ReversedMinimum(VE<bool> v);ST VE<int> ToArray(ll v,CRI M);ST VE<int> ToArray(ll v,CRI M,CRI L);ST CO VE<int>& ToArray(CO VE<int>& v);ST IN VE<int> ToArray(CO char* CO& v);TE <TY V> ST VE<int> ToArray(CO V& v);TE <TY RANGE> VO SetNextNode(CO map<int,int>& edge,VE<int>& AN,int& node,RANGE range)CO;TE <TY SEARCH,TY RANGE> VO SetMaximum_Body(VE<int>& AN,int& node,SEARCH search,RANGE range)CO;IN VO SetMaximum(VE<int>& AN,int& node)CO;IN VO SetMinimum(VE<int>& AN,int& node)CO;TE <TY RANGE> VO SetMaximumLeq_Body(CO VE<int>& v,VE<int>& AN,int& node,bool& lt,RANGE range)CO;};
TE <TY INT> IN TrieTree<INT>::TrieTree():m_count(1),m_edge(1){}TE <TY INT> TE <TY V>VO TrieTree<INT>::insert(CO V& v,CO INT& count){if(count == 0){RE;}AS(count > 0);DF_OF_SEARCH_IN_TRIE_TREE(node = edge[i]= m_count.SZ();m_count.push_back({0,0});m_edge.push_back({}),m_count[node].second += count,m_count[node].first += count);}TE <TY INT> TE <TY V> IN VO TrieTree<INT>::erase(CO V& v){auto&& val = ToArray(v);erase(val,count(val).first);}TE <TY INT> TE <TY V>VO TrieTree<INT>::erase(CO V& v,CO INT& count){if(count == 0){RE;}AS(count > 0);DF_OF_SEARCH_IN_TRIE_TREE(abort(),AS((m_count[node].second -= count)>= 0),AS((m_count[node].first -= count)>= 0));}TE <TY INT> IN VO TrieTree<INT>::clear(){m_count.resize(1);m_count[0]={0,0};m_edge.resize(1);m_edge[0].clear();}TE <TY INT> IN bool TrieTree<INT>::empty()CO NE{RE SZ()== 0;}TE <TY INT> IN CO INT& TrieTree<INT>::SZ()CO NE{RE m_count[0].second;}TE <TY INT> TE <TY V>pair<INT,INT> TrieTree<INT>::count(CO V& v){bool found = true;DF_OF_SEARCH_IN_TRIE_TREE(found = false;break,,);RE found?m_count[node]:pair<INT,INT>{0,0};}TE <TY INT>VO TrieTree<INT>::Increment(VE<int>& v)CO{int L = v.SZ();VE<int> node(L + 1);for(int i = 0;i < L;i++){node[i+1]= m_edge[node[i]].at(v[i]);}WH(true){auto&[count,count_is]= m_count[node[L]];AS(count <= count_is);if(count != count_is){break;}WH(v[L-1]== m_edge[node[L-1]].rBE()->first){v.pop_back();node.pop_back();L--;if(L == 0){v ={-1};RE;}}auto&&[key,val]= *(m_edge[node[L-1]].upper_bound(v[L-1]));v[L-1]= key;node[L]= val;if(m_count[node[L]].first > 0){RE;}}auto& edge = m_edge[node[L]];for(auto IT = edge.BE(),EN = edge.EN();IT != EN;IT++){if(m_count[IT->second].second > 0){v.push_back(IT->first);int node_curr = IT->second;SetMinimum(v,node_curr);RE;}}abort();}TE <TY INT>VO TrieTree<INT>::Decrement(VE<int>& v)CO{int L = v.SZ();VE<int> node(L + 1);for(int i = 0;i < L;i++){node[i+1]= m_edge[node[i]].at(v[i]);}WH(true){WH(v[L-1]== m_edge[node[L-1]].BE()->first){v.pop_back();node.pop_back();L--;if(L == 0){v ={-1};RE;}}auto&&[key,val]= *reverse_iterator(m_edge[node[L-1]].lower_bound(v[L-1]));v[L-1]= key;node[L]= val;if(m_count[node[L]].second > 0){break;}}SetMaximum(v,node[L]);RE;}TE <TY INT> TE <TY RANGE>VO TrieTree<INT>::SetNextNode(CO map<int,int>& edge,VE<int>& AN,int& node,RANGE range)CO{ST_AS(is_invocable_v<RANGE,CO map<int,int>&>);bool found = false;for(auto[IT,EN]= range(edge);IT != EN;IT++){if(m_count[IT->second].second != 0){found = true;AN.push_back(IT->first);node = IT->second;break;}}AS(found);RE;}TE <TY INT> TE <TY SEARCH,TY RANGE>VO TrieTree<INT>::SetMaximum_Body(VE<int>& AN,int& node,SEARCH search,RANGE range)CO{ST_AS(is_invocable_v<SEARCH,CO pair<INT,INT>&>);WH(true){if(search(m_count[node])){break;}SetNextNode(m_edge[node],AN,node,range);}RE;}TE <TY INT> IN VO TrieTree<INT>::SetMaximum(VE<int>& AN,int& node)CO{SetMaximum_Body(AN,node,[&](CO pair<INT,INT>& count){AS(count.first <= count.second);RE count.first == count.second;},[&](CO map<int,int>& edge){RE pair{edge.rBE(),edge.rend()};});}TE <TY INT> IN VO TrieTree<INT>::SetMinimum(VE<int>& AN,int& node)CO{SetMaximum_Body(AN,node,[&](CO pair<INT,INT>& count){AS(count.first <= count.second);RE count.first > 0;},[&](CO map<int,int>& edge){RE pair{edge.BE(),edge.EN()};});}TE <TY INT> IN VE<int> TrieTree<INT>::Maximum(){VE<int> AN{};int node = 0;SetMaximum(AN,node);RE AN;}TE <TY INT> IN VE<int> TrieTree<INT>::Minimum(){VE<int> AN{};int node = 0;SetMinimum(AN,node);RE AN;}TE <TY INT> TE <TY RANGE>VO TrieTree<INT>::SetMaximumLeq_Body(CO VE<int>& v,VE<int>& AN,int& node,bool& lt,RANGE range)CO{ST_AS(is_invocable_v<RANGE,CO map<int,int>&,CRI>);for(auto& i:v){AS(i >= 0);auto& edge = m_edge[node];bool found = false;for(auto[IT,EN]= range(edge,i);IT != EN;IT++){if(m_count[IT->second].second != 0){found = true;AN.push_back(IT->first);node = IT->second;lt = IT->first != i;break;}}if(!found || lt){break;}}RE;}TE <TY INT> TE <TY V>VE<int> TrieTree<INT>::MaximumLeq(CO V& v){auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool lt = false;SetMaximumLeq_Body(val,AN,node,lt,[&](CO map<int,int>& edge,CRI i){RE pair{reverse_iterator(edge.upper_bound(i)),edge.rend()};});if(lt){SetMaximum(AN,node);}else if(AN != VE{-1}&& m_count[node].first == 0){Decrement(AN);}AS(AN == VE{-1}|| val >= AN);RE AN;}TE <TY INT> TE <TY V>VE<int> TrieTree<INT>::MinimumGeq(CO V& v){auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool gt = false;SetMaximumLeq_Body(val,AN,node,gt,[&](CO map<int,int>& edge,CRI i){RE pair{edge.lower_bound(i),edge.EN()};});if(gt){SetMinimum(AN,node);}else if(AN != VE{-1}){CO bool lt = AN < val;if(lt){SetMaximum(AN,node);}if(lt || m_count[node].first == 0){Increment(AN);}}AS(AN == VE{-1}|| val <= AN);RE AN;}TE <TY INT> TE <TY V> IN VE<int> TrieTree<INT>::MaximumLt(CO V& v){auto&& val = ToArray(v);VE<int> AN = MaximumLeq(val);if(AN != VE{-1}&& val == AN){Decrement(AN);AS(AN == VE{-1}|| val > AN);}RE AN;}TE <TY INT> TE <TY V> IN VE<int> TrieTree<INT>::MinimumGt(CO V& v){auto&& val = ToArray(v);VE<int> AN = MinimumGeq(val);if(AN != VE{-1}&& val == AN){Increment(AN);AS(AN == VE{-1}|| val < AN);}RE AN;}TE <TY INT>VE<int> TrieTree<INT>::ReversedMaximum(CO VE<bool>& v){if(empty()){RE{-1};}auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool lt = false;for(auto& reversed:v){if(reversed){SetNextNode(m_edge[node],AN,node,[&](CO map<int,int>& edge){RE pair{edge.BE(),edge.EN()};});}else{SetNextNode(m_edge[node],AN,node,[&](CO map<int,int>& edge){RE pair{edge.rBE(),edge.rend()};});}}RE AN;}TE <TY INT> IN VE<int> TrieTree<INT>::ReversedMinimum(VE<bool> v){v.flip();RE ReversedMaximum(v);}TE <TY INT> IN CO VE<int>& TrieTree<INT>::ToArray(CO VE<int>& v){RE v;}TE <TY INT>VE<int> TrieTree<INT>::ToArray(ll v,CRI M){AS(v >= 0);VE<int> AN{};WH(v > 0){AN.push_back(v % M);v /= M;}int L = AN.SZ();int L_half = L >> 1;for(int i = 0;i < L_half;i++){swap(AN[i],AN[L-1-i]);}RE AN;}TE <TY INT>VE<int> TrieTree<INT>::ToArray(ll v,CRI M,CRI L){AS(v >= 0);VE<int> AN(L);for(int i = 0;i < L;i++){AN[L-1-i]=v % M;v /= M;}RE AN;}TE <TY INT> IN VE<int> TrieTree<INT>::ToArray(CO char* CO& v){RE ToArray(string(v));}TE <TY INT> TE <TY V>VE<int> TrieTree<INT>::ToArray(CO V& v){CO int L = v.SZ();VE<int> AN(L);for(int i = 0;i < L;i++){if CE(is_same_v<V,string>){AN[i]= v[i]-(v[i]< 'a'?'A':'a');}else{AN[i]= v[i];}}RE AN;}
#endif

