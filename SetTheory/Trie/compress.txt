#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/Trie/a_Body.hpp"
#else
#define DF_OF_SEARCH_IN_TRIE_TREE(NEW_EDGE,UPDATE_COUNT_IS,UPDATE_COUNT)int node = 0;UPDATE_COUNT_IS;for(auto& i:ToArray(v)){AS(i >= 0);auto& edge = m_edge[node];if(edge.count(i)== 0){NEW_EDGE;}else{node = edge[i];}UPDATE_COUNT_IS;}UPDATE_COUNT;
TE <TY U,TY ABEL_GROUP>CL TrieTree{PU:ABEL_GROUP m_M;VE<pair<U,U>> m_count;VE<map<int,int>> m_edge;IN TrieTree(ABEL_GROUP M);TE <TY V> VO insert(CO V& v,CO U& u);TE <TY V> IN VO erase(CO V& v);TE <TY V> IN VO erase(CO V& v,CO U& u);IN VO clear();IN bool empty()CO NE;IN CO U& SZ()CO NE;TE <TY V> pair<U,U> count(CO V& v);VO Increment(VE<int>& v)CO;VO Decrement(VE<int>& v)CO;IN VE<int> Maximum();IN VE<int> Minimum();TE <TY V> VE<int> MaximumLeq(CO V& v);TE <TY V> VE<int> MinimumGeq(CO V& v);TE <TY V> IN VE<int> MaximumLt(CO V& v);TE <TY V> IN VE<int> MinimumGt(CO V& v);VE<int> ReversedMaximum(CO VE<bool>& v);IN VE<int> ReversedMinimum(VE<bool> v);TE <TY V> VO swap(CO V& v0,CO V& v1);ST VE<int> ToArray(ll v,CRI M);ST VE<int> ToArray(ll v,CRI M,CRI L);ST CO VE<int>& ToArray(CO VE<int>& v);ST IN VE<int> ToArray(CO char* CO& v);TE <TY V> ST VE<int> ToArray(CO V& v);TE <TY RANGE> VO SetNextNode(CO map<int,int>& edge,VE<int>& AN,int& node,RANGE range)CO;TE <TY SEARCH,TY RANGE> VO SetMaximum_Body(VE<int>& AN,int& node,SEARCH search,RANGE range)CO;IN VO SetMaximum(VE<int>& AN,int& node)CO;IN VO SetMinimum(VE<int>& AN,int& node)CO;TE <TY RANGE> VO SetMaximumLeq_Body(CO VE<int>& v,VE<int>& AN,int& node,bool& lt,RANGE range)CO;};TE <TY ABEL_GROUP> TrieTree(ABEL_GROUP)-> TrieTree<inner_t<ABEL_GROUP>,ABEL_GROUP>;
TE <TY U,TY ABEL_GROUP> IN TrieTree<U,ABEL_GROUP>::TrieTree(ABEL_GROUP M):m_M(MO(M)),m_count{{m_M.Zero(),m_M.Zero()}},m_edge(1){ST_AS(is_same_v<U,inner_t<ABEL_GROUP>>);}TE <TY U,TY ABEL_GROUP> TE <TY V>VO TrieTree<U,ABEL_GROUP>::insert(CO V& v,CO U& count){CO U& zero = m_M.Zero();if(count == zero){RE;}DF_OF_SEARCH_IN_TRIE_TREE(node = edge[i]= m_count.SZ();m_count.push_back({zero,zero});m_edge.push_back({}),m_count[node].second = m_M.Sum(MO(m_count[node].second),count),m_count[node].first = m_M.Sum(MO(m_count[node].first),count));}TE <TY U,TY ABEL_GROUP> TE <TY V> IN VO TrieTree<U,ABEL_GROUP>::erase(CO V& v){auto&& val = ToArray(v);erase(val,count(val).first);}TE <TY U,TY ABEL_GROUP> TE <TY V> IN VO TrieTree<U,ABEL_GROUP>::erase(CO V& v,CO U& count){insert(v,m_M.Inverse(count));}TE <TY U,TY ABEL_GROUP> IN VO TrieTree<U,ABEL_GROUP>::clear(){m_count.resize(1);m_count[0]={m_M.Zero(),m_M.Zero()};m_edge.resize(1);m_edge[0].clear();}TE <TY U,TY ABEL_GROUP> IN bool TrieTree<U,ABEL_GROUP>::empty()CO NE{RE SZ()== m_M.Zero();}TE <TY U,TY ABEL_GROUP> IN CO U& TrieTree<U,ABEL_GROUP>::SZ()CO NE{RE m_count[0].second;}TE <TY U,TY ABEL_GROUP> TE <TY V>pair<U,U> TrieTree<U,ABEL_GROUP>::count(CO V& v){bool found = true;DF_OF_SEARCH_IN_TRIE_TREE(found = false;break,,);RE found?m_count[node]:pair<U,U>{m_M.Zero(),m_M.Zero()};}TE <TY U,TY ABEL_GROUP>VO TrieTree<U,ABEL_GROUP>::Increment(VE<int>& v)CO{int L = v.SZ();VE<int> node(L + 1);for(int i = 0;i < L;i++){node[i+1]= m_edge[node[i]].at(v[i]);}CO U& zero = m_M.Zero();WH(true){auto&[count,count_is]= m_count[node[L]];AS(!(count_is < count));if(count != count_is){break;}WH(v[L-1]== m_edge[node[L-1]].rBE()->first){v.pop_back();node.pop_back();L--;if(L == 0){v ={-1};RE;}}auto&&[key,val]= *(m_edge[node[L-1]].upper_bound(v[L-1]));v[L-1]= key;node[L]= val;if(zero < m_count[node[L]].first){RE;}}auto& edge = m_edge[node[L]];for(auto IT = edge.BE(),EN = edge.EN();IT != EN;IT++){if(zero < m_count[IT->second].second){v.push_back(IT->first);int node_curr = IT->second;SetMinimum(v,node_curr);RE;}}abort();}TE <TY U,TY ABEL_GROUP>VO TrieTree<U,ABEL_GROUP>::Decrement(VE<int>& v)CO{int L = v.SZ();VE<int> node(L + 1);for(int i = 0;i < L;i++){node[i+1]= m_edge[node[i]].at(v[i]);}CO U& zero = m_M.Zero();WH(true){WH(v[L-1]== m_edge[node[L-1]].BE()->first){v.pop_back();node.pop_back();L--;if(L == 0){v ={-1};RE;}}auto&&[key,val]= *reverse_iterator(m_edge[node[L-1]].lower_bound(v[L-1]));v[L-1]= key;node[L]= val;if(zero < m_count[node[L]].second){break;}}SetMaximum(v,node[L]);RE;}TE <TY U,TY ABEL_GROUP> TE <TY RANGE>VO TrieTree<U,ABEL_GROUP>::SetNextNode(CO map<int,int>& edge,VE<int>& AN,int& node,RANGE range)CO{ST_AS(is_invocable_v<RANGE,CO map<int,int>&>);bool found = false;CO U& zero = m_M.Zero();for(auto[IT,EN]= range(edge);IT != EN;IT++){if(m_count[IT->second].second != zero){found = true;AN.push_back(IT->first);node = IT->second;break;}}AS(found);RE;}TE <TY U,TY ABEL_GROUP> TE <TY SEARCH,TY RANGE>VO TrieTree<U,ABEL_GROUP>::SetMaximum_Body(VE<int>& AN,int& node,SEARCH search,RANGE range)CO{ST_AS(is_invocable_v<SEARCH,CO pair<U,U>&>);WH(true){if(search(m_count[node])){break;}SetNextNode(m_edge[node],AN,node,range);}RE;}TE <TY U,TY ABEL_GROUP> IN VO TrieTree<U,ABEL_GROUP>::SetMaximum(VE<int>& AN,int& node)CO{SetMaximum_Body(AN,node,[&](CO pair<U,U>& count){AS(!(count.second < count.first));RE count.first == count.second;},[&](CO map<int,int>& edge){RE pair{edge.rBE(),edge.rend()};});}TE <TY U,TY ABEL_GROUP> IN VO TrieTree<U,ABEL_GROUP>::SetMinimum(VE<int>& AN,int& node)CO{SetMaximum_Body(AN,node,[&](CO pair<U,U>& count){AS(!(count.second,count.first));RE m_M.Zero()< count.first;},[&](CO map<int,int>& edge){RE pair{edge.BE(),edge.EN()};});}TE <TY U,TY ABEL_GROUP> IN VE<int> TrieTree<U,ABEL_GROUP>::Maximum(){VE<int> AN{};int node = 0;SetMaximum(AN,node);RE AN;}TE <TY U,TY ABEL_GROUP> IN VE<int> TrieTree<U,ABEL_GROUP>::Minimum(){VE<int> AN{};int node = 0;SetMinimum(AN,node);RE AN;}TE <TY U,TY ABEL_GROUP> TE <TY RANGE>VO TrieTree<U,ABEL_GROUP>::SetMaximumLeq_Body(CO VE<int>& v,VE<int>& AN,int& node,bool& lt,RANGE range)CO{ST_AS(is_invocable_v<RANGE,CO map<int,int>&,CRI>);CO U& zero = m_M.Zero();for(auto& i:v){AS(i >= 0);auto& edge = m_edge[node];bool found = false;for(auto[IT,EN]= range(edge,i);IT != EN;IT++){if(m_count[IT->second].second != zero){found = true;AN.push_back(IT->first);node = IT->second;lt = IT->first != i;break;}}if(!found || lt){break;}}RE;}TE <TY U,TY ABEL_GROUP> TE <TY V>VE<int> TrieTree<U,ABEL_GROUP>::MaximumLeq(CO V& v){auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool lt = false;SetMaximumLeq_Body(val,AN,node,lt,[&](CO map<int,int>& edge,CRI i){RE pair{reverse_iterator(edge.upper_bound(i)),edge.rend()};});if(lt){SetMaximum(AN,node);}else if(AN != VE{-1}&& m_count[node].first == m_M.Zero()){Decrement(AN);}AS(AN == VE{-1}|| val >= AN);RE AN;}TE <TY U,TY ABEL_GROUP> TE <TY V>VE<int> TrieTree<U,ABEL_GROUP>::MinimumGeq(CO V& v){auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool gt = false;SetMaximumLeq_Body(val,AN,node,gt,[&](CO map<int,int>& edge,CRI i){RE pair{edge.lower_bound(i),edge.EN()};});if(gt){SetMinimum(AN,node);}else if(AN != VE{-1}){CO bool lt = AN < val;if(lt){SetMaximum(AN,node);}if(lt || m_count[node].first == m_M.Zero()){Increment(AN);}}AS(AN == VE{-1}|| val <= AN);RE AN;}TE <TY U,TY ABEL_GROUP> TE <TY V> IN VE<int> TrieTree<U,ABEL_GROUP>::MaximumLt(CO V& v){auto&& val = ToArray(v);VE<int> AN = MaximumLeq(val);if(AN != VE{-1}&& val == AN){Decrement(AN);AS(AN == VE{-1}|| val > AN);}RE AN;}TE <TY U,TY ABEL_GROUP> TE <TY V> IN VE<int> TrieTree<U,ABEL_GROUP>::MinimumGt(CO V& v){auto&& val = ToArray(v);VE<int> AN = MinimumGeq(val);if(AN != VE{-1}&& val == AN){Increment(AN);AS(AN == VE{-1}|| val < AN);}RE AN;}TE <TY U,TY ABEL_GROUP>VE<int> TrieTree<U,ABEL_GROUP>::ReversedMaximum(CO VE<bool>& v){if(empty()){RE{-1};}auto&& val = ToArray(v);VE<int> AN ={};int node = 0;bool lt = false;for(auto& reversed:v){if(reversed){SetNextNode(m_edge[node],AN,node,[&](CO map<int,int>& edge){RE pair{edge.BE(),edge.EN()};});}else{SetNextNode(m_edge[node],AN,node,[&](CO map<int,int>& edge){RE pair{edge.rBE(),edge.rend()};});}}RE AN;}TE <TY U,TY ABEL_GROUP> IN VE<int> TrieTree<U,ABEL_GROUP>::ReversedMinimum(VE<bool> v){v.flip();RE ReversedMaximum(v);}TE <TY U,TY ABEL_GROUP> TE <TY V>VO TrieTree<U,ABEL_GROUP>::swap(CO V& v0,CO V& v1){CO U& zero = m_M.Zero();VE<int> node0 ={0};for(auto& i:v0){auto& edge = m_edge[node0.back()];if(edge.count(i)== 0){node0.push_back(edge[i]= m_count.SZ());m_count.push_back({zero,zero});m_edge.push_back({});}else{node0.push_back(edge[i]);}}VE<int> node1 ={0};for(auto& i:v1){auto& edge = m_edge[node1.back()];if(edge.count(i)== 0){node1.push_back(edge[i]= m_count.SZ());m_count.push_back({zero,zero});m_edge.push_back({});}else{node1.push_back(edge[i]);}}m_edge[node0.back()].swap(m_edge[node1.back()]);U diff = m_M.Sum(m_count[node0.back()],m_M.Inverse(m_count[node1.back()]));for(auto& node:node1){m_count[node]= m_M.Sum(MO(m_count[node]),diff);}diff = m_M.Inverse(diff);for(auto& node:node0){m_count[node]= m_M.Sum(MO(m_count[node]),diff);}RE;}TE <TY U,TY ABEL_GROUP> IN CO VE<int>& TrieTree<U,ABEL_GROUP>::ToArray(CO VE<int>& v){RE v;}TE <TY U,TY ABEL_GROUP>VE<int> TrieTree<U,ABEL_GROUP>::ToArray(ll v,CRI M){AS(v >= 0);VE<int> AN{};WH(v > 0){AN.push_back(v % M);v /= M;}int L = AN.SZ();int L_half = L >> 1;for(int i = 0;i < L_half;i++){swap(AN[i],AN[L-1-i]);}RE AN;}TE <TY U,TY ABEL_GROUP>VE<int> TrieTree<U,ABEL_GROUP>::ToArray(ll v,CRI M,CRI L){AS(v >= 0);VE<int> AN(L);for(int i = 0;i < L;i++){AN[L-1-i]=v % M;v /= M;}RE AN;}TE <TY U,TY ABEL_GROUP> IN VE<int> TrieTree<U,ABEL_GROUP>::ToArray(CO char* CO& v){RE ToArray(string(v));}TE <TY U,TY ABEL_GROUP> TE <TY V>VE<int> TrieTree<U,ABEL_GROUP>::ToArray(CO V& v){CO int L = v.SZ();VE<int> AN(L);for(int i = 0;i < L;i++){if CE(is_same_v<V,string>){AN[i]= v[i]-(v[i]< 'a'?'A':'a');}else{AN[i]= v[i];}}RE AN;}
#endif

