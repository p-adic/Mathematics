#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/CoordinateCompress/Debug/a_Body.hpp"
#else
TE <TY INT = ll>CL CoordinateCompress{PU:set<INT> m_r;VE<INT*> m_l;IN CoordinateCompress();IN VO SetR(INT t);TE <TY U,TE <TY...> TY V > IN VO SetR(V<U> a);tuple<VE<INT>,unordered_map<INT,int>,int> GetR();IN VO clearR();IN VO SetL(INT& t);TE <TY U,TE <TY...> TY V > IN VO SetL(V<U>& a);pair<VE<INT>,int> GetL();IN VO clearL();};TE <TY INT> IN CoordinateCompress<INT>::CoordinateCompress():m_r(),m_l(){}TE <TY INT> IN VO CoordinateCompress<INT>::SetR(INT t){m_r.insert(MO(t));}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetR(V<U> a){for(auto& t:a){SetR(MO(t));}}TE <TY INT>tuple<VE<INT>,unordered_map<INT,int>,int> CoordinateCompress<INT>::GetR(){tuple<VE<INT>,unordered_map<INT,int>,int> AN{};auto&[value,value_inv,value_max]= AN;value.resize(m_r.SZ());for(auto t:m_r){value[value_inv[t]= value_max++]= t;}RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearR(){m_r.clear();}TE <TY INT> IN VO CoordinateCompress<INT>::SetL(INT& t){m_l.push_back(&t);}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetL(V<U>& a){for(auto& t:a){SetL(t);}}TE <TY INT>pair<VE<INT>,int> CoordinateCompress<INT>::GetL(){pair<VE<INT>,int> AN{{},-1};auto&[value,value_max]= AN;if(!m_l.empty()){auto comp =[](INT* CO& p0,INT* CO& p1){RE *p0 < *p1;};sort(m_l.BE(),m_l.EN(),comp);INT temp = *(m_l[0])- 1;for(auto p:m_l){*p = temp == *p?value_max:(value.push_back(temp = *p),++value_max);}}value_max++;RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearL(){m_l.clear();}
#endif
