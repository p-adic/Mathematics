#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Dual/GeometricProgressionMin/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);IN CRI size()CO NE;IN CRI BucketSize()CO NE;IN CRI BucketCount()CO NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,RoundUpSqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN CRI SqrtDecompositionCoordinate::size()CO NE{RE m_N;}IN CRI SqrtDecompositionCoordinate::BucketSize()CO NE{RE m_N_sqrt;}IN CRI SqrtDecompositionCoordinate::BucketCount()CO NE{RE m_N_d;}

TE <TY R,TY PT_MAGMA,TY U,TY R_SET>CL DualSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:PT_MAGMA m_L;R_SET m_X;VE<U> m_a;VE<R> m_b;TE <TY...Args> IN DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a ={},CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);TE <TY Arg> IN VO IntervalAct(CRI i_start,CRI i_final,CO Arg& r);IN U OP[](CRI i);IN U Get(CRI i);IN VO Update(CRI d);};TE <TY PT_MAGMA,TY R_SET,TY...Args> DualSqrtDecomposition(PT_MAGMA M,R_SET X,Args&&... args)-> DualSqrtDecomposition<inner_t<PT_MAGMA>,PT_MAGMA,inner_t<R_SET>,R_SET>;
TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_L(MO(L)),m_X(MO(X)),m_a(MO(a)),m_b(m_N_d,m_L.Point()){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<R_SET>>);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Initialise(Args&&... args){DualSqrtDecomposition<R,PT_MAGMA,U,R_SET> temp{m_L,m_X,forward<decay_t<Args>>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Set(CRI i,CO U& u){U& m_ai = m_a[i];if(m_ai != u){Update(i / m_N_sqrt);m_ai = u;}}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY Arg> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::IntervalAct(CRI i_start,CRI i_final,CO Arg& r){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);CO R r_copy = m_L.Action(r,m_L.Point());if(d_0 > 0){Update(d_0 - 1);}for(int i = i_min;i < i_0;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}for(int d = d_0;d < d_1;d++){R& m_bd = m_b[d];m_bd = m_L.Action(r,MO(m_bd));}if(d_1 < m_N_d){Update(d_1);}for(int i = i_1;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}RE;}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_X.Action(m_b[i / m_N_sqrt],m_a[i]);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Get(CRI i){RE OP[](i);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Update(CRI d){R& m_bd = m_b[d];CO R& point = m_L.Point();if(m_bd != point){CO int j_min = d * m_N_sqrt;CO int j_ulim = min(j_min + m_N_sqrt,m_N);for(int j = j_min;j < j_ulim;j++){U& m_aj = m_a[j];m_aj = m_X.Action(m_bd,MO(m_aj));}m_bd = point;}RE;}

TE <TY U>CL GeometricProgressionMinComposition:VI PU PointedSet<VE<U>>,VI PU VirtualRSet<pair<int,U>,VE<U>>{PU:IN GeometricProgressionMinComposition(CRI SZ,CO U& infty);VE<U> Action(CO pair<int,U>& y0,VE<U> y1);};TE <TY U,TY N_MODULE>CL GeometricProgressionMinAction:VI PU VirtualRSet<VE<U>,pair<U,int>>{PU:N_MODULE m_M;CO VE<U>* m_p_memory_r;IN GeometricProgressionMinAction(N_MODULE M,CO VE<U>& memory_r);pair<U,int> Action(CO VE<U>& y,pair<U,int> u);};
TE <TY U,TY N_MODULE>US BaseOfGeometricProgressionMinDualSqrtDecomposition = DualSqrtDecomposition<VE<U>,GeometricProgressionMinComposition<U>,pair<U,int>,GeometricProgressionMinAction<U,N_MODULE>>;
TE <TY U,TY N_MODULE>CL GeometricProgressionMinDualSqrtDecomposition:PU BaseOfGeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>{PU:VE<U> m_memory_r;TE <TY...Args> IN GeometricProgressionMinDualSqrtDecomposition(N_MODULE M,CO U& infty,VE<U> memory_r,VE<U> a ={},Args&&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,U u);IN VO IntervalAct(CRI i_start,CRI i_final,CO VE<U>& f)= delete;IN VO IntervalSetMin(CRI i_start,CRI i_final,CRI r_num,CO U& y);IN U OP[](CRI i);IN U Get(CRI i);ST VE<pair<U,int>> GetGraph(VE<U> a);};TE <TY N_MODULE,TY...Args> GeometricProgressionMinDualSqrtDecomposition(N_MODULE M,Args&&... args)-> GeometricProgressionMinDualSqrtDecomposition<inner_t<N_MODULE>,N_MODULE>;
TE <TY U> IN GeometricProgressionMinComposition<U>::GeometricProgressionMinComposition(CRI SZ,CO U& infty):PointedSet<VE<U>>(VE(SZ,infty)){}TE <TY U,TY N_MODULE> IN GeometricProgressionMinAction<U,N_MODULE>::GeometricProgressionMinAction(N_MODULE M,CO VE<U>& memory_r):m_M(MO(M)),m_p_memory_r(&memory_r){ST_AS(is_same_v<U,inner_t<N_MODULE>>);}TE <TY U>VE<U> GeometricProgressionMinComposition<U>::Action(CO pair<int,U>& y0,VE<U> y1){U& y1_r = y1[y0.first];y1_r = min(y1_r,y0.second);RE MO(y1);}TE <TY U,TY N_MODULE>pair<U,int> GeometricProgressionMinAction<U,N_MODULE>::Action(CO VE<U>& y,pair<U,int> u){CO int SZ = y.SZ();for(int i = 0;i < SZ;i++){u.first = min(u.first,m_M.Product(m_M.PW((*m_p_memory_r)[i],u.second),y[i]));}RE MO(u);}TE <TY U,TY N_MODULE> TE <TY...Args> IN GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::GeometricProgressionMinDualSqrtDecomposition(N_MODULE M,CO U& infty,VE<U> memory_r,VE<U> a,Args&&... args):BaseOfGeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>(GeometricProgressionMinComposition<U>(memory_r.SZ(),infty),GeometricProgressionMinAction<U,N_MODULE>(MO(M),m_memory_r),GetGraph(MO(a)),forward<decay_t<Args>>(args)...),m_memory_r(MO(memory_r)){}TE <TY U,TY N_MODULE> TE <TY...Args> IN VO GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::Initialise(Args&&... args){GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE> temp{TH->m_M,forward<decay_t<Args>>(args)...};SqrtDecompositionCoordinate::OP=(temp);TH->m_a = MO(temp.m_a);TH->m_b = MO(temp.m_b);m_memory_r = MO(temp.m_memory_r);}TE <TY U,TY N_MODULE> IN VO GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::Set(CRI i,U u){BaseOfGeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::Set(i,{MO(u),i});}TE <TY U,TY N_MODULE> IN VO GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::IntervalSetMin(CRI i_start,CRI i_final,CRI r_num,CO U& y){AS(0 <= r_num && r_num < int(m_memory_r.SZ()));BaseOfGeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::IntervalAct(i_start,i_final,pair<int,U>{r_num,y});}TE <TY U,TY N_MODULE> IN U GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::OP[](CRI i){RE BaseOfGeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::OP[](i).first;}TE <TY U,TY N_MODULE> IN U GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY N_MODULE> IN VE<pair<U,int>> GeometricProgressionMinDualSqrtDecomposition<U,N_MODULE>::GetGraph(VE<U> a){CO int SZ = a.SZ();VE<pair<U,int>> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={MO(a[i]),i};}RE AN;}
#endif

