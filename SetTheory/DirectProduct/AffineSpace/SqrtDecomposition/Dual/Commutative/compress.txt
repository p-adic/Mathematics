#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Dual/Commutative/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

TE <TY R,TY PT_MAGMA,TY U,TY R_SET>CL DualSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:PT_MAGMA m_L;R_SET m_X;VE<U> m_a;VE<R> m_b;TE <TY...Args> IN DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a ={},CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);TE <TY Arg> IN VO IntervalAct(CRI i_start,CRI i_final,CO Arg& r);IN U OP[](CRI i);IN U Get(CRI i);IN VO Update(CRI d);};TE <TY PT_MAGMA,TY R_SET,TY...Args> DualSqrtDecomposition(PT_MAGMA M,R_SET X,Args&&... args)-> DualSqrtDecomposition<inner_t<PT_MAGMA>,PT_MAGMA,inner_t<R_SET>,R_SET>;
TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_L(MO(L)),m_X(MO(X)),m_a(MO(a)),m_b(m_N_d,m_L.Point()){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<R_SET>>);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Initialise(Args&&... args){DualSqrtDecomposition<R,PT_MAGMA,U,R_SET> temp{m_L,m_X,forward<decay_t<Args>>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Set(CRI i,CO U& u){U& m_ai = m_a[i];if(m_ai != u){Update(i / m_N_sqrt);m_ai = u;}}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY Arg> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::IntervalAct(CRI i_start,CRI i_final,CO Arg& r){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);CO R r_copy = m_L.Action(r,m_L.Point());if(d_0 > 0){Update(d_0 - 1);}for(int i = i_min;i < i_0;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}for(int d = d_0;d < d_1;d++){R& m_bd = m_b[d];m_bd = m_L.Action(r,MO(m_bd));}if(d_1 < m_N_d){Update(d_1);}for(int i = i_1;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}RE;}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_X.Action(m_b[i / m_N_sqrt],m_a[i]);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Get(CRI i){RE OP[](i);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Update(CRI d){R& m_bd = m_b[d];CO R& point = m_L.Point();if(m_bd != point){CO int j_min = d * m_N_sqrt;CO int j_ulim = min(j_min + m_N_sqrt,m_N);for(int j = j_min;j < j_ulim;j++){U& m_aj = m_a[j];m_aj = m_X.Action(m_bd,MO(m_aj));}m_bd = point;}RE;}

TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_SET>CL CommutativeDualSqrtDecomposition:PU DualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_SET>{PU:TE <TY...Args> IN CommutativeDualSqrtDecomposition(PT_COMM_MAGMA L,R_SET X,Args&&... args);IN VO Act(CRI i,CO R& r);};TE <TY PT_COMM_MAGMA,TY R_SET,TY...Args> CommutativeDualSqrtDecomposition(PT_COMM_MAGMA M,R_SET X,Args&&... args)-> CommutativeDualSqrtDecomposition<inner_t<PT_COMM_MAGMA>,PT_COMM_MAGMA,inner_t<R_SET>,R_SET>;
TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_SET> TE <TY...Args> IN CommutativeDualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_SET>::CommutativeDualSqrtDecomposition(PT_COMM_MAGMA L,R_SET X,Args&&... args):DualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_SET>(MO(L),MO(X),forward<decay_t<Args>>(args)...){}TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_SET> IN VO CommutativeDualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_SET>::Act(CRI i,CO R& r){TH->Update(i / TH->m_N_sqrt);U& m_ai = TH->m_a[i];m_ai = TH->m_X.Action(r,MO(m_ai));}
#endif

