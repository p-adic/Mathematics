#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Optimisation/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

CL SqrtDecompositionOptimisation:PU SqrtDecompositionCoordinate{PU:VE<int> m_rand;TE <TY...Args> IN SqrtDecompositionOptimisation(CRI N = 0,CO Args&... args);TE <TY...Args> IN VO Initialise(CO Args&... args);TE <TY FUNC> int Minimise(FUNC& func);};
TE <TY...Args> IN SqrtDecompositionOptimisation::SqrtDecompositionOptimisation(CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_rand(m_N_d){AS(m_N > 0);for(int d = 0;d < m_N_d;d++){m_rand[d]= GetRand(- m_N_sqrt / 10,m_N_sqrt / 10);}m_rand[0]= max(m_rand[0],0);if(m_N_d > 0){m_rand[m_N_d-1]= min(m_rand[m_N_d-1],m_N - 1 -(m_N_m - m_N_sqrt));}}TE <TY...Args> IN VO SqrtDecompositionOptimisation::Initialise(CO Args&... args){SqrtDecompositionOptimisation temp{args...};SqrtDecompositionCoordinate::OP=(temp);m_rand = MO(temp.m_rand);}TE <TY FUNC>int SqrtDecompositionOptimisation::Minimise(FUNC& func){ST_AS(is_invocable_v<FUNC,CRI>);US U = ret_t<FUNC,CRI>;int d0 = 0;U u = func(m_rand[d0]);int i = m_N_sqrt;for(int d = 1;d < m_N_d;i += m_N_sqrt,++d){U temp = func(i + m_rand[d]);temp < u?(u = MO(temp),d0 = d):d0;}i = d0 > 0?m_N_sqrt *(d0 - 1):0;int i_ulim = min(i + m_N_sqrt * 2,m_N);int AN = i;u = func(i);WH(++i < i_ulim){U temp = func(i);temp < u?(u = MO(temp),AN = i):AN;}RE AN;}
#endif
