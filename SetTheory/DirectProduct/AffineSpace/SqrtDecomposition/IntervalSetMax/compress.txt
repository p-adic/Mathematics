#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/IntervalSetMax/a_Body.hpp"
#else
TE <TY INT> CE INT Log(INT N){INT AN = 0,pw = 1;WH(N > pw){pw <<= 1;AN++;}RE AN;}

CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);IN CRI size()CO NE;IN CRI BucketSize()CO NE;IN CRI BucketCount()CO NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,RoundUpSqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN CRI SqrtDecompositionCoordinate::size()CO NE{RE m_N;}IN CRI SqrtDecompositionCoordinate::BucketSize()CO NE{RE m_N_sqrt;}IN CRI SqrtDecompositionCoordinate::BucketCount()CO NE{RE m_N_d;}

TE <TY U,TY Z_MODULE>CL IntervalSetMaxAbstractSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:Z_MODULE m_M;VE<U> m_a;VE<U> m_b;U m_val_min;VE<U> m_lazy_set_max;VE<bool> m_a_updated;VE<int> m_b_updated;VE<set<pair<U,int>>> m_set;IN IntervalSetMaxAbstractSqrtDecomposition(CO Z_MODULE& M,CO U& val_min,CRI N = 0);IntervalSetMaxAbstractSqrtDecomposition(Z_MODULE M,CO U& val_min,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO SetMax(CRI i,CO U& u);IN VO IntervalSetMax(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalSum(CRI i_start,CRI i_final);IntervalSetMaxAbstractSqrtDecomposition(Z_MODULE& M,CO U& val_min,CRI N,VE<U>& a);IN VO IntervalSetMax_Body(CRI i_min,CRI i_ulim,CRI d,CO U& u);IN U IntervalSum_Body(CRI i_min,CRI i_ulim,CRI d);};TE <TY Z_MODULE,TY...Args> IntervalSetMaxAbstractSqrtDecomposition(Z_MODULE M,Args&&... args)-> IntervalSetMaxAbstractSqrtDecomposition<inner_t<Z_MODULE>,Z_MODULE>;TE <TY U>CL IntervalSetMaxSqrtDecomposition:PU IntervalSetMaxAbstractSqrtDecomposition<U,Module<int,U>>{PU:TE <TY...Args> IN IntervalSetMaxSqrtDecomposition(Args&&... args);};TE <TY U,TY...Args> IntervalSetMaxSqrtDecomposition(CO U& val_min,Args&&... args)-> IntervalSetMaxSqrtDecomposition<U>;
TE <TY U,TY Z_MODULE> IN IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSetMaxAbstractSqrtDecomposition(CO Z_MODULE& M,CO U& val_min,CRI N):IntervalSetMaxAbstractSqrtDecomposition(M,val_min,VE<U>(N,M.Zero())){}TE <TY U,TY Z_MODULE>IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSetMaxAbstractSqrtDecomposition(Z_MODULE M,CO U& val_min,VE<U> a):IntervalSetMaxAbstractSqrtDecomposition(M,val_min,a.SZ(),a){}TE <TY U,TY Z_MODULE>IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSetMaxAbstractSqrtDecomposition(Z_MODULE& M,CO U& val_min,CRI N,VE<U>& a):SqrtDecompositionCoordinate(N,RoundUpSqrt(N / max(1,Log(N)))),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.Zero()),m_val_min(val_min),m_lazy_set_max(m_N_d,m_val_min),m_a_updated(m_N),m_b_updated(m_N_d),m_set(m_N_d){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<Z_MODULE>>);m_a.resize(m_N_m,m_M.Zero());int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];auto& m_set_d = m_set[d];for(int i = i_min;i < i_ulim;i++){AS(!(m_a[i]< m_val_min));m_bd = m_M.Sum(MO(m_bd),m_a[i]);m_set_d.insert({m_a[i],i});}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY U> TE <TY...Args> IN IntervalSetMaxSqrtDecomposition<U>::IntervalSetMaxSqrtDecomposition(Args&&... args):IntervalSetMaxAbstractSqrtDecomposition<U,Module<int,U>>(Module<int,U>(),forward<Args>(args)...){}TE <TY U,TY Z_MODULE> TE <TY...Args> IN VO IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::Initialise(Args&&... args){IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE> temp{m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);m_lazy_set_max = MO(temp.m_laze_set_max);m_a_updated = MO(temp.m_a_updated);m_b_updated = MO(temp.m_b_updated);m_set = MO(temp.m_set);}TE <TY U,TY Z_MODULE> IN VO IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::SetMax(CRI i,CO U& u){IntervalSetMax(i,i,u);}TE <TY U,TY Z_MODULE> IN VO IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSetMax(CRI i_start,CRI i_final,CO U& u){AS(!(u < m_val_min));CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int d_0_N_sqrt = d_0 * m_N_sqrt;CO int d_1_N_sqrt = d_1 * m_N_sqrt;CO int i_0 = min(d_0_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1_N_sqrt);if(i_min < i_0){if(m_lazy_set_max[d_0 - 1]< u){IntervalSetMax_Body(i_min,i_0,d_0 - 1,u);}}for(int d = d_0;d < d_1;d++){U& m_lazy_set_max_d = m_lazy_set_max[d];if(m_lazy_set_max_d < u){m_lazy_set_max_d = u;auto& m_set_d = m_set[d];WH(!m_set_d.empty()){auto IT = m_set_d.BE();auto&[m_ai,i]= *IT;if(!(m_ai < u)){break;}U& m_bd = m_b[d];m_bd = m_M.Sum(m_bd,m_M.Inverse(m_ai));m_a[i]= m_M.Zero();m_a_updated[i]= true;m_b_updated[d]++;m_set_d.erase(IT);}}}if(i_1 < i_ulim){if(m_lazy_set_max[d_1]< u){IntervalSetMax_Body(i_1,i_ulim,d_1,u);}}RE;}TE <TY U,TY Z_MODULE> IN VO IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSetMax_Body(CRI i_min,CRI i_ulim,CRI d,CO U& u){U& m_bd = m_b[d];int& m_b_updated_d = m_b_updated[d];auto& m_set_d = m_set[d];for(int i = i_min;i < i_ulim;i++){if(m_a_updated[i]){m_a_updated[i]= false;m_b_updated_d--;}else if(!(m_a[i]< u)){continue;}else{m_bd = m_M.Sum(MO(m_bd),m_M.Inverse(m_a[i]));m_set_d.erase({m_a[i],i});}m_set_d.insert({m_a[i]= u,i});m_bd = m_M.Sum(MO(m_bd),m_a[i]);}RE;}TE <TY U,TY Z_MODULE> IN U IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_a_updated[i]?m_lazy_set_max[i / m_N_sqrt]:m_a[i];}TE <TY U,TY Z_MODULE> IN U IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY Z_MODULE> IN U IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSum(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.Zero();if(i_min < i_0){AN = IntervalSum_Body(i_min,i_0,d_0 - 1);}for(int d = d_0;d < d_1;d++){AN = m_M.Sum(m_M.Sum(MO(AN),m_b[d]),m_M.ScalarProduct(m_b_updated[d],m_lazy_set_max[d]));}if(i_1 < i_ulim){AN = m_M.Sum(MO(AN),IntervalSum_Body(i_1,i_ulim,d_1));}RE AN;}TE <TY U,TY Z_MODULE> IN U IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSum_Body(CRI i_min,CRI i_ulim,CRI d){U AN = m_M.Zero();CO U& m_lazy_set_max_d = m_lazy_set_max[d];for(int i = i_min;i < i_ulim;i++){AN = m_M.Sum(MO(AN),m_a_updated[i]?m_lazy_set_max_d:m_a[i]);}RE AN;}TE <CL Traits,TY U,TY Z_MODULE> IN OS& OP<<(OS& os,IntervalSetMaxAbstractSqrtDecomposition<U,Z_MODULE>& sd){CRI N = sd.SZ();for(int i = 0;i < N;i++){(i > 0?os << " ":os)<< sd[i];}RE os;}
#endif

