#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Mo/a_Body.hpp"
#else
CL Mo{PU:int m_Q;int m_Y_d;VE<VE<tuple<int,int,int>>> m_query;IN Mo()= default;TE <TY QUERY> IN Mo(CO QUERY& query,int y_dif_sqrt = 0);TE <TY QUERY> IN VO Set(CO QUERY& query,int y_dif_sqrt = 0);IN CO VE<VE<tuple<int,int,int>>>& Get()CO NE;TE <TY F,TY DFxp,TY DFxm,TY DFyp,TY DFym,TY G> VE<decay_t<ret_t<G,ret_t<F,int,int>,int>>> Solve(F& f,DFxp& dfxp,DFxm& dfxm,DFyp& dfyop,DFym& dfym,G& g)CO;TE <TY F,TY DFxp,TY DFxm,TY DFyp,TY DFym> IN VE<ret_t<F,int,int>> Solve(F& f,DFxp& dfxp,DFxm& dfxm,DFyp& dfyp,DFym& dfym)CO;TE <TY QUERY> IN VO IntroSort(CO QUERY& query,CRI y_start,CRI y_dif_sqrt);TE <TY QUERY> IN VO BucketSort(CO QUERY& query,CRI x_start,CRI x_dif,CRI y_start,CRI y_dif_sqrt);TE <TY R,TY DFxp,TY DFxm,TY DFyp,TY DFym,TY G> VO Solve_Body(VE<R>& AN,R& temp,int& x,int& y,DFxp& dfxp,DFxm& dfxm,DFyp& dfyp,DFym& dfym,CRI d,CRI i_start,G& g)CO;};
TE <TY QUERY> IN Mo::Mo(CO QUERY& query,int y_dif_sqrt):Mo(){Set(query,y_dif_sqrt);}TE <TY QUERY> IN VO Mo::Set(CO QUERY& query,int y_dif_sqrt){m_Q = query.SZ();if(m_Q > 0){auto[x_start,y_start]= query[0];int x_final = x_start;int y_final = y_start;for(int q = 1;q < m_Q;q++){auto&[x,y]= query[q];x < x_start?x_start = x:x_final < x?x_final = x:x_final;y < y_start?y_start = y:y_final < y?y_final = y:y_final;}CO int x_dif = x_final - x_start + 1;CO int x_div = x_dif / m_Q;CO int y_dif = y_final - y_start + 1;y_dif_sqrt == 0?y_dif_sqrt = RoundUpSqrt(y_dif):y_dif_sqrt;m_query.resize(m_Y_d = y_dif / y_dif_sqrt + 1);if(x_div < 31 && m_Q >> x_div > 0){BucketSort(query,x_start,x_dif,y_start,y_dif_sqrt);}else{IntroSort(query,y_start,y_dif_sqrt);}}RE;}TE <TY QUERY> IN VO Mo::IntroSort(CO QUERY& query,CRI y_start,CRI y_dif_sqrt){VE<tuple<int,int,int>> intro_sort(m_Q);for(int q = 0;q < m_Q;q++){auto&[x,y]= query[q];intro_sort[q]={x,y,q};}sort(intro_sort.BE(),intro_sort.EN());for(int i = 0;i < m_Q;i++){auto&[x,y,q]= intro_sort[i];m_query[(y - y_start)/ y_dif_sqrt].push_back({x,y,q});}RE;}TE <TY QUERY> IN VO Mo::BucketSort(CO QUERY& query,CRI x_start,CRI x_dif,CRI y_start,CRI y_dif_sqrt){VE<VE<int>> bucket_sort(x_dif);for(int q = 0;q < m_Q;q++){bucket_sort[get<0>(query[q])- x_start].push_back(q);}for(int x = 0;x < x_dif;x++){auto& bucket_x = bucket_sort[x];CO int SZ = bucket_x.SZ();for(int i = 0;i < SZ;i++){CRI q = bucket_x[i];auto&[x,y]= query[q];m_query[(y - y_start)/ y_dif_sqrt].push_back({x,y,q});}}RE;}IN CO VE<VE<tuple<int,int,int>>>& Mo::Get()CO NE{RE m_query;}TE <TY F,TY DFxp,TY DFxm,TY DFyp,TY DFym,TY G> VE<decay_t<ret_t<G,ret_t<F,int,int>,int>>> Mo::Solve(F& f,DFxp& dfxp,DFxm& dfxm,DFyp& dfyp,DFym& dfym,G& g)CO{US R1 = ret_t<F,int,int>;ST_AS(is_invocable_r_v<R1,DFxp,R1,int,int,int> && is_invocable_r_v<R1,DFxm,R1,int,int,int> && is_invocable_r_v<R1,DFyp,R1,int,int,int> && is_invocable_r_v<R1,DFym,R1,int,int,int>);US R2 = decay_t<ret_t<G,CO R1&,int>>;VE<R2> AN(m_Q);if(m_Q > 0){int d = 0;WH(m_query[d].empty()){d++;}auto[x,y,q]= m_query[d][0];R1 temp = f(x,y);AN[q]= g(temp,q);Solve_Body(AN,temp,x,y,dfxp,dfxm,dfyp,dfym,d,1,g);WH(++d < m_Y_d){Solve_Body(AN,temp,x,y,dfxp,dfxm,dfyp,dfym,d,0,g);}}RE AN;}TE <TY F,TY DFxp,TY DFxm,TY DFyp,TY DFym> IN VE<ret_t<F,int,int>> Mo::Solve(F& f,DFxp& dfxp,DFxm& dfxm,DFyp& dfyp,DFym& dfym)CO{US R = ret_t<F,int,int>;auto id =[&](R r,CRI){RE MO(r);};RE Solve(f,dfxp,dfxm,dfyp,dfym,id);}TE <TY R,TY DFxp,TY DFxm,TY DFyp,TY DFym,TY G> VO Mo::Solve_Body(VE<R>& AN,R& temp,int& x,int& y,DFxp& dfxp,DFxm& dfxm,DFyp& dfyp,DFym& dfym,CRI d,CRI i_start,G& g)CO{auto& m_query_d = m_query[d];CO int SZ = m_query_d.SZ();for(int i = i_start;i < SZ;i++){auto&[x_next,y_next,q]= m_query_d[i];if(x < x_next){temp = dfxp(MO(temp),x,y,x_next);}else if(x > x_next){temp = dfxm(MO(temp),x,y,x_next);}x = x_next;if(y < y_next){temp = dfyp(MO(temp),x,y,y_next);}else if(y > y_next){temp = dfym(MO(temp),x,y,y_next);}y = y_next;AN[q]= g(temp,q);}RE;}
#endif

