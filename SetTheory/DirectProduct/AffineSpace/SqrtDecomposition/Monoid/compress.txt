#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Monoid/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);IN CRI size()CO NE;IN CRI BucketSize()CO NE;IN CRI BucketCount()CO NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,RoundUpSqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN CRI SqrtDecompositionCoordinate::size()CO NE{RE m_N;}IN CRI SqrtDecompositionCoordinate::BucketSize()CO NE{RE m_N_sqrt;}IN CRI SqrtDecompositionCoordinate::BucketCount()CO NE{RE m_N_d;}

#define SFINAE_FOR_SD_S enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY MONOID>CL MonoidSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:MONOID m_M;VE<U> m_a;VE<U> m_b;VE<bool> m_updated;TE <TY...Args> IN MonoidSqrtDecomposition(MONOID M,CRI N = 0,CO Args&... args);TE <TY...Args> IN MonoidSqrtDecomposition(MONOID M,VE<U> a,CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN CO U& BucketProduct(CRI d);IN U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_SD_S = nullptr> IN int Search(CRI i_start,CO F& f,CO bool& reversed = false);IN int Search(CRI i_start,CO U& u,CO bool& reversed = false);TE <TY F> int Search_Body(CRI i_start,CO F& f,U product_temp);TE <TY F> int SearchReverse_Body(CRI i_final,CO F& f,U product_temp);VO ComputeProduct(CRI d);};TE <TY MONOID,TY...Args> MonoidSqrtDecomposition(MONOID M,Args&&...args)-> MonoidSqrtDecomposition<inner_t<MONOID>,MONOID>;
TE <TY U,TY MONOID> TE <TY...Args> IN MonoidSqrtDecomposition<U,MONOID>::MonoidSqrtDecomposition(MONOID M,CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_M(MO(M)),m_a(m_N_m,m_M.Zero()),m_b(m_N_d,m_M.Zero()),m_updated(m_N_d,false){ST_AS(is_same_v<U,inner_t<MONOID>>);}TE <TY U,TY MONOID> TE <TY...Args> IN MonoidSqrtDecomposition<U,MONOID>::MonoidSqrtDecomposition(MONOID M,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.Zero()),m_updated(m_N_d,false){ST_AS(is_same_v<U,inner_t<MONOID>>);m_a.resize(m_N_m,m_M.One());}TE <TY U,TY MONOID> TE <TY...Args> IN VO MonoidSqrtDecomposition<U,MONOID>::Initialise(Args&&... args){MonoidSqrtDecomposition<U,MONOID> temp{m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);m_updated = MO(temp.m_updated);}TE <TY U,TY MONOID> IN VO MonoidSqrtDecomposition<U,MONOID>::Set(CRI i,CO U& u){CO int d = i / m_N_sqrt;m_a[i]= u;m_updated[d]= true;}TE <TY U,TY MONOID> IN CO U& MonoidSqrtDecomposition<U,MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_N);RE m_a[i];}TE <TY U,TY MONOID> IN CO U& MonoidSqrtDecomposition<U,MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY MONOID> IN CO U& MonoidSqrtDecomposition<U,MONOID>::BucketProduct(CRI d){if(m_updated[d]){ComputeProduct(d);}RE m_b[d];}TE <TY U,TY MONOID> IN U MonoidSqrtDecomposition<U,MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();for(int i = i_min;i < i_0;i++){AN = m_M.Product(MO(AN),m_a[i]);}for(int d = d_0;d < d_1;d++){AN = m_M.Product(MO(AN),BucketProduct(d));}for(int i = i_1;i < i_ulim;i++){AN = m_M.Product(MO(AN),m_a[i]);}RE AN;}TE <TY U,TY MONOID> TE <TY F,SFINAE_FOR_SD_S> IN int MonoidSqrtDecomposition<U,MONOID>::Search(CRI i_start,CO F& f,CO bool& reversed){RE reversed?SearchReverse_Body(i_start,f,m_M.Zero()):Search_Body(i_start,f,m_M.Zero());}TE <TY U,TY MONOID> IN int MonoidSqrtDecomposition<U,MONOID>::Search(CRI i_start,CO U& u,CO bool& reversed){RE Search(i_start,[&](CO U& product,CRI){RE !(product < u);},reversed);}TE <TY U,TY MONOID> TE <TY F> int MonoidSqrtDecomposition<U,MONOID>::Search_Body(CRI i_start,CO F& f,U product_temp){CO int i_min = max(i_start,0);CO int d_0 = i_min / m_N_sqrt + 1;CO int i_0 = min(d_0 * m_N_sqrt,m_N);for(int i = i_min;i < i_0;i++){product_temp = m_M.Product(MO(product_temp),m_a[i]);if(f(product_temp,i)){RE i;}}for(int d = d_0;d < m_N_d;d++){U product_next = m_M.Product(product_temp,BucketProduct(d));if(f(product_next,min((d + 1)* m_N_sqrt,m_N)- 1)){RE Search_Body(d * m_N_sqrt,f,MO(product_temp));}product_temp = MO(product_next);}RE -1;}TE <TY U,TY MONOID> TE <TY F> int MonoidSqrtDecomposition<U,MONOID>::SearchReverse_Body(CRI i_final,CO F& f,U product_temp){CO int i_max = min(i_final,m_N - 1);CO int d_1 = i_max / m_N_sqrt;CO int i_1 = max(d_1 * m_N_sqrt,0);for(int i = i_max;i >= i_1;i--){product_temp = m_M.Product(m_a[i],product_temp);if(f(product_temp,i)){RE i;}}for(int d = d_1 - 1;d >= 0;d--){U product_next = m_M.Product(BucketProduct(d),product_temp);if(f(product_next,d * m_N_sqrt)){RE Search_Body((d + 1)* m_N_sqrt - 1,f,MO(product_temp));}product_temp = MO(product_next);}RE -1;}TE <TY U,TY MONOID> VO MonoidSqrtDecomposition<U,MONOID>::ComputeProduct(CRI d){int i_min = d * m_N_sqrt;int i_ulim = i_min + m_N_sqrt;U& m_bd = m_b[d]= m_M.One();for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(MO(m_bd),m_a[i]);}m_updated[d]= false;RE;}
#endif
