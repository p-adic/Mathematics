#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/DifferenceSequence/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<pair<int,int>> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<pair<int,int>> LinearEdge::OP()(CRI t){VE<pair<int,int>> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back({t - 1,1});}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back({t + 1,1});}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

CL LinearPrev{PU:IN int OP()(CRI i);};IN int LinearPrev::OP()(CRI i){RE i - 1;}

TE <TY ACYCLIC_GRAPH>VE<inner_t<ACYCLIC_GRAPH>> TopologicalSort(ACYCLIC_GRAPH& G){CRI SZ = G.SZ();VE<inner_t<ACYCLIC_GRAPH>> AN(SZ);VE<bool> edged(SZ),fixed(SZ);int num = SZ - 1;for(int i = 0;i < SZ;i++){if(!fixed[i]){VE<VE<int>> dfs ={{i}};WH(!dfs.empty()){auto& e = dfs.back();if(e.empty()){dfs.pop_back();}else{CRI j = e.back();if(fixed[j]){e.pop_back();}else{auto&& t = G.Enumeration(j);if(edged[j]){fixed[j]= true;AN[num--]= t;e.pop_back();}else{edged[j]= true;auto&& edge_t = G.Edge(t);VE<int> edge_j{};for(auto& u:edge_t){auto&& k = G.Enumeration_inv(u);if(!fixed[k]){edge_j.push_back(k);}}dfs.push_back(MO(edge_j));}}}}}}RE AN;}

TE <TY DIRECTED_FOREST>tuple<VE<inner_t<DIRECTED_FOREST>>,VE<int>,VE<int>,VE<VE<int>>> TopologicalSortedForest(DIRECTED_FOREST& G){VE<inner_t<DIRECTED_FOREST>> ts = TopologicalSort(G);CRI SZ = G.SZ();VE<int> ts_inv(SZ);VE<int> prev(SZ,-1);VE<VE<int>> edge(SZ);for(int i = SZ - 1;i >= 0;i--){auto& t = ts[i];auto&& edge_t = G.Edge(t);auto& edge_i = edge[i];edge_i.reserve(edge_t.SZ());for(auto& u:edge_t){CRI j = ts_inv[G.Enumeration_inv(u)];prev[j]= i;edge_i.push_back(j);}ts_inv[G.Enumeration_inv(t)]= i;}RE{MO(ts),MO(ts_inv),MO(prev),MO(edge)};}

TE <TY UNDIRECTED_TREE> tuple<VE<inner_t<UNDIRECTED_TREE>>,VE<int>,VE<int>,VE<VE<int>>> TopologicalSortedTree(UNDIRECTED_TREE& G,CO inner_t<UNDIRECTED_TREE>& root){CRI SZ = G.SZ();US T = inner_t<UNDIRECTED_TREE>;VE<VE<T>> edge(SZ);VE<T> dfs{root};WH(!dfs.empty()){CO T t = dfs.back();dfs.pop_back();auto& edge_i = edge[G.Enumeration_inv(t)];auto&& edge_t = G.Edge(t);for(auto& u:edge_t){auto&& j = G.Enumeration_inv(u);if(edge[j].empty()){edge_i.push_back(u);dfs.push_back(u);}}}auto G_dir = G.GetGraph([&](CO T& t)-> CO VE<T>&{RE edge[G.Enumeration_inv(t)];});RE TopologicalSortedForest(G_dir);}

TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP>CL AbstractDifferenceSequence{PU:FOREST m_G;PREV m_prev;GROUP m_M;VE<U> m_a;int m_degree;IN AbstractDifferenceSequence(FOREST G,PREV prev,GROUP M,int degree = 1);IN AbstractDifferenceSequence(FOREST G,PREV prev,GROUP M,VE<U> a,int degree = 0);TE <TY...Args> IN VO Initialise(Args&&... args);CRI SZ()CO NE;IN VO Set(CO T& t,CO U& u,CRI degree = 0);IN VO Add(CO T& t,CO U& u,CRI degree = 0);IN VO FinalSegmentAdd(CO T& t_start,CO U& u,CRI degree = 0);IN VO SubtreeAdd(CO T& t_start,CO VE<T>& t_outisde,CO U& u,CRI degree = 0);IN CO U& OP[](CO T& t);IN CO U& Get(CO T& t,CRI degree = 0);IN CO U& InitialSegmentSum(CO T& t_final,CRI degree = 0);IN U IntervalSum(CO T& t_start,CO T& t_final,CRI degree = 0);IN AbstractDifferenceSequence(FOREST& G,PREV& prev,GROUP& M,VE<U> a,int degree,int dummy);IN VO Shift(CRI degree);VO Integrate();VO Differentiate();};
TE <TY FOREST,TY PREV,TY GROUP,TY...Args> AbstractDifferenceSequence(FOREST G,PREV orev,GROUP M,Args&&... args)-> AbstractDifferenceSequence<inner_t<FOREST>,FOREST,PREV,inner_t<GROUP>,GROUP>;
TE <TY U = ll>CL DifferenceSequence:VI PU AbstractDifferenceSequence<int,LinearGraph,LinearPrev,U,AdditiveGroup<U>>{PU:IN DifferenceSequence(CRI SZ = 0,int degree = 1);IN DifferenceSequence(VE<U> a,int degree = 0);IN VO IntervalAdd(CRI t_start,CRI t_final,CO U& u,CRI degree = 0);IN DifferenceSequence(CRI SZ,VE<U>& a,int degree);};
TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractDifferenceSequence(FOREST G,PREV prev,GROUP M,int degree):AbstractDifferenceSequence(G,prev,M,VE(G.SZ(),M.Zero()),MO(degree),0){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractDifferenceSequence(FOREST& G,PREV& prev,GROUP& M,VE<U> a,int degree,int dummy):AbstractDifferenceSequence(MO(G),MO(prev),MO(M),MO(a),MO(degree)){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractDifferenceSequence(FOREST G,PREV prev,GROUP M,VE<U> a,int degree):m_G(MO(G)),m_prev(MO(prev)),m_M(MO(M)),m_a(MO(a)),m_degree(MO(degree)){ST_AS(is_invocable_r_v<int,PREV,CRI>);}TE <TY U> IN DifferenceSequence<U>::DifferenceSequence(CRI SZ,int degree):DifferenceSequence(VE<U>(SZ),MO(degree)){}TE <TY U> IN DifferenceSequence<U>::DifferenceSequence(VE<U> a,int degree):DifferenceSequence<U>(a.SZ(),a,MO(degree)){}TE <TY U> IN DifferenceSequence<U>::DifferenceSequence(CRI SZ,VE<U>& a,int degree):AbstractDifferenceSequence<int,LinearGraph,LinearPrev,U,AdditiveGroup<U>>(LinearGraph(SZ,true),LinearPrev(),AdditiveGroup<U>(),MO(a),MO(degree)){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> TE <TY...Args> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Initialise(Args&&... args){AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP> temp{m_G,m_M,MO(args)...};m_a = MO(temp.m_a);m_degree = temp.m_degree;}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CRI AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::SZ()CO NE{RE m_G.SZ();}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Set(CO T& t,CO U& u,CRI degree){Add(t,m_M.Sum(m_M.Inverse(OP[](t)),u),degree);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Add(CO T& t,CO U& u,CRI degree){if(u == m_M.Zero()){RE;}Shift(degree);auto&& i = m_G.Enumeration_inv(t);m_a[i]= m_M.Sum(MO(m_a[i]),u);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::FinalSegmentAdd(CO T& t_start,CO U& u,CRI degree){if(u == m_M.Zero()){RE;}Shift(degree + 1);U& m_a_i = m_a[m_G.Enumeration_inv(t_start)];m_a_i = m_M.Sum(MO(m_a_i),u);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::SubtreeAdd(CO T& t_start,CO VE<T>& t_outsides,CO U& u,CRI degree){FinalSegmentAdd(t_start,u,degree);CO U u_inv = m_M.Inverse(u);for(auto& t_outside:t_outsides){FinalSegmentAdd(t_outside,u_inv,degree);}}TE <TY U> IN VO DifferenceSequence<U>::IntervalAdd(CRI t_start,CRI t_final,CO U& u,CRI degree){if(t_start <= t_final){TH->SubtreeAdd(t_start,VE(t_final + 1 < TH->m_G.SZ()?1:0,t_final + 1),u,degree);}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CO U& AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::OP[](CO T& t){RE Get(t,0);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CO U& AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Get(CO T& t,CRI degree){Shift(degree);RE m_a[m_G.Enumeration_inv(t)];}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CO U& AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::InitialSegmentSum(CO T& t_final,CRI degree){RE Get(t_final,degree - 1);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN U AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::IntervalSum(CO T& t_start,CO T& t_final,CRI degree){U AN = InitialSegmentSum(t_final,degree);auto&& i_prev = m_prev(m_G.Enumeration_inv(t_start));i_prev != -1?AN = m_M.Sum(MO(AN),m_M.Inverse(m_a[i_prev])):AN;RE AN;}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Shift(CRI degree){WH(m_degree < degree){Differentiate();}WH(m_degree > degree){Integrate();}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Integrate(){m_degree--;CRI N = SZ();for(int i = 1;i < N;i++){auto&& i_prev = TH->m_prev(i);if(i_prev != -1){m_a[i]= m_M.Sum(MO(m_a[i]),m_a[i_prev]);}}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>::Differentiate(){m_degree++;for(int i = SZ()- 1;i > 0;i--){auto&& i_prev = TH->m_prev(i);if(i_prev != -1){m_a[i]= m_M.Sum(MO(m_a[i]),m_M.Inverse(m_a[i_prev]));}}}TE <CL Traits,TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN OS& OP<<(OS& os,AbstractDifferenceSequence<T,FOREST,PREV,U,GROUP>& ds){auto&& SZ = ds.SZ();for(int i = 0;i < SZ;i++){(i == 0?os:os << " ")<< ds[i];}RE os;}
#endif
