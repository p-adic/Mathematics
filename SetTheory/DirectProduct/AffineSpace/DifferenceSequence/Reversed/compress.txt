#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/DifferenceSequence/Reversed/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<int> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<int> LinearEdge::OP()(CRI t){VE<int> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back(t - 1);}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back(t + 1);}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

CL LinearPrev{PU:IN int OP()(CRI i);};IN int LinearPrev::OP()(CRI i){RE i - 1;}

TE <TY ACYCLIC_GRAPH>VE<inner_t<ACYCLIC_GRAPH>> TopologicalSort(ACYCLIC_GRAPH& G){CRI SZ = G.SZ();VE<inner_t<ACYCLIC_GRAPH>> AN(SZ);VE<bool> edged(SZ),fixed(SZ);int num = SZ - 1;for(int i = 0;i < SZ;i++){if(!fixed[i]){VE<VE<int>> dfs ={{i}};WH(!dfs.empty()){auto& e = dfs.back();if(e.empty()){dfs.pop_back();}else{CRI j = e.back();if(fixed[j]){e.pop_back();}else{auto&& t = G.Enumeration(j);if(edged[j]){fixed[j]= true;AN[num--]= t;e.pop_back();}else{edged[j]= true;auto&& edge_t = G.Edge(t);VE<int> edge_j{};for(auto& u:edge_t){auto&& k = G.Enumeration_inv(u);if(!fixed[k]){edge_j.push_back(k);}}dfs.push_back(MO(edge_j));}}}}}}RE AN;}

TE <TY DIRECTED_FOREST>tuple<VE<inner_t<DIRECTED_FOREST>>,VE<int>,VE<int>,VE<VE<int>>> TopologicalSortedForest(DIRECTED_FOREST& G){VE<inner_t<DIRECTED_FOREST>> ts = TopologicalSort(G);CRI SZ = G.SZ();VE<int> ts_inv(SZ);VE<int> prev(SZ,-1);VE<VE<int>> edge(SZ);for(int i = SZ - 1;i >= 0;i--){auto& t = ts[i];auto&& edge_t = G.Edge(t);auto& edge_i = edge[i];edge_i.reserve(edge_t.SZ());for(auto& u:edge_t){CRI j = ts_inv[G.Enumeration_inv(u)];prev[j]= i;edge_i.push_back(j);}ts_inv[G.Enumeration_inv(t)]= i;}RE{MO(ts),MO(ts_inv),MO(prev),MO(edge)};}

TE <TY UNDIRECTED_TREE> tuple<VE<inner_t<UNDIRECTED_TREE>>,VE<int>,VE<int>,VE<VE<int>>> TopologicalSortedTree(UNDIRECTED_TREE& G,CO inner_t<UNDIRECTED_TREE>& root){CRI SZ = G.SZ();US T = inner_t<UNDIRECTED_TREE>;VE<VE<T>> edge(SZ);VE<T> dfs{root};WH(!dfs.empty()){CO T t = dfs.back();dfs.pop_back();auto& edge_i = edge[G.Enumeration_inv(t)];auto&& edge_t = G.Edge(t);for(auto& u:edge_t){auto&& j = G.Enumeration_inv(u);if(edge[j].empty()){edge_i.push_back(u);dfs.push_back(u);}}}auto G_dir = G.GetGraph([&](CO T& t)-> CO VE<T>&{RE edge[G.Enumeration_inv(t)];});RE TopologicalSortedForest(G_dir);}

TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP>CL AbstractReversedDifferenceSequence{PU:FOREST m_G;PREV m_prev;GROUP m_M;VE<U> m_a;int m_degree;IN AbstractReversedDifferenceSequence(FOREST G,PREV prev,GROUP M,int degree = 1);IN AbstractReversedDifferenceSequence(FOREST G,PREV prev,GROUP M,VE<U> a,int degree = 0);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CO T& t,CO U& u,CRI degree = 0);IN VO Add(CO T& t,CO U& u,CRI degree = 0);IN VO InitialSegmentAdd(CO T& t_final,CO U& u,CRI degree = 0);IN VO IntervalAdd(CO T& t_start,CO T& t_final,CO U& u,CRI degree = 0);IN U OP[](CO T& t);IN CO U& Get(CO T& t,CRI degree = 0);IN CO U& FinalSegmentSum(CO T& t_start,CRI degree = 0);IN U SubtreeSum(CO T& t_start,CO VE<T>& t_outisde,CRI degree = 0);IN AbstractReversedDifferenceSequence(FOREST& G,PREV& prev,GROUP& M,VE<U> a,int degree,int dummy);IN VO Shift(CRI degree);IN VO Shift(CRI degree_min,CRI degree_max);VO Integrate();VO Differentiate();};TE <TY FOREST,TY PREV,TY GROUP,TY...Args> AbstractReversedDifferenceSequence(FOREST G,PREV orev,GROUP M,Args&&... args)-> AbstractReversedDifferenceSequence<inner_t<FOREST>,FOREST,PREV,inner_t<GROUP>,GROUP>;TE <TY U = ll>CL ReversedDifferenceSequence:VI PU AbstractReversedDifferenceSequence<int,LinearGraph,LinearPrev,U,AdditiveGroup<U>>{PU:IN ReversedDifferenceSequence(CRI SZ = 0,int degree = 1);IN ReversedDifferenceSequence(VE<U> a,int degree = 0);IN U IntervalSum(CRI t_start,CRI t_final,CRI degree = 0);IN ReversedDifferenceSequence(CRI SZ,VE<U>& a,int degree);};
TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractReversedDifferenceSequence(FOREST G,PREV prev,GROUP M,int degree):AbstractReversedDifferenceSequence(G,prev,M,VE(G.SZ(),M.Zero()),MO(degree),0){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractReversedDifferenceSequence(FOREST& G,PREV& prev,GROUP& M,VE<U> a,int degree,int dummy):AbstractReversedDifferenceSequence(MO(G),MO(prev),MO(M),MO(a),MO(degree)){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::AbstractReversedDifferenceSequence(FOREST G,PREV prev,GROUP M,VE<U> a,int degree):m_G(MO(G)),m_prev(MO(prev)),m_M(MO(M)),m_a(MO(a)),m_degree(MO(degree)){ST_AS(is_invocable_r_v<int,PREV,CRI>);}TE <TY U> IN ReversedDifferenceSequence<U>::ReversedDifferenceSequence(CRI SZ,int degree):ReversedDifferenceSequence(VE<U>(SZ),MO(degree)){}TE <TY U> IN ReversedDifferenceSequence<U>::ReversedDifferenceSequence(VE<U> a,int degree):ReversedDifferenceSequence<U>(a.SZ(),a,MO(degree)){}TE <TY U> IN ReversedDifferenceSequence<U>::ReversedDifferenceSequence(CRI SZ,VE<U>& a,int degree):AbstractReversedDifferenceSequence<int,LinearGraph,LinearPrev,U,AdditiveGroup<U>>(LinearGraph(SZ,true),LinearPrev(),AdditiveGroup<U>(),MO(a),MO(degree)){}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> TE <TY...Args> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Initialise(Args&&... args){AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP> temp{m_G,m_M,MO(args)...};m_a = MO(temp.m_a);m_degree = temp.m_degree;}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Set(CO T& t,CO U& u,CRI degree){Add(t,m_M.Sum(m_M.Inverse(OP[](t)),u),degree);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Add(CO T& t,CO U& u,CRI degree){if(u == m_M.Zero()){RE;}Shift(degree,degree + 1);auto&& i = m_G.Enumeration_inv(t);m_a[i]= m_M.Sum(MO(m_a[i]),u);if(m_degree > degree){auto&& i_prev = m_prev(i);if(i_prev != -1){m_a[i_prev]= m_M.Sum(MO(m_a[i_prev]),m_M.Inverse(u));}}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::InitialSegmentAdd(CO T& t_final,CO U& u,CRI degree){if(u == m_M.Zero()){RE;}Shift(degree + 1);U& m_a_i = m_a[m_G.Enumeration_inv(t_final)];m_a_i = m_M.Sum(MO(m_a_i),u);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::IntervalAdd(CO T& t_start,CO T& t_final,CO U& u,CRI degree){InitialSegmentAdd(t_final,u,degree);auto&& i_prev = m_prev(m_G.Enumeration_inv(t_start));if(i_prev != -1){InitialSegmentAdd(m_G.Enumeration(i_prev),m_M.Inverse(u),degree);}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN U AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::OP[](CO T& t){Shift(-1,0);auto&& i = m_G.Enumeration_inv(t);U AN = m_a[i];if(m_degree < 0){auto&& edge_t = m_G.Edge(t);for(auto& t_child:edge_t){AN = m_M.Sum(MO(AN),m_M.Inverse(m_a[m_G.Enumeration_inv(t_child)]));}}RE AN;}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CO U& AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Get(CO T& t,CRI degree){Shift(degree);RE m_a[m_G.Enumeration_inv(t)];}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN CO U& AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::FinalSegmentSum(CO T& t_start,CRI degree){RE Get(t_start,degree - 1);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN U AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::SubtreeSum(CO T& t_start,CO VE<T>& t_outsides,CRI degree){U AN = FinalSegmentSum(t_start,degree);for(auto& t_outside:t_outsides){AN = m_M.Sum(MO(AN),m_M.Inverse(m_a[m_G.Enumeration_inv(t_outside)]));}RE AN;}TE <TY U> IN U ReversedDifferenceSequence<U>::IntervalSum(CRI t_start,CRI t_final,CRI degree){RE t_final < t_start?TH->m_M.Zero():TH->SubtreeSum(t_start,VE(t_final + 1 < TH->m_G.SZ()?1:0,t_final + 1),degree);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Shift(CRI degree){Shift(degree,degree);}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Shift(CRI degree_min,CRI degree_max){WH(m_degree < degree_min){Differentiate();}WH(m_degree > degree_max){Integrate();}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Integrate(){m_degree--;for(int i = m_G.SZ()- 1;i > 0;i--){auto&& i_prev = m_prev(i);if(i_prev != -1){m_a[i_prev]= m_M.Sum(MO(m_a[i_prev]),m_a[i]);}}}TE <TY T,TY FOREST,TY PREV,TY U,TY GROUP> IN VO AbstractReversedDifferenceSequence<T,FOREST,PREV,U,GROUP>::Differentiate(){m_degree++;CRI SZ = m_G.SZ();for(int i = 1;i < SZ;i++){auto&& i_prev = m_prev(i);if(i_prev != -1){m_a[i_prev]= m_M.Sum(MO(m_a[i_prev]),m_M.Inverse(m_a[i]));}}}
#endif
