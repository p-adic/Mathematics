#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/Monoid/a_Body.hpp"
#else
#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY MONOID>CL MonoidBIT{PU:MONOID m_M;int m_SZ;VE<U> m_a;VE<U> m_fenwick_0;VE<U> m_fenwick_1;int m_PW;IN MonoidBIT(MONOID M,CRI SZ = 0);IN MonoidBIT(MONOID M,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);VO Set(CRI i,CO U& u);IN CRI SZ()CO NE;IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN CO U& LSBSegmentProduct(CRI j,CO bool& left = true)CO;U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);IN int Search(CO U& u);};TE <TY MONOID,TY...Args> MonoidBIT(MONOID M,Args&&... args)-> MonoidBIT<inner_t<MONOID>,MONOID>;
TE <TY U,TY MONOID> IN MonoidBIT<U,MONOID>::MonoidBIT(MONOID M,CRI SZ):MonoidBIT(M,VE<U>(SZ,M.One())){}TE <TY U,TY MONOID> IN MonoidBIT<U,MONOID>::MonoidBIT(MONOID M,VE<U> a):m_M(MO(M)),m_SZ(a.SZ()),m_a(MO(a)),m_fenwick_0(m_SZ + 1,m_M.One()),m_fenwick_1(m_fenwick_0),m_PW(1){ST_AS(is_same_v<U,inner_t<MONOID>>);for(int i = 0;i < m_SZ;i++){int j = i + 1;U& fenwick_0i = m_fenwick_0[j];fenwick_0i = m_a[i];CO int j_llim = j -(j & -j);j--;WH(j > j_llim){fenwick_0i = m_M.Product(m_fenwick_0[j],fenwick_0i);j -=(j & -j);}}for(int i = m_SZ - 1;i >= 0;i--){int j = i + 1;U& fenwick_1i = m_fenwick_1[j];fenwick_1i = m_a[i];CO int j_ulim = min(j +(j & -j),m_SZ + 1);j++;WH(j < j_ulim){fenwick_1i = m_M.Product(MO(fenwick_1i),m_fenwick_1[j]);j +=(j & -j);}}WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U,TY MONOID> TE <TY...Args> IN VO MonoidBIT<U,MONOID>::Initialise(Args&&... args){MonoidBIT<U,MONOID> temp{MO(m_M),forward<decay_t<Args>>(args)...};m_SZ = temp.m_SZ;m_a = MO(temp.m_a);m_fenwick_0 = MO(temp.m_fenwick_0);m_fenwick_1 = MO(temp.m_fenwick_1);m_PW = temp.m_PW;}TE <TY U,TY MONOID>VO MonoidBIT<U,MONOID>::Set(CRI i,CO U& u){U& ai = m_a[i]= u;int j = i + 1;int j_minus = j -(j & -j);U temp_left = m_M.Product(IntervalProduct(j_minus,i - 1),ai);U temp_right = m_M.One();WH(j <= m_SZ){m_fenwick_0[j]= m_M.Product(temp_left,temp_right);int j_next = j +(j & -j);int j_minus_next = j_next -(j_next & -j_next);if(j_minus_next != j_minus - 1){temp_left = m_M.Product(IntervalProduct(j_minus_next,j_minus - 1),temp_left);j_minus = j_minus_next;}temp_right = m_M.Product(MO(temp_right),IntervalProduct(j,j_next - 1));j = j_next;}j = i + 1;int j_plus = j +(j & -j)- 1;temp_left = m_M.One();temp_right = m_M.Product(ai,IntervalProduct(j,j_plus - 1));WH(j > 0){m_fenwick_1[j]= m_M.Product(temp_left,temp_right);int j_next = j -(j & -j);int j_plus_next = j_next +(j_next & -j_next)- 1;temp_left = m_M.Product(IntervalProduct(j_next - 1,j - 2),temp_left);j = j_next;if(j_plus != j_plus_next - 1){temp_right = m_M.Product(MO(temp_right),IntervalProduct(j_plus,j_plus_next - 1));j_plus = j_plus_next;}}RE;}TE <TY U,TY MONOID> IN CRI MonoidBIT<U,MONOID>::SZ()CO NE{RE m_SZ;}TE <TY U,TY MONOID> IN CO U& MonoidBIT<U,MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE m_a[i];}TE <TY U,TY MONOID> IN CO U& MonoidBIT<U,MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY MONOID> IN CO U& MonoidBIT<U,MONOID>::LSBSegmentProduct(CRI j,CO bool& left)CO{AS(0 < j && j <= m_SZ);RE(left?m_fenwick_0:m_fenwick_1)[j];}TE <TY U,TY MONOID>U MonoidBIT<U,MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);if(j_min > j_max){RE m_M.One();}U AN1 = m_M.One();int j = j_min;int j_next = j +(j & -j);WH(j_next <= j_max){AN1 = m_M.Product(MO(AN1),m_fenwick_1[j]);j = j_next;j_next +=(j & -j);}AN1 = m_M.Product(MO(AN1),m_a[j-1]);U AN0 = m_M.One();j = j_max;j_next = j -(j & -j);WH(j_next >= j_min){AN0 = m_M.Product(m_fenwick_0[j],AN0);j = j_next;j_next -=(j & -j);}RE m_M.Product(MO(AN1),AN0);}TE <TY U,TY MONOID> TE <TY F,SFINAE_FOR_BIT_BS> IN int MonoidBIT<U,MONOID>::Search(CO F& f){int j = 0;int PW = m_PW;U sum = m_M.One();U sum_next = sum;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){sum_next = m_M.Product(MO(sum_next),m_fenwick_0[j_next]);if(f(sum_next,j_next - 1)){sum_next = sum;}else{sum = sum_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY MONOID> IN int MonoidBIT<U,MONOID>::Search(CO U& u){RE Search([&](CO U& prod,CRI){RE !(prod < u);});}
#endif


