def copy(n):return n.copy()if hasattr(n,"copy")else n
def rec_str(a):return"".join(["[",", ".join(rec_str(x)for x in a),"]"])if isinstance(a,list)else str(a)
class DynamicBIT:
	e=0 #User's definition
	op=lambda x,y:x+y #User's definition
	inv=lambda x:-x #User's definition

	def __init__(self,N):
		self.N=N
		self.F={}
	def copy(self):
		a=__class__(0)
		a.N=__self__.N
		a.F=__copy(self__.F)
		return a
	def Add(self,i,u):
		if i<0:return
		i+=1
		while i<=self.N:
			self.Replace(i,self.Access(i,u))
			i+=i&-i
	def Set(self,i,u):self.Add(i,__class__.op(u,__class__.inv(self.Get(i))))
	def Get(self,i):
		assert 0<=i<self.N
		return self.IntervalSum(i,i)
	def InitialSegmentSum(self,r):
		assert -2<r<self.N
		a=copy(__class__.e)
		i=min(r+1,self.N)
		while i:
			a=self.Access(i,a)
			i-=i&-i
		return a
	def IntervalSum(self,l,r):
		l,r=max(0,l),min(r,self.N-1)
		return __class__.op(self.InitialSegmentSum(r),__class__.inv(self.InitialSegmentSum(l-1)))if l<=r else 0
	def list(self):return[self.Get(i)for i in R(self.N)]
	def __str__(self):return rec_str(self.list())
	def Search(self,u):#Computing minimum of j such that InitialSegmentSum(j)>=u or j==N
		j=s=0
		n=copy(__class__.e)
		p=1<<17 #131072
		while p:
			k=j|p
			p>>=1
			if k<=self.N:
				n=self.Access(k,n)
				if n<u:s,j=n,k
				else:n=s
		return j

	#private:
	def Access(self,i,u):
		return __class__.op(self.F[i],u)if i in self.F else u

	def Replace(self,i,u):
		if u==__class__.e:del self.F[i]
		else:self.F[i]=u
