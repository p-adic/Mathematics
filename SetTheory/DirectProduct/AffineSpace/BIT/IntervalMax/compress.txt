#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/IntervalMax/Debug/a_Body.hpp"
#else
TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY COMM_IDEM_MONOID>CL IdempotentMonoidBIT{PU:COMM_IDEM_MONOID m_M;int m_SZ;VE<U> m_a;VE<U> m_fenwick_0;VE<U> m_fenwick_1;int m_pw;IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ = 0);IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);VO Set(CRI i,CO U& u);VO Multiply(CRI i,CO U& u);VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN CRI SZ()CO NE;IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN CO U& LSBSegmentProduct(CRI j,CO bool& left = true)CO;U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);int Search(CO U& u);IN VO COruct();};TE <TY COMM_IDEM_MONOID> IdempotentMonoidBIT(COMM_IDEM_MONOID M)-> IdempotentMonoidBIT<inner_t<COMM_IDEM_MONOID>,COMM_IDEM_MONOID>;TE <TY U>CL IntervalMaxBIT:PU IdempotentMonoidBIT<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN IntervalMaxBIT(CO U& zero_U,Args&&... args);IN VO SetMax(CRI i,CO U& u);IN VO IntervalSetMax(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMax(CRI j,CO bool& left = true)CO;IN U IntervalMax(CRI i_start,CRI i_final);};TE <TY U>CL IntervalMinBIT:PU IdempotentMonoidBIT<U,MinSemilattice<U>>{PU:TE <TY...Args> IN IntervalMinBIT(CO U& infty_U,Args&&... args);IN VO SetMin(CRI i,CO U& u);IN VO IntervalSetMin(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMin(CRI j,CO bool& left = true)CO;IN U IntervalMin(CRI i_start,CRI i_final);};
TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_a(SZ,m_M.One()),m_fenwick_0(m_SZ + 1,m_M.One()),m_fenwick_1(m_SZ + 1,m_M.One()),m_pw(1){COruct();}TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a):m_M(MO(M)),m_SZ(a.SZ()),m_a(MO(a)),m_fenwick_0(m_SZ + 1),m_fenwick_1(m_SZ + 1),m_pw(1){COruct();for(int i = 0;i < m_SZ;i++){int j = i + 1;U& fenwick_0i = m_fenwick_0[j];fenwick_0i = m_a[i];CO int j_llim = j -(j & -j);j--;WH(j > j_llim){fenwick_0i = m_M.Product(m_fenwick_0[j],fenwick_0i);j -=(j & -j);}}for(int i = m_SZ - 1;i >= 0;i--){int j = i + 1;U& fenwick_1i = m_fenwick_1[j];fenwick_1i = m_a[i];CO int j_ulim = min(j +(j & -j),m_SZ + 1);j++;WH(j < j_ulim){fenwick_1i = m_M.Product(MO(fenwick_1i),m_fenwick_1[j]);j +=(j & -j);}}}TE <TY U> TE <TY...Args> IN IntervalMaxBIT<U>::IntervalMaxBIT(CO U& zero_U,Args&&... args):IdempotentMonoidBIT<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),forward<Args>(args)...){}TE <TY U> TE <TY...Args> IN IntervalMinBIT<U>::IntervalMinBIT(CO U& infty_U,Args&&... args):IdempotentMonoidBIT<U,MinSemilattice<U>>(MinSemilattice<U>(infty_U),forward<Args>(args)...){}TE <TY U,TY COMM_IDEM_MONOID> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::COruct(){ST_AS(is_same_v<U,inner_t<COMM_IDEM_MONOID>>);WH(m_pw < m_SZ){m_pw <<= 1;}}TE <TY U,TY COMM_IDEM_MONOID> TE <TY...Args> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Initialise(Args&&... args){IdempotentMonoidBIT<U,COMM_IDEM_MONOID> temp{m_M,forward<Args>(args)...};m_SZ = temp.m_SZ;m_a = MO(temp.m_a);m_fenwick_0 = MO(temp.m_fenwick_0);m_fenwick_1 = MO(temp.m_fenwick_1);m_pw = temp.m_pw;}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Set(CRI i,CO U& u){U& ai = m_a[i];if(u == m_M.Product(ai,u)){Multiply(i,u);}else{ai = u;int j = i + 1;int j_minus = j -(j & -j);U temp_left = m_M.Product(IntervalProduct(j_minus,i - 1),ai);U temp_right = m_M.One();WH(j <= m_SZ){m_fenwick_0[j]= m_M.Product(temp_left,temp_right);int j_next = j +(j & -j);int j_minus_next = j_next -(j_next & -j_next);if(j_minus_next != j_minus - 1){temp_left = m_M.Product(IntervalProduct(j_minus_next,j_minus - 1),temp_left);j_minus = j_minus_next;}temp_right = m_M.Product(MO(temp_right),IntervalProduct(j,j_next - 1));j = j_next;}j = i + 1;int j_plus = j +(j & -j)- 1;temp_left = m_M.One();temp_right = m_M.Product(ai,IntervalProduct(j,j_plus - 1));WH(j > 0){m_fenwick_1[j]= m_M.Product(temp_left,temp_right);int j_next = j -(j & -j);int j_plus_next = j_next +(j_next & -j_next)- 1;temp_left = m_M.Product(IntervalProduct(j_next - 1,j - 2),temp_left);j = j_next;if(j_plus != j_plus_next - 1){temp_right = m_M.Product(MO(temp_right),IntervalProduct(j_plus,j_plus_next - 1));j_plus = j_plus_next;}}}RE;}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Multiply(CRI i,CO U& u){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);int j = i + 1;WH(j <= m_SZ){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);j +=(j & -j);}j = i + 1;WH(j > 0){U& tj = m_fenwick_1[j];tj = m_M.Product(MO(tj),u);j -=(j & -j);}RE;}TE <TY U> VO IntervalMaxBIT<U>::SetMax(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U> VO IntervalMinBIT<U>::SetMin(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);for(int i = j_min - 1;i < j_max;i++){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);}CO int j_llim = j_min -(j_min & -j_min);CO int j_ulim = min(j_max +(j_max & j_max),m_SZ + 1);if(j_min <= j_max){int j = j_min;WH(j < j_ulim){if(j -(j & -j)< j_max){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j++;}j = j_max;WH(j > j_llim){if(j +(j & -j)> j_min){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j--;}}RE;}TE <TY U> VO IntervalMaxBIT<U>::IntervalSetMax(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U> VO IntervalMinBIT<U>::IntervalSetMin(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U,TY COMM_IDEM_MONOID> IN CRI IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::SZ()CO NE{RE m_SZ;}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE m_a[i];}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::LSBSegmentProduct(CRI j,CO bool& left)CO{AS(0 < j && j <= m_SZ);RE(left?m_fenwick_0:m_fenwick_1)[j];}TE <TY U> CO U& IntervalMaxBIT<U>::LSBSegmentMax(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U> CO U& IntervalMinBIT<U>::LSBSegmentMin(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U,TY COMM_IDEM_MONOID>U IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);if(j_min > j_max){RE m_M.One();}U AN1 = m_M.One();int j = j_min;int j_next = j +(j & -j);WH(j_next <= j_max){AN1 = m_M.Product(MO(AN1),m_fenwick_1[j]);j = j_next;j_next +=(j & -j);}AN1 = m_M.Product(MO(AN1),m_a[j-1]);U AN0 = m_M.One();j = j_max;j_next = j -(j & -j);WH(j_next >= j_min){AN0 = m_M.Product(MO(AN0),m_fenwick_0[j]);j = j_next;j_next -=(j & -j);}RE m_M.Product(MO(AN1),AN0);}TE <TY U> U IntervalMaxBIT<U>::IntervalMax(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U> U IntervalMinBIT<U>::IntervalMin(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U,TY COMM_IDEM_MONOID> TE <TY F,SFINAE_FOR_BIT_BS> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Search(CO F& f){int j = 0;int pw = m_pw;U product = m_M.One();U product_next = product;WH(pw > 0){int j_next = j | pw;if(j_next <= m_SZ){product_next = m_M.Product(product_next,m_fenwick_0[j_next]);if(f(product_next,j_next - 1)){product_next = product;}else{product = product_next;j = j_next;}}pw >>= 1;}RE j;}TE <TY U,TY COMM_IDEM_MONOID> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Search(CO U& u){RE Search([&](CO U& prod,CRI){RE prod == m_M.Product(prod,u);});}TE <CL Traits,TY U,TY COMM_IDEM_MONOID> IN OS& OP<<(OS& os,CO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>& bit){auto&& SZ = bit.SZ();for(int i = 0;i < SZ;i++){(i == 0?os:os << " ")<< bit[i];}RE os;}
#endif
