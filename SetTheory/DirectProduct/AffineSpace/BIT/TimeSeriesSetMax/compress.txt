#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/TimeSeriesSetMax/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY ABELIAN_GROUP>CL AbstractBIT{PU:ABELIAN_GROUP m_M;int m_SZ;VE<U> m_fenwick;int m_PW;IN AbstractBIT(ABELIAN_GROUP M,CRI SZ = 0);IN AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a);IN AbstractBIT<U,ABELIAN_GROUP>& OP=(AbstractBIT<U,ABELIAN_GROUP>&& bit);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI i,CO U& u);IN AbstractBIT<U,ABELIAN_GROUP>& OP+=(CO VE<U>& a);VO Add(CRI i,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i);IN U Get(CRI i);IN CO U& LSBSegmentSum(CRI j)CO;U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CO U& u);IN int Search(CRI i_start,CO U& u);IN VO COruct();};TE <TY ABELIAN_GROUP,TY...Args> AbstractBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL BIT:PU AbstractBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN BIT(CO Args&... args);};TE <TY U> BIT(CO VE<U>& a)-> BIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();for(int j = 1;j <= m_SZ;j++){U& fenwick_j = m_fenwick[j];int i = j - 1;fenwick_j = a[i];int i_lim = j -(j & -j);WH(i > i_lim){fenwick_j = m_M.Sum(MO(fenwick_j),m_fenwick[i]);i -=(i & -i);}}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::COruct(){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U> TE <TY...Args> IN BIT<U>::BIT(CO Args&... args):AbstractBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>& AbstractBIT<U,ABELIAN_GROUP>::OP=(AbstractBIT<U,ABELIAN_GROUP>&& bit){m_SZ = bit.m_SZ;m_fenwick = MO(bit.m_fenwick);m_PW = bit.m_PW;RE *TH;}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){*TH = AbstractBIT<U,ABELIAN_GROUP>{m_M,args...};}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>& AbstractBIT<U,ABELIAN_GROUP>::OP+=(CO VE<U>& a){AbstractBIT<U,ABELIAN_GROUP> a_copy{m_M,a};AS(m_SZ == a_copy.m_SZ);for(int j = 1;j <= m_SZ;j++){U& fenwick_j = m_fenwick[j];fenwick_j = m_M.Sum(MO(fenwick_j),a.m_fenwick[j]);}RE *TH;}TE <TY U,TY ABELIAN_GROUP>VO AbstractBIT<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){int j = i + 1;WH(j <= m_SZ){U& fenwick_j = m_fenwick[j];fenwick_j = m_M.Sum(MO(fenwick_j),u);j +=(j & -j);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractBIT<U,ABELIAN_GROUP>::SZ()CO NE{RE m_SZ;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::OP[](CRI i){AS(i < m_SZ);RE IntervalSum(i,i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::Get(CRI i){RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractBIT<U,ABELIAN_GROUP>::LSBSegmentSum(CRI j)CO{AS(0 < j && j <= m_SZ);RE m_fenwick[j];}TE <TY U,TY ABELIAN_GROUP>U AbstractBIT<U,ABELIAN_GROUP>::InitialSegmentSum(CRI i_final){U sum = m_M.Zero();int j = min(i_final + 1,m_SZ);WH(j > 0){sum = m_M.Sum(MO(sum),m_fenwick[j]);j -= j & -j;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS>int AbstractBIT<U,ABELIAN_GROUP>::Search(CO F& f){int j = 0;int PW = m_PW;U sum = m_M.Zero();U sum_next = sum;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){sum_next = m_M.Sum(MO(sum_next),m_fenwick[j_next]);if(f(sum_next,j_next - 1)){sum_next = sum;}else{sum = sum_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO F& f){CO U u_inv = m_M.Inverse(InitialSegmentSum(i_start - 1));RE max(i_start,Search([&](CO U& sum,CRI i){RE i_start <= i && f(m_M.Sum(u_inv,sum),i);}));}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CO U& u){RE Search([&](CO U& sum,CRI){RE !(sum < u);});}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO U& u){RE max(i_start,Search(m_M.Sum(InitialSegmentSum(i_start - 1),u)));}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractBIT<U,ABELIAN_GROUP>& bit){auto&& SZ = bit.SZ();for(int i = 0;i < SZ;i++){(i == 0?os:os << " ")<< bit[i];}RE os;}

TE <TY Query>VE<pair<CO Query*,int>> QuerySort(CO VE<Query>& query,CO bool& sorted){US SQuery = pair<CO Query*,int>;CO int Q = query.SZ();VE<SQuery> AN(Q);for(int q = 0;q < Q;q++){AN[q]={&(query[q]),q};}ST auto comp =[](CO SQuery& q0,CO SQuery& q1){RE *(q0.first)< *(q1.first)?true:q0.second < q1.second && *(q0.first)== *(q1.first);};if(!sorted){sort(AN.BE(),AN.EN(),comp);}RE AN;}

TE <TY R,TY U,TY Z_MODULE>CL AbstractTimeSeriesSetMaxBIT{PU:Z_MODULE m_M;int m_N;VE<U> m_a;map<R,U> m_event;IN AbstractTimeSeriesSetMaxBIT(Z_MODULE M,CO R& dummy,CRI N = 0);IN AbstractTimeSeriesSetMaxBIT(Z_MODULE M,CO R& dummy,VE<U> a,CO VE<pair<R,U>>& event ={});TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CO R& t,CO U& u);TE <TY INT,TY ABSTRACT_BIT = AbstractBIT<U,Z_MODULE>> VE<U> IntervalSum(CO VE<tuple<R,INT,INT>>& query,CO bool& sorted = false);};TE <TY R,TY Z_MODULE,TY...Args> AbstractTimeSeriesSetMaxBIT(Z_MODULE,R,Args&&...)-> AbstractTimeSeriesSetMaxBIT<R,inner_t<Z_MODULE>,Args...>;TE <TY U>CL TimeSeriesSetMaxBIT:PU AbstractTimeSeriesSetMaxBIT<ll,U,Module<ll,U>>{PU:IN TimeSeriesSetMaxBIT(CRI N = 0);TE <TY...Args> IN TimeSeriesSetMaxBIT(VE<U> a,Args&&... args);};
TE <TY U,TY Z_MODULE,TY INT,TY ABSTRACT_BIT = AbstractBIT<U,Z_MODULE>> VE<U> AbstractMaxIntervalSum(Z_MODULE M,VE<U> a,CO VE<tuple<U,INT,INT>>& query,CO bool& sorted = false);TE <TY U,TY INT,TY ABSTRACT_BIT = AbstractBIT<U,Module<int,U>>> IN VE<U> MaxIntervalSum(VE<U> a,CO VE<tuple<U,INT,INT>>& query,CO bool& sorted = false);TE <TY R,TY U,TY Z_MODULE> IN AbstractTimeSeriesSetMaxBIT<R,U,Z_MODULE>::AbstractTimeSeriesSetMaxBIT(Z_MODULE M,CO R& dummy,CRI N):m_M(MO(M)),m_N(N),m_a(N,m_M.Zero()),m_event(){}TE <TY R,TY U,TY Z_MODULE> IN AbstractTimeSeriesSetMaxBIT<R,U,Z_MODULE>::AbstractTimeSeriesSetMaxBIT(Z_MODULE M,CO R& dummy,VE<U> a,CO VE<pair<R,U>>& event):m_M(MO(M)),m_N(a.SZ()),m_a(MO(a)),m_event(){for(auto&[t,u]:event){Set(t,u);}}TE <TY U> IN TimeSeriesSetMaxBIT<U>::TimeSeriesSetMaxBIT(CRI N):AbstractTimeSeriesSetMaxBIT<ll,U,Module<ll,U>>(Module<ll,U>(),0,N){}TE <TY U> TE <TY...Args> IN TimeSeriesSetMaxBIT<U>::TimeSeriesSetMaxBIT(VE<U> a,Args&&... args):AbstractTimeSeriesSetMaxBIT<ll,U,Module<ll,U>>(Module<ll,U>(),0,MO(a),forward<Args>(args)...){}TE <TY R,TY U,TY Z_MODULE> TE <TY...Args> IN VO AbstractTimeSeriesSetMaxBIT<R,U,Z_MODULE>::Initialise(Args&&... args){decltype(*TH)temp{m_M,MO(args)...};m_N = temp.m_N;m_a = MO(temp.m_a);m_event = MO(temp.m_event);}TE <TY R,TY U,TY Z_MODULE> IN VO AbstractTimeSeriesSetMaxBIT<R,U,Z_MODULE>::Set(CO R& t,CO U& u){CO bool b = m_event.count(t)== 1;auto& m_event_t = m_event[t];m_event_t = b?max(m_event_t,u):u;}TE <TY R,TY U,TY Z_MODULE> TE <TY INT,TY ABSTRACT_BIT>VE<U> AbstractTimeSeriesSetMaxBIT<R,U,Z_MODULE>::IntervalSum(CO VE<tuple<R,INT,INT>>& query,CO bool& sorted){if(m_N == 0){AS(query.SZ()== 0);RE{};}auto query_sorted = QuerySort(query,sorted);set<pair<U,int>> a_sorted{};for(int i = 0;i < m_N;i++){a_sorted.insert({m_a[i],i});}CO U& zero = m_M.Zero();ABSTRACT_BIT a{m_M,m_a};BIT<int> b{m_N};auto IT = m_event.BE(),EN = m_event.EN();VE<U> AN(query.SZ());U temp = a_sorted.BE()->first;for(auto&[p,q]:query_sorted){auto&[t,l,r]= *p;WH(IT != EN && !(t < IT->first)){temp = max(temp,IT->second);IT++;}WH(!a_sorted.empty()){auto IT_a = a_sorted.BE();auto&[ai,i]= *IT_a;if(ai < temp){a.Set(i,zero);b.Add(i,1);a_sorted.erase(IT_a);}else{break;}}AN[q]= m_M.Sum(a.IntervalSum(l,r),m_M.ScalarProduct(b.IntervalSum(l,r),temp));}RE AN;}TE <TY U,TY Z_MODULE,TY INT,TY ABSTRACT_BIT>VE<U> AbstractMaxIntervalSum(Z_MODULE M,VE<U> a,CO VE<tuple<U,INT,INT>>& query,CO bool& sorted){AbstractTimeSeriesSetMaxBIT bit{MO(M),0,MO(a)};auto query_sorted = QuerySort(query,sorted);CO int Q = query.SZ();VE<tuple<int,int,int>> query_time(Q);for(int q = 0;q < Q;q++){auto&[u,l,r]= *(query_sorted[q].first);bit.Set(q,u);query_time[q]={q,l,r};}auto AN_sorted = bit.TE IntervalSum<int,ABSTRACT_BIT>(query_time,true);VE<U> AN(Q);for(int q = 0;q < Q;q++){AN[query_sorted[q].second]= AN_sorted[q];}RE AN;}TE <TY U,TY INT,TY ABSTRACT_BIT> IN VE<U> MaxIntervalSum(VE<U> a,CO VE<tuple<U,INT,INT>>& query,CO bool& sorted){RE AbstractMaxIntervalSum<U,Module<int,U>,INT,ABSTRACT_BIT>(Module<int,U>(),MO(a),query,sorted);}
#endif
