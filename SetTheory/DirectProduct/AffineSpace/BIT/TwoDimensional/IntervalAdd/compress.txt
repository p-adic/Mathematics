#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/TwoDimensional/IntervalAdd/a_Body.hpp"
#else
TE <TY U,TY ABELIAN_GROUP>CL AbstractTwoDimensionalBIT{PU:ABELIAN_GROUP m_M;int m_X;int m_Y;VE<VE<U>> m_fenwick;IN AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CRI X = 0,CRI Y = 0);IN AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO VE<VE<U>>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI x,CRI y,CO U& u);VO Add(CRI x,CRI y,CO U& u);IN CRI X()CO NE;IN CRI Y()CO NE;IN U Get(CRI x,CRI y);IN CO U& LSBRectangleSum(CRI i,CRI j)CO;U InitialRectangleSum(CRI x_final,CRI y_final);IN U RectangleSum(int x_start,int x_final,int y_start,int y_final);};TE <TY ABELIAN_GROUP,TY...Args> AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractTwoDimensionalBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL TwoDimensionalBIT:PU AbstractTwoDimensionalBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN TwoDimensionalBIT(CO Args&... args);};TE <TY U> TwoDimensionalBIT(CO VE<VE<U>>& a)-> TwoDimensionalBIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CRI X,CRI Y):m_M(MO(M)),m_X(X),m_Y(Y),m_fenwick(m_X + 1,VE(m_Y + 1,m_M.Zero())){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);}TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO VE<VE<U>>& a):m_M(MO(M)),m_X(a.SZ()),m_Y(m_X == 0?0:a[0].SZ()),m_fenwick(m_X + 1,VE(m_Y + 1,m_M.Zero())){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);VE temp(m_X,VE<U>(m_Y + 1,m_M.Zero()));for(int i = 1;i <= m_X;i++){CO int x = i - 1;AS(int(a[x].SZ())== m_Y);for(int j = 1;j <= m_Y;j++){int y = j - 1;CO int y_lim = j -(j & -j);m_fenwick[i][j]= a[x][y];WH(y > y_lim){m_fenwick[i][j]= m_M.Sum(MO(m_fenwick[i][j]),m_fenwick[i][y]);y -=(y & -y);}}}for(int i = 1;i <= m_X;i++){int x = i - 1;CO int x_lim = i -(i & -i);WH(x > x_lim){for(int j = 1;j <= m_Y;j++){m_fenwick[i][j]= m_M.Sum(MO(m_fenwick[i][j]),m_fenwick[x][j]);}x -=(x & -x);}}}TE <TY U> TE <TY...Args> IN TwoDimensionalBIT<U>::TwoDimensionalBIT(CO Args&... args):AbstractTwoDimensionalBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){AbstractTwoDimensionalBIT<U,ABELIAN_GROUP> temp{m_M,args...};m_X = temp.m_X;m_Y = temp.m_Y;m_fenwick = MO(temp.m_fenwick);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Set(CRI x,CRI y,CO U& u){Add(x,y,m_M.Sum(m_M.Inverse(Get(x,y)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Add(CRI x,CRI y,CO U& u){int i = x + 1;WH(i <= m_X){auto& fenwick_i = m_fenwick[i];int j = y + 1;WH(j <= m_Y){U& fenwick_ij = fenwick_i[j];fenwick_ij = m_M.Sum(MO(fenwick_ij),u);j +=(j & -j);}i +=(i & -i);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::X()CO NE{RE m_X;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Y()CO NE{RE m_Y;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Get(CRI x,CRI y){AS(0 <= x && x < m_X && 0 <= y && y < m_Y);RE RectangleSum(x,x,y,y);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::LSBRectangleSum(CRI i,CRI j)CO{AS(0 < i && i <= m_X && 0 < j && j <= m_Y);RE m_fenwick[i][j];}TE <TY U,TY ABELIAN_GROUP>U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::InitialRectangleSum(CRI x_final,CRI y_final){U sum = m_M.Zero();int i = min(x_final + 1,m_X);WH(i > 0){auto& fenwick_i = m_fenwick[i];int j = min(y_final + 1,m_Y);WH(j > 0){sum = m_M.Sum(MO(sum),fenwick_i[j]);j -=(j & -j);}i -=(i & -i);}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::RectangleSum(int x_start,int x_final,int y_start,int y_final){x_start = max(0,x_start);x_final = min(m_X - 1,x_final);y_start = max(0,y_start);y_final = min(m_Y - 1,y_final);RE x_start <= x_final && y_start <= y_final?m_M.Sum(m_M.Sum(InitialRectangleSum(x_start - 1,y_start - 1),m_M.Inverse(InitialRectangleSum(x_final,y_start - 1))),m_M.Sum(m_M.Inverse(InitialRectangleSum(x_start - 1,y_final)),InitialRectangleSum(x_final,y_final))):m_M.Zero();}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>& bit){auto&& X = bit.X();auto&& Y = bit.Y();for(int x = 0;x < X;x++){for(int y = 0;y < Y;y++){(y == 0?x == 0?os:os << "\n":os << " ")<< bit.Get(x,y);}}RE os;}

TE <TY U,TY Z_MODULE>CL AbstractTwoDimensionalIntervalAddBIT{PU:Z_MODULE m_M;AbstractTwoDimensionalBIT<U,Z_MODULE> m_bit00;AbstractTwoDimensionalBIT<U,Z_MODULE> m_bit01;AbstractTwoDimensionalBIT<U,Z_MODULE> m_bit10;AbstractTwoDimensionalBIT<U,Z_MODULE> m_bit11;IN AbstractTwoDimensionalIntervalAddBIT(Z_MODULE M,CRI X = 0,CRI Y = 0);IN AbstractTwoDimensionalIntervalAddBIT(Z_MODULE M,VE<VE<U>> a);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI x,CRI y,CO U& u);IN VO Add(CRI x,CRI y,CO U& u);VO IntervalAdd(int x_start,int x_final,int y_start,int y_final,CO U& u);IN CRI X()CO NE;IN CRI Y()CO NE;IN U Get(CRI x,CRI y);IN U InitialRectangleSum(CRI x,CRI y);IN U RectangleSum(int x_start,int x_final,int y_start,int y_final);};TE <TY Z_MODULE,TY...Args> AbstractTwoDimensionalIntervalAddBIT(Z_MODULE M,CO Args&... args)-> AbstractTwoDimensionalIntervalAddBIT<inner_t<Z_MODULE>,Z_MODULE>;TE <TY U = ll>CL TwoDimensionalIntervalAddBIT:PU AbstractTwoDimensionalIntervalAddBIT<U,Module<int,U>>{PU:TE <TY...Args> IN TwoDimensionalIntervalAddBIT(Args&&... args);};TE <TY U> TwoDimensionalIntervalAddBIT(VE<VE<U>> a)-> TwoDimensionalIntervalAddBIT<U>;
TE <TY U,TY Z_MODULE> IN AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::AbstractTwoDimensionalIntervalAddBIT(Z_MODULE M,CRI X,CRI Y):m_M(MO(M)),m_bit00(m_M,X,Y),m_bit01(m_M,X,Y),m_bit10(m_M,X,Y),m_bit11(m_M,X,Y){}TE <TY U,TY Z_MODULE> IN AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::AbstractTwoDimensionalIntervalAddBIT(Z_MODULE M,VE<VE<U>> a):m_M(MO(M)),m_bit00(m_M),m_bit01(m_M),m_bit10(m_M),m_bit11(m_M){CO int m_X = a.SZ();CO int m_Y = m_X == 0?0:a[0].SZ();auto da = a;for(int x = m_X - 1;x >= 0;x--){if(x > 0){for(int y = 0;y < m_Y;y++){a[x][y]= m_M.Sum(MO(a[x][y]),m_M.Inverse(a[x-1][y]));}da[x]= a[x];}for(int y = m_Y - 1;y > 0;y--){a[x][y]= m_M.Sum(MO(a[x][y]),m_M.Inverse(a[x][y-1]));}}m_bit00.Initialise(a);for(int x = 0;x < m_X;x++){for(int y = 1;y < m_Y;y++){a[x][y]= m_M.ScalarProduct(1 - y,MO(a[x][y]));}}m_bit01.Initialise(a);for(int x = 0;x < m_X;x++){if(x > 0){for(int y = 0;y < m_Y;y++){da[x][y]= m_M.ScalarProduct(1 - x,MO(da[x][y]));}}for(int y = m_Y - 1;y > 0;y--){da[x][y]= m_M.Sum(MO(da[x][y]),m_M.Inverse(da[x][y-1]));}}m_bit10.Initialise(da);for(int x = 0;x < m_X;x++){for(int y = 1;y < m_Y;y++){da[x][y]= m_M.ScalarProduct(1 - y,MO(da[x][y]));}}m_bit11.Initialise(da);}TE <TY U> TE <TY...Args> IN TwoDimensionalIntervalAddBIT<U>::TwoDimensionalIntervalAddBIT(Args&&... args):AbstractTwoDimensionalIntervalAddBIT<U,Module<int,U>>(Module<int,U>(),forward<Args>(args)...){}TE <TY U,TY Z_MODULE> TE <TY...Args> IN VO AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::Initialise(Args&&... args){AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE> temp{m_M,forward<Args>(args)...};m_bit00 = MO(temp.m_bit00);m_bit01 = MO(temp.m_bit01);m_bit10 = MO(temp.m_bit10);m_bit11 = MO(temp.m_bit11);}TE <TY U,TY Z_MODULE> IN VO AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::Set(CRI x,CRI y,CO U& u){Add(x,y,m_M.Sum(m_M.Inverse(Get(x,y)),u));}TE <TY U,TY Z_MODULE> IN VO AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::Add(CRI x,CRI y,CO U& u){IntervalAdd(x,x,y,y);}TE <TY U,TY Z_MODULE> IN VO AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::IntervalAdd(int x_start,int x_final,int y_start,int y_final,CO U& u){auto& m_X = X();auto& m_Y = Y();x_start = max(0,x_start);x_final = min(m_X - 1,x_final);y_start = max(0,y_start);y_final = min(m_Y - 1,y_final);if(x_start > x_final || y_start > y_final){RE;}CO U u_inv = m_M.Inverse(u);if(x_final + 1 < m_X && y_final + 1 < m_Y){m_bit00.Add(x_final + 1,y_final + 1,u);m_bit01.Add(x_final + 1,y_final + 1,m_M.ScalarProduct(y_final,u_inv));m_bit10.Add(x_final + 1,y_final + 1,m_M.ScalarProduct(x_final,u_inv));m_bit11.Add(x_final + 1,y_final + 1,m_M.ScalarProduct(x_final * y_final,u));}if(x_final + 1 < m_X){m_bit00.Add(x_final + 1,y_start,u_inv);m_bit01.Add(x_final + 1,y_start,m_M.ScalarProduct(y_start - 1,u));m_bit10.Add(x_final + 1,y_start,m_M.ScalarProduct(x_final,u));m_bit11.Add(x_final + 1,y_start,m_M.ScalarProduct(x_final *(y_start - 1),u_inv));}if(y_final + 1 < m_Y){m_bit00.Add(x_start,y_final + 1,u_inv);m_bit01.Add(x_start,y_final + 1,m_M.ScalarProduct(y_final,u));m_bit10.Add(x_start,y_final + 1,m_M.ScalarProduct(x_start - 1,u));m_bit11.Add(x_start,y_final + 1,m_M.ScalarProduct((x_start - 1)* y_final,u_inv));}m_bit00.Add(x_start,y_start,u);m_bit01.Add(x_start,y_start,m_M.ScalarProduct(y_start - 1,u_inv));m_bit10.Add(x_start,y_start,m_M.ScalarProduct(x_start - 1,u_inv));m_bit11.Add(x_start,y_start,m_M.ScalarProduct((x_start - 1)*(y_start - 1),u));RE;}TE <TY U,TY Z_MODULE> IN CRI AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::X()CO NE{RE m_bit00.X();}TE <TY U,TY Z_MODULE> IN CRI AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::Y()CO NE{RE m_bit00.Y();}TE <TY U,TY Z_MODULE> IN U AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::Get(CRI x,CRI y){AS(0 <= x && x < X()&& 0 <= y && y < Y());RE m_bit00.InitialRectangleSum(x,y);}TE <TY U,TY Z_MODULE> IN U AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::InitialRectangleSum(CRI x,CRI y){RE m_M.Sum(m_M.Sum(m_bit11.InitialRectangleSum(x,y),m_M.ScalarProduct(x * y,m_bit00.InitialRectangleSum(x,y))),m_M.Sum(m_M.ScalarProduct(x,m_bit01.InitialRectangleSum(x,y)),m_M.ScalarProduct(y,m_bit10.InitialRectangleSum(x,y))));}TE <TY U,TY Z_MODULE> IN U AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>::RectangleSum(int x_start,int x_final,int y_start,int y_final){x_start = max(0,x_start);x_final = min(X()- 1,x_final);y_start = max(0,y_start);y_final = min(Y()- 1,y_final);RE x_start <= x_final && y_start <= y_final?m_M.Sum(m_M.Sum(InitialRectangleSum(x_start - 1,y_start - 1),m_M.Inverse(InitialRectangleSum(x_final,y_start - 1))),m_M.Sum(m_M.Inverse(InitialRectangleSum(x_start - 1,y_final)),InitialRectangleSum(x_final,y_final))):m_M.Zero();}TE <CL Traits,TY U,TY Z_MODULE> IN OS& OP<<(OS& os,AbstractTwoDimensionalIntervalAddBIT<U,Z_MODULE>& bit){auto&& X = bit.X();auto&& Y = bit.Y();for(int x = 0;x < X;x++){for(int y = 0;y < Y;y++){(y == 0?x == 0?os:os << "\n":os << " ")<< bit.Get(x,y);}}RE os;}
#endif


