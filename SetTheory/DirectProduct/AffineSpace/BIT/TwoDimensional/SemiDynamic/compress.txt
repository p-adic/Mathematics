#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/TwoDimensional/SemiDynamic/a_Body.hpp"
#else
TE <TY U,TY ABELIAN_GROUP>CL AbstractTwoDimensionalSemiDynamicBIT{PU:ABELIAN_GROUP m_M;int m_X;ll m_Y;VE<Map<ll,U>> m_fenwick;IN AbstractTwoDimensionalSemiDynamicBIT(ABELIAN_GROUP M,CRI X,CRL Y);IN VO Initialise(CRI X,CRL Y);IN VO Set(CRI x,CRL y,CO U& u);VO Add(CRI x,CRL y,CO U& u);IN CRI X()CO NE;IN CRL Y()CO NE;IN U Get(CRI x,CRL y);IN CO U& LSBRectangleSum(CRI i,CRL j)CO;U InitialRectangleSum(CRI x_final,CRL y_final);IN U RectangleSum(int x_start,int x_final,ll y_start,ll y_final);IN U Access(CRI i,CRL j,U u)NE;IN VO Replace(CRI i,CRL j,U u)NE;};TE <TY ABELIAN_GROUP,TY...Args> AbstractTwoDimensionalSemiDynamicBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractTwoDimensionalSemiDynamicBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL TwoDimensionalSemiDynamicBIT:PU AbstractTwoDimensionalSemiDynamicBIT<U,AdditiveGroup<U>>{PU:IN TwoDimensionalSemiDynamicBIT(CRI x = 0,CRL Y = 0);};
TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalSemiDynamicBIT(ABELIAN_GROUP M,CRI X,CRL Y):m_M(MO(M)),m_X(X),m_Y(Y),m_fenwick(m_X + 1){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);}TE <TY U> IN TwoDimensionalSemiDynamicBIT<U>::TwoDimensionalSemiDynamicBIT(CRI X,CRL Y):AbstractTwoDimensionalSemiDynamicBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),X,Y){}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Access(CRI i,CRL j,U u)NE{if(m_fenwick[i].count(j)> 0){u = m_M.Sum(MO(u),m_fenwick[i][j]);}RE MO(u);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Replace(CRI i,CRL j,U u)NE{if(u == m_M.Zero()){m_fenwick[i].erase(j);}else{m_fenwick[i][j]= MO(u);}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Initialise(CRI X,CRL Y){m_X = X;m_Y = Y;m_fenwick = VE<Map<ll,U>>(m_X + 1);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Set(CRI x,CRL y,CO U& u){Add(x,y,m_M.Sum(m_M.Inverse(Get(x,y)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Add(CRI x,CRL y,CO U& u){int i = x + 1;WH(i <= m_X){ll j = y + 1;WH(j <= m_Y){Replace(i,j,Access(i,j,u));j +=(j & -j);}i +=(i & -i);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::X()CO NE{RE m_X;}TE <TY U,TY ABELIAN_GROUP> IN CRL AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Y()CO NE{RE m_Y;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::Get(CRI x,CRL y){AS(0 <= x && x < m_X && 0 <= y && y < m_Y);RE RectangleSum(x,x,y,y);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::LSBRectangleSum(CRI i,CRL j)CO{AS(0 < i && i <= m_X && 0 < j && j <= m_Y);RE Access(i,j,m_M.Zero());}TE <TY U,TY ABELIAN_GROUP>U AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::InitialRectangleSum(CRI x_final,CRL y_final){U sum = m_M.Zero();int i = min(x_final + 1,m_X);WH(i > 0){ll j = min(y_final + 1,m_Y);WH(j > 0){sum = Access(i,j,MO(sum));j -=(j & -j);}i -=(i & -i);}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>::RectangleSum(int x_start,int x_final,ll y_start,ll y_final){x_start = max(0,x_start);x_final = min(m_X - 1,x_final);y_start = max(0LL,y_start);y_final = min(m_Y - 1,y_final);RE x_start <= x_final && y_start <= y_final?m_M.Sum(m_M.Sum(InitialRectangleSum(x_start - 1,y_start - 1),m_M.Inverse(InitialRectangleSum(x_final,y_start - 1))),m_M.Sum(m_M.Inverse(InitialRectangleSum(x_start - 1,y_final)),InitialRectangleSum(x_final,y_final))):m_M.Zero();}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractTwoDimensionalSemiDynamicBIT<U,ABELIAN_GROUP>& bit){auto&& X = bit.X();auto&& Y = bit.Y();for(int x = 0;x < X;x++){for(ll y = 0;y < Y;y++){(y == 0?x == 0?os:os << "\n":os << " ")<< bit.Get(x,y);}}RE os;}
#endif

