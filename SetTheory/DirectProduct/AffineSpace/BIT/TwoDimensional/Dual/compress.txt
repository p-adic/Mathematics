#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/BIT/TwoDimensional/Dual/a_Body.hpp"
#else
TE <TY U,TY ABELIAN_GROUP>CL AbstractTwoDimensionalBIT{PU:ABELIAN_GROUP m_M;int m_X;int m_Y;VE<VE<U>> m_fenwick;IN AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CRI X = 0,CRI Y = 0);IN AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO VE<VE<U>>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI x,CRI y,CO U& u);VO Add(CRI x,CRI y,CO U& u);IN CRI X()CO NE;IN CRI Y()CO NE;IN U Get(CRI x,CRI y);IN CO U& LSBRectangleSum(CRI i,CRI j)CO;U InitialRectangleSum(CRI x_final,CRI y_final);IN U RectangleSum(int x_start,int x_final,int y_start,int y_final);};TE <TY ABELIAN_GROUP,TY...Args> AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractTwoDimensionalBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL TwoDimensionalBIT:PU AbstractTwoDimensionalBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN TwoDimensionalBIT(CO Args&... args);};TE <TY U> TwoDimensionalBIT(CO VE<VE<U>>& a)-> TwoDimensionalBIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CRI X,CRI Y):m_M(MO(M)),m_X(X),m_Y(Y),m_fenwick(m_X + 1,VE(m_Y + 1,m_M.Zero())){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);}TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalBIT(ABELIAN_GROUP M,CO VE<VE<U>>& a):m_M(MO(M)),m_X(a.SZ()),m_Y(m_X == 0?0:a[0].SZ()),m_fenwick(m_X + 1,VE(m_Y + 1,m_M.Zero())){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);for(int i = 1;i <= m_X;i++){auto& fenwick_i = m_fenwick[i];int x = i - 1;auto& a_x = a[x];AS(int(a_x.SZ())== m_Y);for(int j = 1;j <= m_Y;j++){int y = j - 1,y_lim = j -(j & -j);U& fenwick_ij = fenwick_i[j]= a[x][y];WH(y > y_lim){fenwick_ij = m_M.Sum(MO(fenwick_ij),fenwick_i[y]);y -=(y & -y);}}}for(int i = 1;i <= m_X;i++){auto& fenwick_i = m_fenwick[i];int x = i - 1,x_lim = i -(i & -i);WH(x > x_lim){auto& fenwick_x = m_fenwick[x];for(int j = 1;j <= m_Y;j++){U& fenwick_ij = fenwick_i[j];fenwick_ij = m_M.Sum(MO(fenwick_ij),fenwick_x[j]);}x -=(x & -x);}}}TE <TY U> TE <TY...Args> IN TwoDimensionalBIT<U>::TwoDimensionalBIT(CO Args&... args):AbstractTwoDimensionalBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){AbstractTwoDimensionalBIT<U,ABELIAN_GROUP> temp{m_M,args...};m_X = temp.m_X;m_Y = temp.m_Y;m_fenwick = MO(temp.m_fenwick);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Set(CRI x,CRI y,CO U& u){Add(x,y,m_M.Sum(m_M.Inverse(RectangleSum(x,x,y,y)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Add(CRI x,CRI y,CO U& u){int i = x + 1;WH(i <= m_X){auto& fenwick_i = m_fenwick[i];int j = y + 1;WH(j <= m_Y){U& fenwick_ij = fenwick_i[j];fenwick_ij = m_M.Sum(MO(fenwick_ij),u);j +=(j & -j);}i +=(i & -i);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::X()CO NE{RE m_X;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Y()CO NE{RE m_Y;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::Get(CRI x,CRI y){AS(0 <= x && x < m_X && 0 <= y && y < m_Y);RE RectangleSum(x,x,y,y);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::LSBRectangleSum(CRI i,CRI j)CO{AS(0 < i && i <= m_X && 0 < j && j <= m_Y);RE m_fenwick[i][j];}TE <TY U,TY ABELIAN_GROUP>U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::InitialRectangleSum(CRI x_final,CRI y_final){U sum = m_M.Zero();int i = min(x_final + 1,m_X);WH(i > 0){auto& fenwick_i = m_fenwick[i];int j = min(y_final + 1,m_Y);WH(j > 0){sum = m_M.Sum(MO(sum),fenwick_i[j]);j -= j & -j;}i -= i & -i;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>::RectangleSum(int x_start,int x_final,int y_start,int y_final){x_start = max(0,x_start);x_final = min(m_X - 1,x_final);y_start = max(0,y_start);y_final = min(m_Y - 1,y_final);RE x_start <= x_final && y_start <= y_final?m_M.Sum(m_M.Sum(InitialRectangleSum(x_start - 1,y_start - 1),m_M.Inverse(InitialRectangleSum(x_final,y_start - 1))),m_M.Sum(m_M.Inverse(InitialRectangleSum(x_start - 1,y_final)),InitialRectangleSum(x_final,y_final))):m_M.Zero();}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractTwoDimensionalBIT<U,ABELIAN_GROUP>& bit){auto&& X = bit.X();auto&& Y = bit.Y();for(int x = 0;x < X;x++){for(int y = 0;y < Y;y++){(y == 0?x == 0?os:os << "\n":os << " ")<< bit.Get(x,y);}}RE os;}

TE <TY U,TY ABELIAN_GROUP>CL AbstractTwoDimensionalDualBIT{PU:ABELIAN_GROUP m_M;AbstractTwoDimensionalBIT<U,ABELIAN_GROUP> m_fenwick;IN AbstractTwoDimensionalDualBIT(ABELIAN_GROUP M,CRI X = 0,CRI Y = 0);IN AbstractTwoDimensionalDualBIT(ABELIAN_GROUP M,VE<VE<U>> a);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI x,CRI y,CO U& u);IN VO Add(CRI x,CRI y,CO U& u);VO IntervalAdd(int x_start,int x_final,int y_start,int y_final,CO U& u);IN CRI X()CO NE;IN CRI Y()CO NE;IN U Get(CRI x,CRI y);};TE <TY ABELIAN_GROUP,TY...Args> AbstractTwoDimensionalDualBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractTwoDimensionalDualBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL TwoDimensionalDualBIT:PU AbstractTwoDimensionalDualBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN TwoDimensionalDualBIT(Args&&... args);};TE <TY U> TwoDimensionalDualBIT(VE<VE<U>> a)-> TwoDimensionalDualBIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalDualBIT(ABELIAN_GROUP M,CRI X,CRI Y):m_M(MO(M)),m_fenwick(m_M,X,Y){}TE <TY U,TY ABELIAN_GROUP> IN AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::AbstractTwoDimensionalDualBIT(ABELIAN_GROUP M,VE<VE<U>> a):m_M(MO(M)),m_fenwick(m_M){CO int m_X = a.SZ();CO int m_Y = m_X == 0?0:a[0].SZ();for(int x = m_X;x >= 0;x--){if(x > 0){for(int y = m_Y;y >= 0;y--){a[x][y]= m_M.Sum(MO(a[x][y]),m_M.Inverse(a[x-1][y]));}}for(int y = m_Y;y > 0;y--){a[x][y]= m_M.Sum(MO(a[x][y]),m_M.Inverse(a[x][y-1]));}}m_fenwick.Initialise(MO(a));}TE <TY U> TE <TY...Args> IN TwoDimensionalDualBIT<U>::TwoDimensionalDualBIT(Args&&... args):AbstractTwoDimensionalDualBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),forward<Args>(args)...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::Initialise(Args&&... args){AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP> temp{m_M,forward<Args>(args)...};m_fenwick = MO(temp.m_fenwick);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::Set(CRI x,CRI y,CO U& u){Add(x,y,m_M.Sum(m_M.Inverse(Get(x,y)),u));}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::Add(CRI x,CRI y,CO U& u){IntervalAdd(x,x,y,y);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::IntervalAdd(int x_start,int x_final,int y_start,int y_final,CO U& u){auto& m_X = X();auto& m_Y = Y();x_start = max(0,x_start);x_final = min(m_X - 1,x_final);y_start = max(0,y_start);y_final = min(m_Y - 1,y_final);if(x_start > x_final || y_start > y_final){RE;}CO U u_inv = m_M.Inverse(u);if(x_final + 1 < X && y_final + 1 < m_Y){m_fenwick.Add(x_final + 1,y_final + 1,u);}if(x_final + 1 < m_X){m_fenwick.Add(x_final + 1,y_start,u_inv);}if(y_final + 1 < m_Y){m_fenwick.Add(x_start,y_final + 1,u_inv);}m_fenwick.Add(x_start,y_start,u);RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::X()CO NE{RE m_fenwick.X();}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::Y()CO NE{RE m_fenwick.Y();}TE <TY U,TY ABELIAN_GROUP> IN U AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>::Get(CRI x,CRI y){AS(0 <= x && x < X()&& 0 <= y && y < Y());RE m_fenwick.InitialRectangleSum(x,y);}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractTwoDimensionalDualBIT<U,ABELIAN_GROUP>& bit){auto&& X = bit.X();auto&& Y = bit.Y();for(int x = 0;x < X;x++){for(int y = 0;y < Y;y++){(y == 0?x == 0?os:os << "\n":os << " ")<< bit.Get(x,y);}}RE os;}
#endif

