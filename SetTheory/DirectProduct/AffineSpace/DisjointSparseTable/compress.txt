#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/DisjointSparseTable/a_Body.hpp"
#else
TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

TE <TY U,TY MONOID>CL AbstractDisjointSparseTable{PU:MONOID m_M;int m_SZ;VE<VE<U>> m_prod;IN AbstractDisjointSparseTable(MONOID M,CRI SZ = 0);IN AbstractDisjointSparseTable(MONOID M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN U IntervalProduct(CRI i_start,CRI i_final);};TE <TY MONOID,TY...Args> AbstractDisjointSparseTable(MONOID M,CO Args&... args)-> AbstractDisjointSparseTable<inner_t<MONOID>,MONOID>;TE <TY U>CL DisjointSparseTable:PU AbstractDisjointSparseTable<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN DisjointSparseTable(CO U& zero_U,CO Args&... args);IN U IntervalMax(CRI i_start,CRI i_final);};
TE <TY U,TY MONOID> IN AbstractDisjointSparseTable<U,MONOID>::AbstractDisjointSparseTable(MONOID M,CRI SZ):AbstractDisjointSparseTable(M,VE<U>(SZ,M.One())){}TE <TY U,TY MONOID> IN AbstractDisjointSparseTable<U,MONOID>::AbstractDisjointSparseTable(MONOID M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_prod(){ST_AS(is_same_v<U,inner_t<MONOID>>);int digit = 1;WH(m_SZ >= 1 << digit){++digit;}m_prod.resize(digit,VE(m_SZ,m_M.One()));for(int v = 0;v < digit;v++){auto& m_prod_v = m_prod[v];int p = 1 << v,p2 = p << 1;for(int j = p;j <= m_SZ;j += p2){CO int i_ulim = min(j + p,m_SZ);if(j < m_SZ){m_prod_v[j]= a[j];for(int i = j + 1;i < i_ulim;i++){m_prod_v[i]= m_M.Product(m_prod_v[i-1],a[i]);}}CO int i_min = j - p;m_prod_v[j-1]= a[j-1];for(int i = j - 2;i >= i_min;i--){m_prod_v[i]= m_M.Product(a[i],m_prod_v[i+1]);}}}}TE <TY U> TE <TY...Args> IN DisjointSparseTable<U>::DisjointSparseTable(CO U& zero_U,CO Args&... args):AbstractDisjointSparseTable<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),args...){}TE <TY U,TY MONOID> TE <TY...Args> IN VO AbstractDisjointSparseTable<U,MONOID>::Initialise(CO Args&... args){*TH = AbstractDisjointSparseTable(MO(m_M),args...);}TE <TY U,TY MONOID> IN CO U& AbstractDisjointSparseTable<U,MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE IntervalProduct(i,i);}TE <TY U,TY MONOID> IN CO U& AbstractDisjointSparseTable<U,MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY MONOID> IN U AbstractDisjointSparseTable<U,MONOID>::IntervalProduct(CRI i_start,CRI i_final){AS(0 <= i_start && i_start <= i_final && i_final < m_SZ);CO int v = 31 - __builtin_clz(i_start ^(i_final + 1));RE i_final <((i_final + 1)>> v)<< v?m_prod[v][i_start]:m_M.Product(m_prod[v][i_start],m_prod[v][i_final]);}TE <TY U> IN U DisjointSparseTable<U>::IntervalMax(CRI i_start,CRI i_final) {RE TH->IntervalProduct(i_start,i_final);}
#endif
