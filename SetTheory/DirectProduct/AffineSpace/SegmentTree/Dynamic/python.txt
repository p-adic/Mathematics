def copy(n):return n.copy()if hasattr(n,"copy")else n
def rec_str(a):return"".join(["[",", ".join(rec_str(x)for x in a),"]"])if isinstance(a,list)else str(a)
class DynamicSegmentTree:
	e=1 #User's definition
	op=lambda x,y:x*y #User's definition

	def __init__(self,N):
		self.N=N
		self.p=1
		while self.N>self.p:self.p<<=1
		self.T={}

	def copy(self):
		a=__class__(0)
		a.N=self.N
		a.p=self.p
		a.T=copy(self.T)
		return a

	def Set(self,i,u):
		assert 0<=i<self.N
		j=self.p|i
		self.Replace(j,u)
		j>>=1
		while j:
			self.Replace(j,__class__.op(self.Access(j<<1),self.Access((j<<1)|1)))
			j>>=1

	def Get(self,i):
		assert 0<=i<self.N
		return self.IntervalProduct(i,i)

	def IntervalProduct(self,l,r): #[l,r]
		l,r=max(0,l),min(r,self.N-1)
		assert l-1<=r
		l|=self.p
		r+=self.p+1
		a,b=copy(__class__.e),copy(__class__.e)
		while l<r:
			if l&1:a,l=__class__.op(a,self.Access(l)),l+1
			if r&1:b,r=__class__.op(self.Access(r-1),b),r-1
			l,r=l>>1,r>>1
		return __class__.op(a,b)

	#private:
	def Access(self,i):
		return self.T[i]if i in self.T else __class__.e

	def Replace(self,i,u):
		if u==__class__.e:del self.T[i]
		else:self.T[i]=u
