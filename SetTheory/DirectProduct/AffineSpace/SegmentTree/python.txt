#零初期化
p=1
while N>p:p*=2
T=[0]*p*2
#配列による初期化
for i in R(0,N):T[p|i]=A[i]
for j in R(p-1,0,-1):T[j]=T[j*2]+T[j*2+1]

#一点更新S
#区間和G
def S(i,u):
	j=p|i
	T[j],j=u,j>>1
	while j:T[j],j=T[j*2]+T[j*2+1],j>>1
def G(l,r): #l,rは始端,終端
	l|=p
	r+=p+1
	a=b=0
	while l<r:
		if l&1:a,l=a+T[l],l+1
		if r&1:b,r=T[r-1]+b,r-1
		l,r=l>>1,r>>1
	return a+b


#minバージョン
p=1
while N>p:p*=2
L=9**9 #387420489>10^8
#L=99*9 #913517247483640899>10^17
T=[L]*p*2
for i in R(0,N):T[p|i]=A[i]
for j in R(p-1,0,-1):T[j]=min(T[j*2],T[j*2+1])
def S(i,u):
	j=p|i
	T[j],j=u,j>>1
	while j:T[j],j=min(T[j*2],T[j*2+1]),j>>1
def G(l,r):
	l|=p
	r+=p+1
	a=b=L
	while l<r:
		if l&1:a,l=min(a,T[l]),l+1
		if r&1:b,r=min(T[r-1],b),r-1
		l,r=l>>1,r>>1
	return min(a,b)


def copy(n):return n.copy()if hasattr(n,"copy")else n
def rec_str(a):return"".join(["[",", ".join(rec_str(x)for x in a),"]"])if isinstance(a,list)else str(a)
class SegmentTree:
	e=1 #User's definition
	op=lambda x,y:x*y #User's definition

	def __init__(self,x):
		b=isinstance(x,int)
		if b:self.N=x
		else:self.N=len(x)
		self.p=1
		while self.N>self.p:self.p<<=1
		if b:self.T=[copy(__class__.e)for i in R(self.p<<1)]
		else:
			self.T=[__class__.e]*(self.p<<1)
			for i in R(0,self.N):self.T[self.p|i]=copy(x[i])
			for j in R(self.p-1,0,-1):self.T[j]=__class__.op(self.T[j<<1],self.T[(j<<1)|1])

	def copy(self):
		a=__class__([])
		a.N=self.N
		a.p=self.p
		a.T=copy(self.T)
		return a

	def Set(self,i,u):
		assert 0<=i<self.N
		j=self.p|i
		self.T[j],j=u,j>>1
		while j:self.T[j],j=__class__.op(self.T[j<<1],self.T[(j<<1)|1]),j>>1

	def Get(self,i):
		assert 0<=i<self.N
		return self.IntervalProduct(i,i)

	def IntervalProduct(self,l,r): #l,rは始端,終端
		l,r=max(0,l),min(r,self.N-1)
		assert l-1<=r
		l|=self.p
		r+=self.p+1
		a,b=copy(__class__.e),copy(__class__.e)
		while l<r:
			if l&1:a,l=__class__.op(a,self.T[l]),l+1
			if r&1:b,r=__class__.op(self.T[r-1],b),r-1
			l,r=l>>1,r>>1
		return __class__.op(a,b)


