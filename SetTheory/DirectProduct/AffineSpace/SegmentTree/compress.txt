#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SegmentTree/Debug/a_Body.hpp"
#else
TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

TE <TY U,TY MONOID>CL AbstractSegmentTree{PU:MONOID m_M;int m_SZ;int m_pw;VE<U> m_a;IN AbstractSegmentTree(MONOID M,CRI SZ = 0);IN AbstractSegmentTree(MONOID M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);VO Set(CRI i,CO U& u);IN CRI SZ()CO NE;IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;U IntervalProduct(CRI i_start,CRI i_final);};TE <TY MONOID,TY...Args> AbstractSegmentTree(MONOID M,CO Args&... args)-> AbstractSegmentTree<inner_t<MONOID>,MONOID>;TE <TY U>CL SegmentTree:PU AbstractSegmentTree<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN SegmentTree(CO U& zero_U,CO Args&... args);IN U IntervalMax(CRI i_start,CRI i_final);};
TE <TY U,TY MONOID> IN AbstractSegmentTree<U,MONOID>::AbstractSegmentTree(MONOID M,CRI SZ):AbstractSegmentTree(M,VE<U>(SZ,M.One())){}TE <TY U,TY MONOID> IN AbstractSegmentTree<U,MONOID>::AbstractSegmentTree(MONOID M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_pw(1),m_a(){ST_AS(is_same_v<U,inner_t<MONOID>>);WH(m_SZ > m_pw){m_pw <<= 1;}m_a.resize(m_pw << 1,m_M.One());for(int i = 0;i < m_SZ;i++){m_a[m_pw | i]= a[i];}for(int j = m_pw - 1;j >= 1;j--){int j2 = j << 1;m_a[j]= m_M.Product(m_a[j2],m_a[j2 | 1]);}}TE <TY U> TE <TY...Args> IN SegmentTree<U>::SegmentTree(CO U& zero_U,CO Args&... args):AbstractSegmentTree<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),args...){}TE <TY U,TY MONOID> TE <TY...Args> IN VO AbstractSegmentTree<U,MONOID>::Initialise(CO Args&... args){*TH = AbstractSegmentTree(MO(m_M),args...);}TE <TY U,TY MONOID>VO AbstractSegmentTree<U,MONOID>::Set(CRI i,CO U& u){AS(0 <= i && i < m_SZ);int j = m_pw | i;m_a[j]= u;WH((j >>= 1)>= 1){int j2 = j << 1;m_a[j]= m_M.Product(m_a[j2],m_a[j2 | 1]);}RE;}TE <TY U,TY MONOID> IN CRI AbstractSegmentTree<U,MONOID>::SZ()CO NE{RE m_SZ;}TE <TY U,TY MONOID> IN CO U& AbstractSegmentTree<U,MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE m_a[m_pw | i];}TE <TY U,TY MONOID> IN CO U& AbstractSegmentTree<U,MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY MONOID>U AbstractSegmentTree<U,MONOID>::IntervalProduct(CRI i_start,CRI i_final){U AN0 = m_M.One();int j_min = max(0,i_start);int j_ulim = min(i_final,m_SZ - 1);if(j_min > j_ulim){RE AN0;}j_min |= m_pw;++(j_ulim |= m_pw);U AN1 = AN0;WH(j_min < j_ulim){(j_min & 1)== 1?AN0 = m_M.Product(MO(AN0),m_a[j_min++]):AN0;(j_ulim & 1)== 1?AN1 = m_M.Product(m_a[--j_ulim],AN1):AN1;j_min >>= 1;j_ulim >>= 1;}RE m_M.Product(MO(AN0),AN1);}TE <TY U> IN U SegmentTree<U>::IntervalMax(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}
#endif
