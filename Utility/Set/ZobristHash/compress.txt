#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/Set/ZobristHash/a_Body.hpp"
#else
TE <TY T>CL ZobristHashBody{PU:ull m_r;ull m_s;IN ZobristHashBody();IN ZobristHashBody(CO ull& r,CO ull& s);ull Encode(CO Set<T>& S);TE <TE <TY...> TY V> IN ull Encode(CO V<T>& S,CO bool& non_overlapping = false);IN ull SymmetricDifference(ull code0,CO ull& code1);IN ull Add(Set<T>& S,ull code,CO T& t);IN ull Erase(Set<T>& S,ull code,CO T& t);IN ull AddErase(ull code,CO T& t);TE <TE <TY...> TY V> ull OverlappingEncode(CO V<T>& S);TE <TE <TY...> TY V> ull NonOverlappingEncode(CO V<T>& S);VI ull Hash(CO T& t)= 0;};CL ZobristHash:PU ZobristHashBody<ull>{PU:TE <TY...Args> IN ZobristHash(Args&&... args);IN ull Hash(CO ull& t);};TE <TY T>CL MemorisationZobristHash:PU ZobristHashBody<T>{PU:Map<T,ull> m_f;TE <TY...Args> IN MemorisationZobristHash(Args&&... args);IN ull Hash(CO T& t);};TE <TY T,int enum_T_inv(CO T&)>CL EnumerationZobristHash:PU ZobristHashBody<T>{PU:TE <TY...Args> IN EnumerationZobristHash(Args&&... args);IN ull Hash(CO T& t);};
TE <TY T> IN ZobristHashBody<T>::ZobristHashBody():ZobristHashBody(GetRand(1,1LL << 60),GetRand(1,1LL << 60)){}TE <TY T> IN ZobristHashBody<T>::ZobristHashBody(CO ull& r,CO ull& s):m_r(r),m_s(s){}TE <TY...Args> IN ZobristHash::ZobristHash(Args&&... args):ZobristHashBody<ull>(args...){}TE <TY T> TE <TY...Args> IN MemorisationZobristHash<T>::MemorisationZobristHash(Args&&... args):ZobristHashBody<T>(args...){}TE <TY T,int enum_T_inv(CO T&)> TE <TY...Args> IN EnumerationZobristHash<T,enum_T_inv>::EnumerationZobristHash(Args&&... args):ZobristHashBody<T>(args...){}TE <TY T> ull ZobristHashBody<T>::Encode(CO Set<T>& S){ull AN = 0;for(auto& t:S){AN ^= Hash(t);}RE AN;}TE <TY T> TE <TE <TY...> TY V> IN ull ZobristHashBody<T>::Encode(CO V<T>& S,CO bool& non_overlapping){RE non_overlapping?NonOverlappingEncode(S):OverlappingEncode(S);}TE <TY T> TE <TE <TY...> TY V> ull ZobristHashBody<T>::OverlappingEncode(CO V<T>& S){Set<T> S_set{};for(auto& t:S){S_set.insert(t);}RE Encode(S_set);}TE <TY T> TE <TE <TY...> TY V> ull ZobristHashBody<T>::NonOverlappingEncode(CO V<T>& S){ull AN = 0;for(auto& t:S){AN ^= Hash(t);}RE AN;}TE <TY T> IN ull ZobristHashBody<T>::SymmetricDifference(ull code0,CO ull& code1){RE MO(code0 ^= code1);}TE <TY T> IN ull ZobristHashBody<T>::Add(Set<T>& S,ull code,CO T& t){RE MO(S.count(t)== 0?(S.insert(t),code ^= Hash(t)):code);}TE <TY T> IN ull ZobristHashBody<T>::Erase(Set<T>& S,ull code,CO T& t){RE MO(S.count(t)== 0?code:(S.erase(t),code ^= Hash(t)));}TE <TY T> IN ull ZobristHashBody<T>::AddErase(ull code,CO T& t){RE MO(code ^= Hash(t));}IN ull ZobristHash::Hash(CO ull& t){RE(t + 1)* TH->m_r + TH->m_s;}TE <TY T> IN ull MemorisationZobristHash<T>::Hash(CO T& t){if(m_f.count(t)== 0){CO ull SZ = m_f.SZ()+ 1;RE m_f[t]= SZ * TH->m_r + TH->m_s;}RE m_f[t];}TE <TY T,int enum_T_inv(CO T&)> IN ull EnumerationZobristHash<T,enum_T_inv>::Hash(CO T& t){RE(enum_T_inv(t)+ 1)* *TH->m_r + TH->m_s;}

#define DF_OF_HASH_FOR_SET(SET)TE <TY T> IN size_t hash<SET<T>>::OP()(CO SET<T>& S)CO{ST CO ull r = GetRand(1,1LL << 60),s = GetRand(1,1LL << 60);ST CO hash<T> h{};size_t AN{};for(auto& t:S){AN ^=(h(t)+ 1)* r + s;}RE AN;}
TE <TY T> DC_OF_HASH(unordered_set<T>);TE <TY T> DC_OF_HASH(set<T>);
DF_OF_HASH_FOR_SET(unordered_set);DF_OF_HASH_FOR_SET(set);
#endif

