#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/SuffixArray/IntervalSort/a_Body.hpp"
#else
TE <TY STR>VE<int> ManberMyers(CO STR& s){CO int N = s.SZ();US CHAR = decldecay_t(s[0]);map<CHAR,VE<int>> bucket{};for(int i = 0;i < N;i++){bucket[s[i]].push_back(i);}VE<int> order(N);int order_lb = 0;VE<VE<int>> interval{};for(auto&[c,v]:bucket){if(order_lb > 0){for(auto& i:v){order[i]= order_lb;}}CO int SZ = v.SZ();order_lb += SZ;if(SZ > 1){interval.push_back(MO(v));}}VE<VE<int>> ninterval{};int L = 1;WH(true){WH(!interval.empty()){bucket.clear();for(auto& i:interval.back()){CO int j = i + L;bucket[j < N?order[j]:-1].push_back(i);}interval.pop_back();int order_lb_diff = 0;for(auto&[c,v]:bucket){if(order_lb_diff > 0){for(auto& i:v){order[i]+= order_lb_diff;}}CO int SZ = v.SZ();order_lb_diff += SZ;if(SZ > 1){ninterval.push_back(MO(v));}}}if(ninterval.empty()){break;}swap(interval,ninterval);ninterval.clear();L <<= 1;}VE<int> AN(N);for(int i = 0;i < N;i++){AN[order[i]]= i;}RE AN;}

TE <TY STR>CL LexicographicIntervalSort{PU:CO STR* m_p_S;int m_N;VE<int> m_sa;VE<ll> m_cs;IN LexicographicIntervalSort(CO STR& S);IN pair<int,int> Get(ll k)CO;pair<int,int> OP[](ll k)CO;IN ll CountIntervals(CRI l,CO int r,CRI shift)CO;};
TE <TY STR> IN LexicographicIntervalSort<STR>::LexicographicIntervalSort(CO STR& S):m_p_S(&S),m_N(S.SZ()),m_sa(ManberMyers(S)),m_cs(m_N + 1){AS(m_N > 0);for(int i = 0;i < m_N;i++){m_cs[i+1]= m_cs[i]+(m_N - m_sa[i]);}}TE <TY STR> IN pair<int,int> LexicographicIntervalSort<STR>::Get(ll k)CO{RE OP[](MO(k));}TE <TY STR> pair<int,int> LexicographicIntervalSort<STR>::OP[](ll k)CO{AS(k <= m_N * ll(m_N + 1)/ 2);CO STR& S = *m_p_S;int L = 0,R = m_N,shift = -1;WH(k > 0){shift++;int l = L - 1,r = R - 1;WH(l + 1 < r){CO int m =(l + r)>> 1;(CountIntervals(L,m,shift)>= k?r:l)= m;}auto& c = S.at(m_sa[r]+ shift);l = r;WH(l < R - 1){CO int m =(l + R)>> 1,i = m_sa[m]+ shift;(i < m_N && S[i]== c?l:R)= m;}R = l + 1;l = L - 1;WH(l + 1 < r){CO int m =(l + r)>> 1,i = m_sa[m]+ shift;(i < m_N && S[i]== c?r:l)= m;}k -= CountIntervals(L,r - 1,shift);AS(k >= 0);L = r;k -= R - L;}VE<int> v(R - L);for(int i = L;i < R;i++){v[i - L]= m_sa[i];}sort(v.BE(),v.EN());L = v[R - L - 1 + k];R = L + shift;RE{L,R};}TE <TY STR> IN ll LexicographicIntervalSort<STR>::CountIntervals(CRI l,CO int r,CRI shift)CO{AS(0 <= l && l - 1 <= r && r < m_N);RE(m_cs[r + 1]- m_cs[l])- ll(r - l + 1)* shift;}
#endif

