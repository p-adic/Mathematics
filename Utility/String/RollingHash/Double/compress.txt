#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/RollingHash/Double/a_Body.hpp"
#else
TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_pw;IN RollingHash();IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;MODINT r_pw(INT i)CO NE;TE <TY STR> IN CODE Encode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed = false);TE <TY CHAR> IN CODE Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR> IN CODE swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO;TE <TY CHAR> IN CODE PopFront(CODE code,CO CHAR& c_prev)CO;TE <TY CHAR> IN CODE PopBack(CODE code,CO CHAR& c_prev)CO;TE <TY STR> IN int CountContain(CO STR& s,CO CODE& code,CO bool& reversed = false);ST IN CODE Concatenate(CODE code0,CO CODE& code1);ST IN CODE Fold(CODE code,INT n);MODINT GetRand();VO CheckSize(CO INT& SZ);VI MODINT Twist(CRL c)CO;};
TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash():RollingHash(GetRand()){}TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_pw{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT,TY CODE>MODINT RollingHash<MODINT,INT,CODE>::r_pw(INT i)CO NE{if(i < m_SZ){RE m_r_pw[i];}MODINT AN = m_r_pw[m_SZ - 1];MODINT pw = m_r;i -= m_SZ - 1;WH(i > 0){(i & 1)== 0?AN:AN *= pw;pw *= pw;i >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN CODE RollingHash<MODINT,INT,CODE>::Encode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}RE{AN,m_r_pw[SZ],SZ};}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::CumulativeEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= Concatenate(AN[i],{Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i],m_r,1});}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::PointwiseEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={Twist(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed){CO int SZ = s.SZ();VE<CODE> AN{};if(le <= SZ){CheckSize(le + 1);AN.resize(SZ - le + 1,{MODINT{},m_r_pw[le],1});for(int i = 0;i < le;i++){get<0>(AN[0])+= Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}CO int SZ_shifted = SZ - le;for(int i = 1;i <= SZ_shifted;i++){get<0>(AN[i])=(get<0>(AN[i-1])- e(s[reversed?SZ - i:i - 1]))* m_r_inv + e(s[reversed?SZ - i - le:i - 1 + le])* m_r_pw[le-1];}}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO{auto&[h,p,s]= code;AS(i < s);h +=(Twist(c_next)-= Twist(c_prev))*= r_pw(MO(i));RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO{RE Replace(Replace(MO(code),MO(i),c_i,c_j),MO(j),c_j,c_i);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopFront(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);h -= Twist(c_prev)* r_pw(s);r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopBack(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);(h -= Twist(c_prev)* m_r_pw[0])*= m_r_inv;r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN int RollingHash<MODINT,INT,CODE>::CountContain(CO STR& s,CO CODE& code,CO bool& reversed){CO int SZ0 = s.SZ();CheckSize(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSize(SZ1);CO MODINT& r_pw = m_r_pw[SZ1 - 1];int AN = 0;MODINT temp = 0;for(int i = 0;i < SZ0;i++){(i < SZ1?temp += Twist(s[reversed?SZ0 - 1 - i:i])* m_r_pw[i]:((temp -= Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= Twist(s[reversed?SZ0 - 1 - i:i])* r_pw)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Concatenate(CODE code0,CO CODE& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Fold(CODE code,INT n){AS(n >= 0);CODE AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(MO(AN),code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::GetRand(){RE::GetRand(((MODINT{}- 1)/ 11).RP(),(MODINT{}- 1).RP());}TE <TY MODINT,TY INT,TY CODE> VO RollingHash<MODINT,INT,CODE>::CheckSize(CO INT& SZ){WH(m_SZ < SZ){m_r_pw.push_back(m_r_pw[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::Twist(CRL c)CO{RE MODINT(c);}

TE <TY RH0,TY RH1,TY CODE = Pair<decltype(declval<RH0>().Encode("")),decltype(declval<RH1>().Encode(""))>,TY VCODE = Pair<decltype(declval<RH0>().CumulativeEncode("")),decltype(declval<RH1>().CumulativeEncode(""))>>CL RollingHashPair{PU:RH0 m_rh0;RH1 m_rh1;IN RollingHashPair();IN RH0& OP[](CO TupleAccessIndex<0>& i)NE;IN RH1& OP[](CO TupleAccessIndex<1>& i)NE;TE <TY STR> IN CODE Encode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VCODE CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VCODE PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VCODE FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed = false);TE <TY CHAR,TY INT> IN CODE Replace(CODE code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR,TY INT> IN CODE swap(CODE code,CO INT& i,CO INT& j,CO CHAR& c_i,CO CHAR& c_j)CO;TE <TY CHAR> IN CODE PopFront(CODE code,CO CHAR& c_prev)CO;TE <TY CHAR> IN CODE PopBack(CODE code,CO CHAR& c_prev)CO;TE <TY STR> IN int CountContain(CO STR& s,CO CODE& code,CO bool& reversed = false);ST IN CODE Concatenate(CODE code0,CO CODE& code1);TE <TY INT> ST IN CODE Fold(CODE code,CO INT& n);};
TE <uint M0,uint M1,TY INT = int>US DoubleRollingHash = RollingHashPair<RollingHash<Mod<M0>,INT>,RollingHash<Mod<M1>,INT>>;TE <uint M0,uint M1,uint M2,TY INT = int>US TripleRollingHash = RollingHashPair<DoubleRollingHash<M0,M1,INT>,RollingHash<Mod<M2>,INT>>;
TE <TY RH0,TY RH1,TY CODE,TY VCODE> IN RollingHashPair<RH0,RH1,CODE,VCODE>::RollingHashPair():m_rh0(),m_rh1(){}TE <TY RH0,TY RH1,TY CODE,TY VCODE> IN RH0& RollingHashPair<RH0,RH1,CODE,VCODE>::OP[](CO TupleAccessIndex<0>& i)NE{RE m_rh0;}TE <TY RH0,TY RH1,TY CODE,TY VCODE> IN RH1& RollingHashPair<RH0,RH1,CODE,VCODE>::OP[](CO TupleAccessIndex<1>& i)NE{RE m_rh1;}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY STR> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::Encode(CO STR& s,CO bool& reversed){RE{m_rh0.Encode(s,reversed),m_rh1.Encode(s,reversed)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY STR> IN VCODE RollingHashPair<RH0,RH1,CODE,VCODE>::CumulativeEncode(CO STR& s,CO bool& reversed){RE{m_rh0.CumulativeEncode(s,reversed),m_rh1.CumulativeEncode(s,reversed)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY STR> IN VCODE RollingHashPair<RH0,RH1,CODE,VCODE>::PointwiseEncode(CO STR& s,CO bool& reversed){RE{m_rh0.PointwiseEncode(s,reversed),m_rh1.PointwiseEncode(s,reversed)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY STR> IN VCODE RollingHashPair<RH0,RH1,CODE,VCODE>::FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed){RE{m_rh0.FixedLengthEncode(s,reversed),m_rh1.FixedLengthEncode(s,reversed)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY CHAR,TY INT> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::Replace(CODE code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO{RE{m_rh0.Replace(MO(code[O]),i,c_prev,c_next),m_rh1.Replace(MO(code[I]),i,c_prev,c_next)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY CHAR,TY INT> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::swap(CODE code,CO INT& i,CO INT& j,CO CHAR& c_i,CO CHAR& c_j)CO{RE Replace(Replace(MO(code),i,c_i,c_j),j,c_j,c_i);}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY CHAR> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::PopFront(CODE code,CO CHAR& c_prev)CO{RE{m_rh0.PopFront(MO(code[O]),c_prev),m_rh1.PopFront(MO(code[I]),c_prev)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY CHAR> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::PopBack(CODE code,CO CHAR& c_prev)CO{RE{m_rh0.PopBack(MO(code[O]),c_prev),m_rh1.PopBack(MO(code[I]),c_prev)};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY STR> IN int RollingHashPair<RH0,RH1,CODE,VCODE>::CountContain(CO STR& s,CO CODE& code,CO bool& reversed){CO int SZ0 = s.SZ();auto n = Pair{get<0>(code[O]),get<0>(code[I])};auto& SZ1 = get<2>(code[O]);AS(SZ1 == get<2>(code[I]));if(SZ1 == 0){RE 1;}auto r_pw = Pair{m_rh0.r_pw(SZ1 - 1),m_rh1.r_pw(SZ1 - 1)};int AN = 0;decltype(r_pw)temp{};for(int i = 0;i < SZ0;i++){(i < SZ1?temp += Pair{m_rh0.Twist(s[reversed?SZ0 - 1 - i:i])* m_rh0.r_pw(i),m_rh1.Twist(s[reversed?SZ0 - 1 - i:i])* m_rh1.r_pw(i)}:((temp -= Pair{m_rh0.Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]),m_rh1.Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1])})*= Pair{m_rh0.r_inv(),m_rh1.r_inv()})+= Pair{m_rh0.Twist(s[reversed?SZ0 - 1 - i:i]),m_rh1.Twist(s[reversed?SZ0 - 1 - i:i])}* r_pw)== n?++AN:AN;}RE AN;}TE <TY RH0,TY RH1,TY CODE,TY VCODE> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::Concatenate(CODE code0,CO CODE& code1){RE{RH0::Concatenate(MO(code0[O]),code1[O]),RH1::Concatenate(MO(code0[I]),code1[I])};}TE <TY RH0,TY RH1,TY CODE,TY VCODE> TE <TY INT> IN CODE RollingHashPair<RH0,RH1,CODE,VCODE>::Fold(CODE code,CO INT& n){RE{RH0::Fold(MO(code[O]),n),RH1::Fold(MO(code[I]),n)};}
#endif

