#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/RollingHash/Shift/a_Body.hpp"
#else
IN int GCD(){RE 0;}TE <TY INT1,TY...INT2>INT1 GCD(INT1 b_0,INT2... args){b_0 < 0?b_0 = -b_0:b_0;INT1 b_1 = GCD(MO(args)...);WH(b_1 != 0){swap(b_0 %= b_1,b_1);}RE MO(b_0);}

TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_pw;IN RollingHash();IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;MODINT r_pw(INT i)CO NE;TE <TY STR> IN CODE Encode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed = false);TE <TY CHAR> IN CODE Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR> IN CODE swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO;TE <TY CHAR> IN CODE PopFront(CODE code,CO CHAR& c_prev)CO;TE <TY CHAR> IN CODE PopBack(CODE code,CO CHAR& c_prev)CO;TE <TY STR> IN int CountContain(CO STR& s,CO CODE& code,CO bool& reversed = false);ST IN CODE Concatenate(CODE code0,CO CODE& code1);ST IN CODE Fold(CODE code,INT n);MODINT GetRand();VO CheckSize(CO INT& SZ);VI MODINT Twist(CRL c)CO;};
TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash():RollingHash(GetRand()){}TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_pw{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT,TY CODE>MODINT RollingHash<MODINT,INT,CODE>::r_pw(INT i)CO NE{if(i < m_SZ){RE m_r_pw[i];}MODINT AN = m_r_pw[m_SZ - 1];MODINT pw = m_r;i -= m_SZ - 1;WH(i > 0){(i & 1)== 0?AN:AN *= pw;pw *= pw;i >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN CODE RollingHash<MODINT,INT,CODE>::Encode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}RE{AN,m_r_pw[SZ],SZ};}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::CumulativeEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= Concatenate(AN[i],{Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i],m_r,1});}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::PointwiseEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={Twist(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed){CO int SZ = s.SZ();VE<CODE> AN{};if(le <= SZ){CheckSize(le + 1);AN.resize(SZ - le + 1,{MODINT{},m_r_pw[le],1});for(int i = 0;i < le;i++){get<0>(AN[0])+= Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}CO int SZ_shifted = SZ - le;for(int i = 1;i <= SZ_shifted;i++){get<0>(AN[i])=(get<0>(AN[i-1])- e(s[reversed?SZ - i:i - 1]))* m_r_inv + e(s[reversed?SZ - i - le:i - 1 + le])* m_r_pw[le-1];}}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO{auto&[h,p,s]= code;AS(i < s);h +=(Twist(c_next)-= Twist(c_prev))*= r_pw(MO(i));RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO{RE Replace(Replace(MO(code),MO(i),c_i,c_j),MO(j),c_j,c_i);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopFront(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);h -= Twist(c_prev)* r_pw(s);r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopBack(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);(h -= Twist(c_prev)* m_r_pw[0])*= m_r_inv;r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN int RollingHash<MODINT,INT,CODE>::CountContain(CO STR& s,CO CODE& code,CO bool& reversed){CO int SZ0 = s.SZ();CheckSize(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSize(SZ1);CO MODINT& r_pw = m_r_pw[SZ1 - 1];int AN = 0;MODINT temp = 0;for(int i = 0;i < SZ0;i++){(i < SZ1?temp += Twist(s[reversed?SZ0 - 1 - i:i])* m_r_pw[i]:((temp -= Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= Twist(s[reversed?SZ0 - 1 - i:i])* r_pw)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Concatenate(CODE code0,CO CODE& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Fold(CODE code,INT n){AS(n >= 0);CODE AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(MO(AN),code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::GetRand(){RE::GetRand(((MODINT{}- 1)/ 11).RP(),(MODINT{}- 1).RP());}TE <TY MODINT,TY INT,TY CODE> VO RollingHash<MODINT,INT,CODE>::CheckSize(CO INT& SZ){WH(m_SZ < SZ){m_r_pw.push_back(m_r_pw[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::Twist(CRL c)CO{RE MODINT(c);}

TE <TY MODINT = Mod<999309403>,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL ShiftableRollingHash:PU RollingHash<MODINT,INT,CODE>{PU:MODINT m_pw[26];IN ShiftableRollingHash();IN CODE Shift(CO Mod<26>& shift,CODE c)CO;MODINT Twist(CRL c)CO;ST MODINT GetPrimitiveRoot();};
TE <TY MODINT,TY INT,TY CODE> IN ShiftableRollingHash<MODINT,INT,CODE>::ShiftableRollingHash():RollingHash<MODINT,INT,CODE>(GetPrimitiveRoot()),m_pw{MODINT::DeRP(1)}{CE CO decltype(MODINT::GetModulo())P = MODINT::GetModulo();ST_AS(P == 999309403 || P == 999300121 || P == 999300017);m_pw[1]= MODINT::DeRP(P == 999309403?1102168:P == 999300121?75873362:31458519);for(int i = 2;i < 26;i++){m_pw[i]= m_pw[i-1]* m_pw[1];}}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHash<MODINT,INT,CODE>::Shift(CO Mod<26>& shift,CODE c)CO{get<0>(c)*= m_pw[shift.RP()];RE MO(c);}TE <TY MODINT,TY INT,TY CODE> MODINT ShiftableRollingHash<MODINT,INT,CODE>::Twist(CRL c)CO{AS('A' <= c && c <= 'z');RE m_pw[c -(c < 'a'?'A':'a')];}TE <TY MODINT,TY INT,TY CODE>MODINT ShiftableRollingHash<MODINT,INT,CODE>::GetPrimitiveRoot(){CE CO decltype(MODINT::GetModulo())P = MODINT::GetModulo();CE CO MODINT pr = MODINT::DeRP(P == 999309403?2:P == 999300121?22:5);int EX = GetRand(1,P - 1);RE Power(pr,MO(EX /= GCD(EX,P - 1)));}
#endif
