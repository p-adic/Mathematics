#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Utility/String/RollingHash/a_Body.hpp"
#else
TE <TY MODINT,TY INT = int>CL RollingHash{PU:INT m_SZ;VE<MODINT> m_PW;MODINT m_r;MODINT m_r_inv;IN RollingHash(MODINT r);TE <TY STR> IN tuple<MODINT,MODINT,INT> Encode(CO STR& s);TE <TY STR,TY Enum> tuple<MODINT,MODINT,INT> Encode(CO STR& s,Enum& e);IN tuple<MODINT,MODINT,INT> Concatenate(CO tuple<MODINT,MODINT,INT>& code0,CO tuple<MODINT,MODINT,INT>& code1)CO;IN tuple<MODINT,MODINT,INT> Fold(tuple<MODINT,MODINT,INT> code,INT n)CO;TE <TY CHAR> IN tuple<MODINT,MODINT,INT> Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR,TY Enum> tuple<MODINT,MODINT,INT> Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO;TE <TY STR> IN INT CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code);TE <TY STR,TY Enum> INT CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,Enum& e);VO CheckSZ(CO INT& SZ);TE <TY CHAR> ST IN MODINT Enumeration(CO CHAR& c);};
TE <TY MODINT,TY INT> IN RollingHash<MODINT,INT>::RollingHash(MODINT r):m_SZ(1),m_PW{1},m_r(MO(r)),m_r_inv(m_r){m_r_inv.Invert();}TE <TY MODINT,TY INT> TE <TY STR> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Encode(CO STR& s){RE Encode(s,Enumeration<decldecay_t(s[0])>);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Encode(CO STR& s,Enum& e){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += e(s[i])* m_PW[i];}RE{AN,m_PW[SZ],SZ};}TE <TY MODINT,TY INT> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Concatenate(CO tuple<MODINT,MODINT,INT>& code0,CO tuple<MODINT,MODINT,INT>& code1)CO{RE{get<0>(code0)+ get<0>(code1)* get<1>(code0),get<1>(code0)* get<1>(code1),get<2>(code0)+ get<2>(code1)};}TE <TY MODINT,TY INT> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Fold(tuple<MODINT,MODINT,INT> code,INT n)CO{AS(n >= 0);tuple<MODINT,MODINT,INT> AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(AN,code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT> TE <TY CHAR> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO{RE Replace(code,i,c_prev,c_next,Enumeration<CHAR>);}TE <TY MODINT,TY INT> TE <TY CHAR,TY Enum>tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO{auto&[h,p,s]= code;AS(i < s);h +=(e(c_next)-= e(c_prev))*=(i < m_SZ?m_PW[i]:PW(m_r,i));RE MO(code);}TE <TY MODINT,TY INT> TE <TY STR> IN INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code){RE CountContain(s,code,Enumeration<decldecay_t(s[0])>);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,Enum& e){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO INT SZ0 = s.SZ();CheckSZ(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSZ(SZ1);CO MODINT& PW = m_PW[SZ1 - 1];INT AN = 0;MODINT temp = 0;for(INT i = 0;i < SZ0;i++){(i < SZ1?temp += e(s[i])* m_PW[i]:((temp -= e(s[i - SZ1]))*= m_r_inv)+= e(s[i])* PW)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT> VO RollingHash<MODINT,INT>::CheckSZ(CO INT& SZ){m_PW.reserve(SZ);WH(m_SZ < SZ){m_PW.push_back(m_PW[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT> TE <TY CHAR> IN MODINT RollingHash<MODINT,INT>::Enumeration(CO CHAR& c){RE MODINT{c};}
#endif
