#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/RollingHash/Module/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_pw;IN RollingHash();IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;MODINT r_pw(INT i)CO NE;TE <TY STR> IN CODE Encode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed = false);TE <TY CHAR> IN CODE Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR> IN CODE swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO;TE <TY CHAR> IN CODE PopFront(CODE code,CO CHAR& c_prev)CO;TE <TY CHAR> IN CODE PopBack(CODE code,CO CHAR& c_prev)CO;TE <TY STR> IN int CountContain(CO STR& s,CO CODE& code,CO bool& reversed = false);ST IN CODE Concatenate(CODE code0,CO CODE& code1);ST IN CODE Fold(CODE code,INT n);MODINT GetRand();VO CheckSize(CO INT& SZ);VI MODINT Twist(CRL c)CO;};
TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash():RollingHash(GetRand()){}TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_pw{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT,TY CODE>MODINT RollingHash<MODINT,INT,CODE>::r_pw(INT i)CO NE{if(i < m_SZ){RE m_r_pw[i];}MODINT AN = m_r_pw[m_SZ - 1];MODINT pw = m_r;i -= m_SZ - 1;WH(i > 0){(i & 1)== 0?AN:AN *= pw;pw *= pw;i >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN CODE RollingHash<MODINT,INT,CODE>::Encode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}RE{AN,m_r_pw[SZ],SZ};}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::CumulativeEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= Concatenate(AN[i],{Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i],m_r,1});}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::PointwiseEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={Twist(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed){CO int SZ = s.SZ();VE<CODE> AN{};if(le <= SZ){CheckSize(le + 1);AN.resize(SZ - le + 1,{MODINT{},m_r_pw[le],1});for(int i = 0;i < le;i++){get<0>(AN[0])+= Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}CO int SZ_shifted = SZ - le;for(int i = 1;i <= SZ_shifted;i++){get<0>(AN[i])=(get<0>(AN[i-1])- e(s[reversed?SZ - i:i - 1]))* m_r_inv + e(s[reversed?SZ - i - le:i - 1 + le])* m_r_pw[le-1];}}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::Replace(CODE code,INT i,CO CHAR& c_prev,CO CHAR& c_next)CO{auto&[h,p,s]= code;AS(i < s);h +=(Twist(c_next)-= Twist(c_prev))*= r_pw(MO(i));RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::swap(CODE code,INT i,INT j,CO CHAR& c_i,CO CHAR& c_j)CO{RE Replace(Replace(MO(code),MO(i),c_i,c_j),MO(j),c_j,c_i);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopFront(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);(h -= Twist(c_prev)* m_r_pw[0])*= m_r_inv;p *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopBack(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);h -= Twist(c_prev)* r_pw(s);p *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN int RollingHash<MODINT,INT,CODE>::CountContain(CO STR& s,CO CODE& code,CO bool& reversed){CO int SZ0 = s.SZ();CheckSize(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSize(SZ1);CO MODINT& r_pw = m_r_pw[SZ1 - 1];int AN = 0;MODINT temp = 0;for(int i = 0;i < SZ0;i++){(i < SZ1?temp += Twist(s[reversed?SZ0 - 1 - i:i])* m_r_pw[i]:((temp -= Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= Twist(s[reversed?SZ0 - 1 - i:i])* r_pw)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Concatenate(CODE code0,CO CODE& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Fold(CODE code,INT n){AS(n >= 0);CODE AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(MO(AN),code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::GetRand(){RE::GetRand(((MODINT{}- 1)/ 11).RP(),(MODINT{}- 1).RP());}TE <TY MODINT,TY INT,TY CODE> VO RollingHash<MODINT,INT,CODE>::CheckSize(CO INT& SZ){WH(m_SZ < SZ){m_r_pw.push_back(m_r_pw[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::Twist(CRL c)CO{RE MODINT(c);}

TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHashModule:PU PointedSet<CODE>,VI PU VirtualGroup<CODE>,VI PU VirtualRSet<int,CODE>{PU:IN RollingHashModule();IN CODE Product(CODE code0,CO CODE& code1);IN CODE Transfer(CO CODE& code);IN CODE Action(CRI r,CODE code);};
TE <TY MODINT,TY INT,TY CODE> IN RollingHashModule<MODINT,INT,CODE>::RollingHashModule():PointedSet<CODE>({0,1,0}){ST_AS(is_same_v<CODE,tuple<MODINT,MODINT,INT>>);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Product(CODE code0,CO CODE& code1){RE RollingHash<MODINT,INT>::Concatenate(MO(code0),code1);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Transfer(CO CODE& code){MODINT p = 1 / get<1>(code);RE{- get<0>(code)* p,p,-get<2>(code)};}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Action(CRI r,CODE code){RE RollingHash<MODINT,INT>::Fold(MO(code),r);}
#endif

