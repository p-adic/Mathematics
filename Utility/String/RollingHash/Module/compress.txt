#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Utility/String/RollingHash/Module/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY MODINT,TY INT = int>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_PW;IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;IN CO VE<MODINT>& r_PW()CO NE;TE <TY STR> IN tuple<MODINT,MODINT,INT> Encode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> tuple<MODINT,MODINT,INT> Encode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY STR> IN VE<MODINT> CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> VE<MODINT> CumulativeEncode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY STR> IN VE<tuple<MODINT,MODINT,INT>> PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> VE<tuple<MODINT,MODINT,INT>> PointwiseEncode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY CHAR> IN tuple<MODINT,MODINT,INT> Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR,TY Enum> tuple<MODINT,MODINT,INT> Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO;TE <TY STR> IN INT CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,CO bool& reversed = false);TE <TY STR,TY Enum> INT CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,Enum& e,CO bool& reversed = false);ST IN tuple<MODINT,MODINT,INT> Concatenate(tuple<MODINT,MODINT,INT> code0,CO tuple<MODINT,MODINT,INT>& code1);ST IN tuple<MODINT,MODINT,INT> Fold(tuple<MODINT,MODINT,INT> code,INT n);VO CheckSZ(CO INT& SZ);TE <TY CHAR> ST IN MODINT Enumeration(CO CHAR& c);};
TE <TY MODINT,TY INT> IN RollingHash<MODINT,INT>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_PW{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT> IN CO MODINT& RollingHash<MODINT,INT>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT> IN CO MODINT& RollingHash<MODINT,INT>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT> IN CO VE<MODINT>& RollingHash<MODINT,INT>::r_PW()CO NE{RE m_r_PW;}TE <TY MODINT,TY INT> TE <TY STR> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Encode(CO STR& s,CO bool& reversed){RE Encode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Encode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += e(s[reversed?SZ - 1 - i:i])* m_r_PW[i];}RE{AN,m_r_PW[SZ],SZ};}TE <TY MODINT,TY INT> TE <TY STR> IN VE<MODINT> RollingHash<MODINT,INT>::CumulativeEncode(CO STR& s,CO bool& reversed){RE CumulativeEncode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>VE<MODINT> RollingHash<MODINT,INT>::CumulativeEncode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);VE<MODINT> AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= AN[i]+ e(s[reversed?SZ - 1 - i:i])* m_r_PW[i];}RE AN;}TE <TY MODINT,TY INT> TE <TY STR> IN VE<tuple<MODINT,MODINT,INT>> RollingHash<MODINT,INT>::PointwiseEncode(CO STR& s,CO bool& reversed){RE PointwiseEncode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>VE<tuple<MODINT,MODINT,INT>> RollingHash<MODINT,INT>::PointwiseEncode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);VE<tuple<MODINT,MODINT,INT>> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={e(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT> TE <TY CHAR> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO{RE Replace(code,i,c_prev,c_next,Enumeration<CHAR>);}TE <TY MODINT,TY INT> TE <TY CHAR,TY Enum>tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Replace(tuple<MODINT,MODINT,INT> code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO{auto&[h,p,s]= code;AS(i < s);h +=(e(c_next)-= e(c_prev))*=(i < m_SZ?m_r_PW[i]:R_PW(m_r,i));RE MO(code);}TE <TY MODINT,TY INT> TE <TY STR> IN INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,CO bool& reversed){RE CountContain(s,code,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO tuple<MODINT,MODINT,INT>& code,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO INT SZ0 = s.SZ();CheckSZ(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSZ(SZ1);CO MODINT& r_PW = m_r_PW[SZ1 - 1];INT AN = 0;MODINT temp = 0;for(INT i = 0;i < SZ0;i++){(i < SZ1?temp += e(s[reversed?SZ0 - 1 - i:i])* m_r_PW[i]:((temp -= e(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= e(s[reversed?SZ0 - 1 - i:i])* r_PW)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Concatenate(tuple<MODINT,MODINT,INT> code0,CO tuple<MODINT,MODINT,INT>& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT> IN tuple<MODINT,MODINT,INT> RollingHash<MODINT,INT>::Fold(tuple<MODINT,MODINT,INT> code,INT n){AS(n >= 0);tuple<MODINT,MODINT,INT> AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(AN,code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT> VO RollingHash<MODINT,INT>::CheckSZ(CO INT& SZ){m_r_PW.reserve(SZ);WH(m_SZ < SZ){m_r_PW.push_back(m_r_PW[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT> TE <TY CHAR> IN MODINT RollingHash<MODINT,INT>::Enumeration(CO CHAR& c){RE MODINT{c};}

TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHashModule:PU PointedSet<CODE>,VI PU VirtualGroup<CODE>,VI PU VirtualRSet<int,CODE>{PU:IN RollingHashModule();IN CODE Product(CODE code0,CO CODE& code1);IN CODE Transfer(CO CODE& code);IN CODE Action(CRI r,CODE code);};
TE <TY MODINT,TY INT,TY CODE> IN RollingHashModule<MODINT,INT,CODE>::RollingHashModule():PointedSet<CODE>({0,1,0}){ST_AS(is_same_v<CODE,tuple<MODINT,MODINT,INT>>);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Product(CODE code0,CO CODE& code1){RE RollingHash<MODINT,INT>::Concatenate(MO(code0),code1);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Transfer(CO CODE& code){MODINT p = 1 / get<1>(code);RE{- get<0>(code)* p,p,-get<2>(code)};}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHashModule<MODINT,INT,CODE>::Action(CRI r,CODE code){RE RollingHash<MODINT,INT>::Fold(MO(code),r);}
#endif

