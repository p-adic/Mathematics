#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Utility/String/Palindrome/a_Body.hpp"
#else
TE <TY MODINT,TY INT = int>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_power;IN RollingHash();IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;IN CO VE<MODINT>& r_power()CO NE;US Code = tuple<MODINT,MODINT,INT>;TE <TY STR> IN Code EnCode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> Code EnCode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY STR> IN Code CumulativeEnCode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> Code CumulativeEnCode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY STR> IN VE<Code> PointwiseEnCode(CO STR& s,CO bool& reversed = false);TE <TY STR,TY Enum> VE<Code> PointwiseEnCode(CO STR& s,Enum& e,CO bool& reversed = false);TE <TY STR> IN Code FixedLEEnCode(CO STR& s,CRI LE,CO bool& reversed = false);TE <TY STR,TY Enum> Code FixedLEEnCode(CO STR& s,CRI LE,Enum& e,CO bool& reversed = false);TE <TY CHAR> IN Code Replace(Code code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR,TY Enum> Code Replace(Code code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO;TE <TY CHAR> IN Code PopFront(Code code,CO CHAR& c_prev)CO;TE <TY CHAR,TY Enum> Code PopFront(Code code,CO CHAR& c_prev,Enum& e)CO;TE <TY CHAR> IN Code PopBack(Code code,CO CHAR& c_prev)CO;TE <TY CHAR,TY Enum> Code PopBack(Code code,CO CHAR& c_prev,Enum& e)CO;TE <TY STR> IN INT CountContain(CO STR& s,CO Code& code,CO bool& reversed = false);TE <TY STR,TY Enum> INT CountContain(CO STR& s,CO Code& code,Enum& e,CO bool& reversed = false);ST IN Code Concatenate(Code code0,CO Code& code1);ST IN Code Fold(Code code,INT n);VO CheckSZ(CO INT& SZ);TE <TY CHAR> ST IN MODINT Enumeration(CO CHAR& c);};
TE <TY MODINT,TY INT> IN RollingHash<MODINT,INT>::RollingHash():RollingHash(GetRand(((MODINT{}- 1)/ 11).RP(),(MODINT{}- 1).RP())){}TE <TY MODINT,TY INT> IN RollingHash<MODINT,INT>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_power{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT> IN CO MODINT& RollingHash<MODINT,INT>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT> IN CO MODINT& RollingHash<MODINT,INT>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT> IN CO VE<MODINT>& RollingHash<MODINT,INT>::r_power()CO NE{RE m_r_power;}TE <TY MODINT,TY INT> TE <TY STR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Encode(CO STR& s,CO bool& reversed){RE Encode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Encode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += e(s[reversed?SZ - 1 - i:i])* m_r_power[i];}RE{AN,m_r_power[SZ],SZ};}TE <TY MODINT,TY INT> TE <TY STR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::CumulativeEncode(CO STR& s,CO bool& reversed){RE CumulativeEncode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::CumulativeEncode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);TY RollingHash<MODINT,INT>::Code AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= Concatenate(AN[i],{e(s[reversed?SZ - 1 - i:i])* m_r_power[i],m_r,1});}RE AN;}TE <TY MODINT,TY INT> TE <TY STR> IN VE<TY RollingHash<MODINT,INT>::Code> RollingHash<MODINT,INT>::PointwiseEncode(CO STR& s,CO bool& reversed){RE PointwiseEncode(s,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>VE<TY RollingHash<MODINT,INT>::Code> RollingHash<MODINT,INT>::PointwiseEncode(CO STR& s,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);VE<TY RollingHash<MODINT,INT>::Code> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={e(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT> TE <TY STR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::FixedLEEncode(CO STR& s,CRI LE,CO bool& reversed){RE FixedLEEncode(s,LE,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::FixedLEEncode(CO STR& s,CRI LE,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO int SZ = s.SZ();CheckSZ(SZ + 1);TY RollingHash<MODINT,INT>::Code AN(SZ - LE,{MODINT{},m_r_power[LE],1});for(int i = 0;i < SZ;i++){get<0>(AN[0])+= e(s[reversed?SZ - 1 - i:i])* m_r_power[i];}CO int SZ_shifted = SZ - LE;for(int i = 1;i < SZ_shift;i++){get<0>(AN[i])= get<0>(AN[i-1])- e(s[reversed?SZ - i:i - 1])* m_r_power[i-1]+ e(s[reversed?SZ - i - LE:i - 1 + LE])* m_r_power[i-1+LE];}RE AN;}TE <TY MODINT,TY INT> TE <TY CHAR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Replace(TY RollingHash<MODINT,INT>::Code code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO{RE Replace(MO(code),i,c_prev,c_next,Enumeration<CHAR>);}TE <TY MODINT,TY INT> TE <TY CHAR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Replace(TY RollingHash<MODINT,INT>::Code code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next,Enum& e)CO{auto&[h,p,s]= code;AS(i < s);h +=(e(c_next)-= e(c_prev))*=(i < m_SZ?m_r_power[i]:R_PW(m_r,i));RE MO(code);}TE <TY MODINT,TY INT> TE <TY CHAR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::PopFront(TY RollingHash<MODINT,INT>::Code code,CO CHAR& c_prev)CO{RE PopFront(MO(code),c_prev,Enumeration<CHAR>);}TE <TY MODINT,TY INT> TE <TY CHAR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::PopFront(TY RollingHash<MODINT,INT>::Code code,CO CHAR& c_prev,Enum& e)CO{auto&[h,p,s]= code;AS(s-- > 0);h -= e(c_prev)*(s < m_SZ?m_r_power[s]:R_PW(m_r,s));r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT> TE <TY CHAR> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::PopBack(TY RollingHash<MODINT,INT>::Code code,CO CHAR& c_prev)CO{RE PopBack(MO(code),c_prev,Enumeration<CHAR>);}TE <TY MODINT,TY INT> TE <TY CHAR,TY Enum>TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::PopBack(TY RollingHash<MODINT,INT>::Code code,CO CHAR& c_prev,Enum& e)CO{auto&[h,p,s]= code;AS(s-- > 0);(h -= e(c_prev)* m_r_power[0])*= m_r_inv;r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT> TE <TY STR> IN INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO TY RollingHash<MODINT,INT>::Code& code,CO bool& reversed){RE CountContain(s,code,Enumeration<decldecay_t(s[0])>,reversed);}TE <TY MODINT,TY INT> TE <TY STR,TY Enum>INT RollingHash<MODINT,INT>::CountContain(CO STR& s,CO TY RollingHash<MODINT,INT>::Code& code,Enum& e,CO bool& reversed){ST_AS(is_invocable_r_v<MODINT,Enum,CO decldecay_t(s[0])&>);CO INT SZ0 = s.SZ();CheckSZ(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSZ(SZ1);CO MODINT& r_power = m_r_power[SZ1 - 1];INT AN = 0;MODINT temp = 0;for(INT i = 0;i < SZ0;i++){(i < SZ1?temp += e(s[reversed?SZ0 - 1 - i:i])* m_r_power[i]:((temp -= e(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= e(s[reversed?SZ0 - 1 - i:i])* r_power)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Concatenate(TY RollingHash<MODINT,INT>::Code code0,CO TY RollingHash<MODINT,INT>::Code& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT> IN TY RollingHash<MODINT,INT>::Code RollingHash<MODINT,INT>::Fold(TY RollingHash<MODINT,INT>::Code code,INT n){AS(n >= 0);TY RollingHash<MODINT,INT>::Code AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(MO(AN),code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT> VO RollingHash<MODINT,INT>::CheckSZ(CO INT& SZ){m_r_power.reserve(SZ);WH(m_SZ < SZ){m_r_power.push_back(m_r_power[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT> TE <TY CHAR> IN MODINT RollingHash<MODINT,INT>::Enumeration(CO CHAR& c){RE MODINT{c};}

VE<bool> Palindrome(CO string& S,CO bool& reversed = false){CO int N = S.SZ();VE AN(N,true);RollingHash<MP,ll> rh{};auto code = rh.PointwiseEncode(S,reversed);auto left = code[0],right = code[1];for(int r = 1;r < N;r++){left = rh.Concatenate(MO(left),code[r]);right = rh.Concatenate(code[r],MO(right));AN[reversed?N - 1 - r:r]= left == right;}RE AN;}VE<VE<bool>> TotalPalindrome(CO string& S){CO int N = S.SZ();VE AN(N,VE<bool>());AN[0].resize(1,true);for(int r = 1;r < N;r++){CO VE<bool>& AN_r_minus = AN[r-1];VE<bool>& AN_r = AN[r];AN_r.resize(r + 1,true);for(int l = 0;l <= r;l++){AN_r[l]=(S[l]== S[r])&& AN_r_minus[l+1];}}RE AN;}
#endif

