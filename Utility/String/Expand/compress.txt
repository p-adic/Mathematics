#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/Expand/a_Body.hpp"
#else
TE <TY INT> IN ll TruncatedSum(CRL n,CRL m,CO INT& bound){AS(m >= 0 && bound >= 0);RE n <= bound - m?n + m:bound + 1;}TE <TY INT> IN ll TruncatedProduct(CRL n,CRL m,CO INT& bound){AS(m >= 0 && bound >= 0);RE m == 0?m:n <= bound / m?n * m:bound + 1;}

TE <TE <TY...> TY TUPLE>string ExpandRandomAccess(CO VE<string>& S,CO string& source,CO VE<int>& trans,VE<TUPLE<int,ll,ll>> query){ll K = 0;for(auto&[i,t,k]:query){SetMax(K,k);}CO int N = S.SZ(),M = source.SZ();VE count(N,VE(1,VE<int>(M + 1)));VE init(N,pair{-1,-1});for(int i = 0;i < N;i++){CO int SZ = S[i].SZ();for(int p = 0;p < SZ;p++){count[i].push_back(count[i][p]);bool found = false;for(int j = 0;!found && j < M;j++){if((found |= S[i][p]== source[j])){count[i][p+1][j]++;if(init[i].first == -1){init[i]={p,j};}}}if(!found){count[i][p+1][M]++;}}}VE A(2,VE(M + 1,VE<ll>(M + 1,0)));for(int j = 0;j <= M;j++){A[0][j][j]= 1;if(j < M){for(auto& c:S[trans[j]]){bool found = false;for(int q = 0;!found && q < M;q++){if(c == source[q]){A[1][q][j]++;found = true;}}if(!found){A[1][M][j]++;}}}else{A[1][j][M]= 1;}}VE<bool> over(M),all(M,true);auto mult =[&](CO VE<VE<ll>>& B){VE AN(M + 1,VE<ll>(M + 1));VE<ll> sum(M + 1);for(int q = 0;q <= M;q++){for(int j = 0;j <= M;j++){for(int r = 0;AN[q][j]<= K && r <= M;r++){AN[q][j]= TruncatedSum(AN[q][j],TruncatedProduct(A[1][q][r],B[r][j],K),K);}if(j < M){over[j]= over[j]||(sum[j]= TruncatedSum(sum[j],AN[q][j],K))> K;}}}RE AN;};WH(over != all){A.push_back(mult(A.back()));}CO int T = len(A);ll temp = 0;auto eval =[&](CRI i,CRI p,CRL t,CRL k){AS(0 <= i && i < N && -1 <= p && p < int(S[i].SZ())&& 0 <= t && t < T);ll AN = 0;if(p >= 0){for(int q = 0;AN <= K && q <= M;q++){CO int r_max = q == M?M:M - 1;for(int r = 0;AN <= K && r <= r_max;r++){AN = TruncatedSum(AN,TruncatedProduct(A[t][q][r],count[i][p+1][r],K),K);}}}if(AN < k){SetMax(temp,AN);}RE AN;};string AN{};for(auto&[i,t,k]:query){AS(0 <= i && i < N && t >= 0 && k > 0);auto&[p0,j0]= init[i];if(k <= p0){AN.push_back(S[i][k-1]);continue;}AS(j0 != -1);auto&[p1,j1]= init[trans[j0]];AS(p1 != -1 && j0 == j1);if(k <= TruncatedSum(p0,TruncatedProduct(p1,t,K),K)){AN.push_back(S[trans[j0]][(k - p0)% p1]);continue;}if(T <= t){k -= p0 + p1 *(t - T);i = trans[j0];t = T - 1;}bool fix = false;for(int s = 0;!fix && s <= t;s++){CO int SZ = S[i].SZ();temp = 0;MAX_LEQ(p,-1,SZ - 1,eval(i,p,t - s,k),k - 1);AS(-1 <= p && p < SZ - 1);k -= temp;p++;fix = true;for(int j = 0;j < M;j++){if(S[i][p]== source[j]){if(s < t &&(k > 1 || S[i][p]!= S[trans[j]][0])){i = trans[j];fix = false;}break;}}if(fix){AS(k == 1);AN.push_back(S[i][p]);}}AS(fix);}RE AN;}
#endif

