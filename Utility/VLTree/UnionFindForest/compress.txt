// １つ目のコンストラクタは領域を確保するだけなのでpush_RightMostで要素を追加する必要があることに注意。
TE <TY T>CL EntryOfVLTree{PU:T m_t;EntryOfVLTree<T>* m_left_branch;EntryOfVLTree<T>* m_right_branch;EntryOfVLTree<T>* m_leftmost_node;EntryOfVLTree<T>* m_rightmost_node;IN EntryOfVLTree();TE <TY Arg> IN EntryOfVLTree(CO Arg&);TE <TY Arg> IN EntryOfVLTree(CO Arg&,EntryOfVLTree<T>* CO&,EntryOfVLTree<T>* CO&);IN EntryOfVLTree(CO EntryOfVLTree<T>&);EntryOfVLTree<T>& OP=(CO EntryOfVLTree<T>&);};
TE <TY T> IN EntryOfVLTree<T>::EntryOfVLTree(): m_t(),m_left_branch(TH),m_right_branch(TH),m_leftmost_node(TH),m_rightmost_node(TH){}TE <TY T> TE <TY Arg> IN EntryOfVLTree<T>::EntryOfVLTree(CO Arg& t): EntryOfVLTree(t,TH,TH){}TE <TY T> TE <TY Arg> IN EntryOfVLTree<T>::EntryOfVLTree(CO Arg& t,EntryOfVLTree<T>* CO& left_branch,EntryOfVLTree<T>* CO& right_branch): m_t(t),m_left_branch(left_branch),m_right_branch(right_branch),m_leftmost_node(TH),m_rightmost_node(TH){}TE <TY T> IN EntryOfVLTree<T>::EntryOfVLTree(CO EntryOfVLTree<T>& e): m_t(e.m_t),m_left_branch(e.m_left_branch == &e?TH:e.m_left_branch),m_right_branch(e.m_right_branch == &e?TH:e.m_right_branch),m_leftmost_node(TH),m_rightmost_node(TH){if(e.m_leftmost_node != &e){m_leftmost_node = e.m_leftmost_node;m_rightmost_node = e.m_rightmost_node;}}TE <TY T> EntryOfVLTree<T>& EntryOfVLTree<T>::OP=(CO EntryOfVLTree<T>& e){m_t = e.m_t;m_left_branch =(e.m_left_branch == &e?TH:e.m_left_branch);m_right_branch =(e.m_right_branch == &e?TH:e.m_right_branch);if(e.m_leftmost_node == &e){m_leftmost_node = m_rightmost_node = TH;}else{m_leftmost_node = e.m_leftmost_node;m_rightmost_node = e.m_rightmost_node;}RE *TH;}
TE <TY T>CL IteratorOfVLTree{PU:EntryOfVLTree<T>* m_p;IN IteratorOfVLTree()NE;IN IteratorOfVLTree(EntryOfVLTree<T>* CO&)NE;IN IteratorOfVLTree(CO IteratorOfVLTree<T>&)NE;IN T& OP*()CO;IN T* OP->()CO;IN IteratorOfVLTree<T>& OP=(CO IteratorOfVLTree<T>&)NE;IteratorOfVLTree<T>& OP++(int)NE;IteratorOfVLTree<T>& OP--(int)NE;IteratorOfVLTree<T>& OP[](CO int&);IteratorOfVLTree<T>& Shift()NE;TE <TY... Args> IteratorOfVLTree<T>& Shift(CO int&,CO Args&...);IN bool IsLeaf()CO NE;IN bool IsLeftMost()CO NE;IN bool IsRightMost()CO NE;IN bool IsValid()CO NE;};
TE <TY T>CL COIteratorOfVLTree{PU:CO EntryOfVLTree<T>* m_p;IN COIteratorOfVLTree()NE;IN COIteratorOfVLTree(CO EntryOfVLTree<T>* CO&)NE;IN COIteratorOfVLTree(CO COIteratorOfVLTree<T>&)NE;IN COIteratorOfVLTree(CO IteratorOfVLTree<T>&)NE;IN CO T& OP*()CO;IN CO T* OP->()CO;IN COIteratorOfVLTree<T>& OP=(CO COIteratorOfVLTree<T>&)NE;IN COIteratorOfVLTree<T>& OP=(CO IteratorOfVLTree<T>&)NE;COIteratorOfVLTree<T>& OP++(int)NE;COIteratorOfVLTree<T>& OP--(int)NE;COIteratorOfVLTree<T>& OP[](CO int&);COIteratorOfVLTree<T>& Shift()NE;TE <TY... Args> COIteratorOfVLTree<T>& Shift(CO int&,CO Args&...);IN bool IsLeaf()CO NE;IN bool IsLeftMost()CO NE;IN bool IsRightMost()CO NE;IN bool IsValid()CO NE;ST IN bool Equal(CO IteratorOfVLTree<T>&,CO IteratorOfVLTree<T>&)NE;ST IN bool Equal(CO COIteratorOfVLTree<T>&,CO IteratorOfVLTree<T>&)NE;ST IN bool Equal(CO IteratorOfVLTree<T>&,CO COIteratorOfVLTree<T>&)NE;ST IN bool Equal(CO COIteratorOfVLTree<T>&,CO COIteratorOfVLTree<T>&)NE;};
TE <TY T> IN IteratorOfVLTree<T>::IteratorOfVLTree()NE:m_p(nullptr){}TE <TY T> IN IteratorOfVLTree<T>::IteratorOfVLTree(EntryOfVLTree<T>* CO& p)NE:m_p(p){}TE <TY T> IN IteratorOfVLTree<T>::IteratorOfVLTree(CO IteratorOfVLTree<T>& IT)NE:m_p(IT.m_p){}TE <TY T> IN T& IteratorOfVLTree<T>::OP*()CO{RE m_p->m_t;}TE <TY T> IN T* IteratorOfVLTree<T>::OP->()CO{RE &(*(*TH));}TE <TY T> IN IteratorOfVLTree<T>& IteratorOfVLTree<T>::OP=(CO IteratorOfVLTree<T>& IT)NE{m_p = IT.m_p;RE *TH;}TE <TY T>IteratorOfVLTree<T>& IteratorOfVLTree<T>::OP++(int)NE{if(m_p == nullptr){RE *TH;}if(m_p == m_p->m_right_branch){m_p = nullptr;}else{m_p = m_p->m_right_branch;}RE *TH;}TE <TY T>IteratorOfVLTree<T>& IteratorOfVLTree<T>::OP--(int)NE{if(m_p == nullptr){RE *TH;}if(m_p == m_p->m_left_branch){m_p = nullptr;}else{m_p = m_p->m_left_branch;}RE *TH;}TE <TY T>IteratorOfVLTree<T>& IteratorOfVLTree<T>::OP[](CO int& n){if(n > 0){m_p = m_p->m_leftmost_node;for(int i = 1;i < n;i++){m_p = m_p->m_right_branch;}}else{if(n < 0){m_p = m_p->m_rightmost_node;for(int i = -1;n < i;i--){m_p = m_p->m_left_branch;}}}RE *TH;}TE <TY T> IteratorOfVLTree<T>& IteratorOfVLTree<T>::Shift()NE{RE *TH;}TE <TY T> TE <TY... Args> IteratorOfVLTree<T>& IteratorOfVLTree<T>::Shift(CO int& n,CO Args&... args){OP[](n);RE Shift(args...);}TE <TY T> IN bool IteratorOfVLTree<T>::IsLeaf()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_leftmost_node);}TE <TY T> IN bool IteratorOfVLTree<T>::IsLeftMost()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_left_branch);}TE <TY T> IN bool IteratorOfVLTree<T>::IsRightMost()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_right_branch);}TE <TY T> IN bool IteratorOfVLTree<T>::IsValid()CO NE{RE m_p != nullptr;}TE <TY T> IN COIteratorOfVLTree<T>::COIteratorOfVLTree()NE:m_p(nullptr){}TE <TY T> IN COIteratorOfVLTree<T>::COIteratorOfVLTree(CO EntryOfVLTree<T>* CO& p)NE:m_p(p){}TE <TY T> IN COIteratorOfVLTree<T>::COIteratorOfVLTree(CO COIteratorOfVLTree<T>& IT)NE:m_p(IT.m_p){}TE <TY T> IN COIteratorOfVLTree<T>::COIteratorOfVLTree(CO IteratorOfVLTree<T>& IT)NE:m_p(IT.m_p){}TE <TY T> IN CO T& COIteratorOfVLTree<T>::OP*()CO{RE m_p->m_t;};TE <TY T> IN CO T* COIteratorOfVLTree<T>::OP->()CO{RE &(*(*TH));}TE <TY T> IN COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::OP=(CO COIteratorOfVLTree<T>& IT)NE{m_p = IT.m_p;RE *TH;}TE <TY T> IN COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::OP=(CO IteratorOfVLTree<T>& IT)NE{m_p = IT.m_p;RE *TH;}TE <TY T>COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::OP++(int)NE{if(m_p == nullptr){RE *TH;}if(m_p == m_p->m_right_branch){m_p = nullptr;}else{m_p = m_p->m_right_branch;}RE *TH;}TE <TY T>COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::OP--(int)NE{if(m_p == nullptr){RE *TH;}if(m_p == m_p->m_left_branch){m_p = nullptr;}else{m_p = m_p->m_left_branch;}RE *TH;}TE <TY T>COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::OP[](CO int& n){if(n > 0){m_p = m_p->m_leftmost_node;for(int i = 1;i < n;i++){m_p = m_p->m_right_branch;}}if(n < 0){m_p = m_p->m_rightmost_node;for(int i = -1;n < i;i--){m_p = m_p->m_left_branch;}}RE *TH;}TE <TY T> COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::Shift()NE{RE *TH;}TE <TY T> TE <TY... Args> COIteratorOfVLTree<T>& COIteratorOfVLTree<T>::Shift(CO int& n,CO Args&... args){OP[](n);RE Shift(args...);}TE <TY T> IN bool COIteratorOfVLTree<T>::IsLeaf()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_leftmost_mode);}TE <TY T> IN bool COIteratorOfVLTree<T>::IsLeftMost()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_left_branch);}TE <TY T> IN bool COIteratorOfVLTree<T>::IsRightMost()CO NE{RE(m_p == nullptr)? false :(m_p == m_p->m_right_branch);}TE <TY T> IN bool COIteratorOfVLTree<T>::IsValid()CO NE{RE m_p != nullptr;}TE <TY T> IN bool COIteratorOfVLTree<T>::Equal(CO IteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE IT0.m_p == IT1.m_p;}TE <TY T> IN bool COIteratorOfVLTree<T>::Equal(CO COIteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE IT0.m_p == IT1.m_p;}TE <TY T> IN bool COIteratorOfVLTree<T>::Equal(CO IteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE IT0.m_p == IT1.m_p;}TE <TY T> IN bool COIteratorOfVLTree<T>::Equal(CO COIteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE IT0.m_p == IT1.m_p;}TE <TY T> IN bool OP==(CO IteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE COIteratorOfVLTree<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO IteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO COIteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE COIteratorOfVLTree<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO COIteratorOfVLTree<T>& IT0,CO IteratorOfVLTree<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO IteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE COIteratorOfVLTree<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO IteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO COIteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE COIteratorOfVLTree<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO COIteratorOfVLTree<T>& IT0,CO COIteratorOfVLTree<T>& IT1)NE{RE !(IT0 == IT1);}
TE <TY Arg>CL WrappedType{PU:Arg m_t;TE <TY... ARGS> IN WrappedType(CO ARGS&... args);IN VO Set(CO Arg& t);IN CO Arg& Get()CO NE;};
TE <TY... Types>CL WrappedTypes{};
TE <TY Arg> TE <TY... ARGS> IN WrappedType<Arg>::WrappedType(CO ARGS&... args): m_t(args...){}TE <TY Arg> IN VO WrappedType<Arg>::Set(CO Arg& t){m_t = t;}TE <TY Arg> IN CO Arg& WrappedType<Arg>::Get()CO NE{RE m_t;}
TE <TY T> CL VLTree;
TE <TY T>CL VLSubTree{PU:EntryOfVLTree<T> m_e;EntryOfVLTree<T>* m_p_root;uint m_SZ;IN VLSubTree();TE <TY Arg1,TY... Arg2> IN VLSubTree(CO Arg1&,CO Arg2&...);TE <TY Arg> IN VLSubTree(CO WrappedType<Arg>& t);IN VLSubTree(CO VLSubTree<T>&);IN VLSubTree(EntryOfVLTree<T>&);IN VLSubTree(CO IteratorOfVLTree<T>&);IN VLSubTree(CO int&,CO EntryOfVLTree<T>&);IN VLSubTree(CO int&,CO COIteratorOfVLTree<T>&);VO LeafToTree(CO VLSubTree<T>&);VO Graft(VLSubTree<T>&);virtual ~VLSubTree()= default;VLSubTree<T>& OP=(CO VLSubTree<T>&);IN CRUI SZ()CO NE;IN VO CutBranches();IN bool IsLeaf()CO NE;IN VLSubTree<T> LeftMostSubTree();IN VLSubTree<T> RightMostSubTree();IN VLTree<T> LeftMostSubTreeCopy()CO;IN VLTree<T> RightMostSubTreeCopy()CO;IN VO push_RightMost()CO NE;TE <TY Arg1,TY... Arg2> VO push_RightMost(CO Arg1&,CO Arg2&...);TE <TY... Args> VO push_RightMost(CO VLTree<T>&,CO Args&...);TE <TY Arg> VO push_LeftMost(CO Arg&);VO pop_RightMost();VO pop_LeftMost();VO pop_Root();US iterator = IteratorOfVLTree<T>;US CO_iterator = COIteratorOfVLTree<T>;IN iterator LeftMostNode()NE;IN CO_iterator LeftMostNode()CO NE;IN iterator RightMostNode()NE;IN CO_iterator RightMostNode()CO NE;iterator LeftMostLeaf()NE;CO_iterator LeftMostLeaf()CO NE;iterator RightMostLeaf()NE;CO_iterator RightMostLeaf()CO NE;IN iterator Root()NE;IN CO_iterator Root()CO NE;TE <TY... Args> IN iterator GetIterator(CO Args&...);TE <TY... Args> IN CO_iterator GetIterator(CO Args&...)CO;TE <TY Arg> VO insert(CO iterator&,CO Arg&);iterator erase(iterator&);IN CO T& GetRoot()CO NE;IN T& RefRoot()NE;IN VO SetRoot(CO T&);TE <TY... Args> IN CO T& GetNode(CO Args&...)CO;VLSubTree<T> OP[](CRUI);VLSubTree<T> OP[](iterator&);VLTree<T> OP[](CO CO_iterator&)CO;VLTree<T> GetBranchCopy(CRUI)CO;VLTree<T> GetBranchCopy(CO iterator&)CO;VLTree<T> GetBranchCopy(CO CO_iterator&)CO;VO Concatenate(CO VLTree<T>&);VO Concatenate(CO iterator&,CO VLTree<T>&);bool CheckContain(CO iterator&)CO NE;bool CheckContain(CO CO_iterator&)CO NE;string Display()CO;};
TE <TY T> IN VLSubTree<T>::VLSubTree(): m_e(),m_p_root(&m_e),m_SZ(0){}TE <TY T> TE <TY Arg1,TY... Arg2> IN VLSubTree<T>::VLSubTree(CO Arg1& t0,CO Arg2&... t1): VLSubTree<T>(){push_RightMost(t0,t1...);}TE <TY T> TE <TY Arg> IN VLSubTree<T>::VLSubTree(CO WrappedType<Arg>& t): m_e(t.Get()),m_p_root(&m_e),m_SZ(0){}TE <TY T> IN VLSubTree<T>::VLSubTree(CO VLSubTree<T>& a): m_e(a.m_e.m_t),m_p_root(&m_e),m_SZ(0){LeafToTree(a);}TE <TY T>VLSubTree<T>::VLSubTree(EntryOfVLTree<T>& e):m_e(e),m_p_root(&e),m_SZ(0){EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;if(p != m_p_root){m_SZ++;EntryOfVLTree<T>* CO p_rightmost = m_p_root->m_rightmost_node;WH(p != p_rightmost){p = p->m_right_branch;m_SZ++;}}}TE <TY T> IN VLSubTree<T>::VLSubTree(CO IteratorOfVLTree<T>& IT): VLSubTree(*(IT.m_p)){}TE <TY T>VLSubTree<T>::VLSubTree(CO int& dummy,CO EntryOfVLTree<T>& e):m_e(e.m_t),m_p_root(&m_e),m_SZ(0){CO EntryOfVLTree<T>* p = e.m_leftmost_node;CO EntryOfVLTree<T>* CO p_rightmost = e.m_rightmost_node;bool b =(p != &e);WH(b){push_RightMost(VLTree<T>(dummy,*p));b =(p != p_rightmost);p = p->m_right_branch;}}TE <TY T> IN VLSubTree<T>::VLSubTree(CO int& dummy,CO COIteratorOfVLTree<T>& IT): VLSubTree(dummy,*(IT.m_p)){}TE <TY T>VLSubTree<T>& VLSubTree<T>::OP=(CO VLSubTree<T>& a){if(TH != &a){CutBranches();LeafToTree(a);}RE *TH;}TE <TY T>VO VLSubTree<T>::LeafToTree(CO VLSubTree<T>& a){m_p_root->m_t = a.m_p_root->m_t;EntryOfVLTree<T>* p = a.m_p_root->m_leftmost_node;CRUI N = a.m_SZ;for(uint n = 0;n < N;n++){push_RightMost(VLTree<T>(0,*p));p = p->m_right_branch;}RE;}TE <TY T> IN CRUI VLSubTree<T>::SZ()CO NE{RE m_SZ;}TE <TY T> IN VO VLSubTree<T>::CutBranches(){WH(m_SZ > 0)pop_RightMost();}TE <TY T> IN bool VLSubTree<T>::IsLeaf()CO NE{RE m_SZ == 0;}TE <TY T> IN VLSubTree<T> VLSubTree<T>::LeftMostSubTree(){RE VLSubTree(*(m_p_root->m_leftmost_node));}TE <TY T> IN VLSubTree<T> VLSubTree<T>::RightMostSubTree(){RE VLSubTree(*(m_p_root->m_rightmost_node));}TE <TY T> IN VLTree<T> VLSubTree<T>::LeftMostSubTreeCopy()CO{RE VLTree<T>(0,*(m_p_root->m_leftmost_node));}TE <TY T> IN VLTree<T> VLSubTree<T>::RightMostSubTreeCopy()CO{RE VLTree<T>(0,*(m_p_root->m_rightmost_node));}TE <TY T> IN VO VLSubTree<T>::push_RightMost()CO NE{}TE <TY T> TE <TY Arg1,TY... Arg2>VO VLSubTree<T>::push_RightMost(CO Arg1& t0,CO Arg2&... t1){auto p = new EntryOfVLTree<T>(t0);EntryOfVLTree<T>*& p_rightmost = m_p_root->m_rightmost_node;if(p_rightmost == m_p_root){m_p_root->m_leftmost_node = p;}else{p->m_left_branch = p_rightmost;p_rightmost->m_right_branch = p;}p_rightmost = p;m_SZ++;push_RightMost(t1...);RE;}TE <TY T> TE <TY... Args>VO VLSubTree<T>::push_RightMost(CO VLTree<T>& t0,CO Args&... t1){push_RightMost(t0.m_p_root->m_t);Concatenate(t0);push_RightMost(t1...);RE;}TE <TY T> TE <TY Arg>VO VLSubTree<T>::push_LeftMost(CO Arg& t){auto p = new EntryOfVLTree<T>(t);EntryOfVLTree<T>*& p_leftmost = m_p_root->m_leftmost_node;if(p_leftmost == m_p_root){m_p_root->m_rightmost_node = p;}else{p->m_right_branch = p_leftmost;p_leftmost->m_left_branch = p;}p_leftmost = p;m_SZ++;RE;}TE <TY T>VO VLSubTree<T>::pop_RightMost(){assert(m_SZ > 0);EntryOfVLTree<T>* p_rightmost = m_p_root->m_rightmost_node;VLSubTree<T> t{*p_rightmost};t.CutBranches();if(m_SZ == 1){m_p_root->m_leftmost_node = m_p_root;m_p_root->m_rightmost_node = m_p_root;}else{EntryOfVLTree<T>* CO& p_rightmost_prev = p_rightmost->m_left_branch;m_p_root->m_rightmost_node = p_rightmost_prev;p_rightmost_prev->m_right_branch = p_rightmost_prev;}delete p_rightmost;m_SZ--;RE;}TE <TY T>VO VLSubTree<T>::pop_LeftMost(){assert(m_SZ > 0);EntryOfVLTree<T>* p_leftmost = m_p_root->m_leftmost_node;VLSubTree<T> t{*p_leftmost};t.CutBranches();if(m_SZ == 1){m_p_root->m_leftmost_node = m_p_root;m_p_root->m_rightmost_node = m_p_root;}else{EntryOfVLTree<T>* CO& p_leftmost_next = p_leftmost->m_right_branch;m_p_root->m_leftmost_node = p_leftmost_next;p_leftmost_next->m_left_branch = p_leftmost_next;}delete p_leftmost;m_SZ--;RE;}TE <TY T>VO VLSubTree<T>::pop_Root(){assert(m_SZ == 1);EntryOfVLTree<T>* p_unique_node = m_p_root->m_leftmost_node;m_p_root->m_t = p_unique_node->m_t;m_p_root->m_leftmost_node = p_unique_node->m_leftmost_node;m_p_root->m_rightmost_node = p_unique_node->m_rightmost_node;delete p_unique_node;EntryOfVLTree<T>* p_node = m_p_root->m_leftmost_node;m_SZ = 0;if(p_node != m_p_root){m_SZ++;WH(p_node != p_node->m_right_branch){p_node = p_node->m_right_branch;m_SZ++;}}RE;}TE <TY T> IN TY VLSubTree<T>::iterator VLSubTree<T>::LeftMostNode()NE{RE IteratorOfVLTree<T>(m_p_root->m_leftmost_node);}TE <TY T> IN TY VLSubTree<T>::CO_iterator VLSubTree<T>::LeftMostNode()CO NE{RE COIteratorOfVLTree<T>(m_p_root->m_leftmost_node);}TE <TY T> IN TY VLSubTree<T>::iterator VLSubTree<T>::RightMostNode()NE{RE IteratorOfVLTree<T>(m_p_root->m_rightmost_node);}TE <TY T> IN TY VLSubTree<T>::CO_iterator VLSubTree<T>::RightMostNode()CO NE{RE COIteratorOfVLTree<T>(m_p_root->m_rightmost_node);}TE <TY T>TY VLSubTree<T>::iterator VLSubTree<T>::LeftMostLeaf()NE{EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;WH(p != p->m_leftmost_node){p = p->m_leftmost_node;}RE IteratorOfVLTree<T>(p);}TE <TY T>TY VLSubTree<T>::CO_iterator VLSubTree<T>::LeftMostLeaf()CO NE{CO EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;WH(p != p->m_leftmost_node){p = p->m_leftmost_node;}RE COIteratorOfVLTree<T>(p);}TE <TY T>TY VLSubTree<T>::iterator VLSubTree<T>::RightMostLeaf()NE{EntryOfVLTree<T>* p = m_p_root->m_rightmost_node;WH(p != p->m_rightmost_node){p = p->m_rightmost_node;}RE IteratorOfVLTree<T>(p);}TE <TY T>TY VLSubTree<T>::CO_iterator VLSubTree<T>::RightMostLeaf()CO NE{CO EntryOfVLTree<T>* p = m_p_root->m_rightmost_node;WH(p != p->m_rightmost_node){p = p->m_rightmost_node;}RE COIteratorOfVLTree<T>(p);}TE <TY T> IN TY VLSubTree<T>::iterator VLSubTree<T>::Root()NE{RE IteratorOfVLTree<T>(m_p_root);}TE <TY T> IN TY VLSubTree<T>::CO_iterator VLSubTree<T>::Root()CO NE{RE COIteratorOfVLTree<T>(m_p_root);}TE <TY T> TE <TY... Args> IN TY VLSubTree<T>::iterator VLSubTree<T>::GetIterator(CO Args&... args){RE Root().Shift(args...);}TE <TY T> TE <TY... Args> IN TY VLSubTree<T>::CO_iterator VLSubTree<T>::GetIterator(CO Args&... args)CO{RE Root().Shift(args...);}TE <TY T> TE <TY Arg>VO VLSubTree<T>::insert(CO TY VLSubTree<T>::iterator& IT,CO Arg& t){assert(CheckContain(IT));EntryOfVLTree<T>* CO& p0 = IT.m_p;EntryOfVLTree<T>* CO& p1 = p0->m_right_branch;auto p = new EntryOfVLTree<T>(t,p0,p1);p1->m_left_branch = p;p0->m_right_branch = p;m_SZ++;RE;}TE <TY T>TY VLSubTree<T>::iterator VLSubTree<T>::erase(TY VLSubTree<T>::iterator& IT){assert(CheckContain(IT));EntryOfVLTree<T>* CO p = IT.m_p;EntryOfVLTree<T>* CO p0 = p->m_left_branch;EntryOfVLTree<T>* CO p1 = p->m_right_branch;if(! IT.IsLeaf()){VLSubTree<T> t_sub{*p};t_sub.CutBranches();}if(p0 != p){if(p != p1){IT++;p0->m_right_branch = p1;p1->m_left_branch = p0;}else{IT--;p0->m_right_branch = p0;m_p_root->m_rightmost_node = p0;}}else{if(p != p1){IT++;p1->m_left_branch = p1;m_p_root->m_leftmost_node = p1;}else{IT = Root();m_p_root->m_leftmost_node = m_p_root;m_p_root->m_rightmost_node = m_p_root;}}delete p;m_SZ--;RE IT;}TE <TY T> IN CO T& VLSubTree<T>::GetRoot()CO NE{RE m_p_root->m_t;}TE <TY T> IN T& VLSubTree<T>::RefRoot()NE{RE m_p_root->m_t;}TE <TY T> IN VO VLSubTree<T>::SetRoot(CO T& t){m_p_root->m_t = t;}TE <TY T> TE <TY... Args> IN CO T& VLSubTree<T>::GetNode(CO Args&... args)CO{RE *(GetIterator(args...));}TE <TY T>VLSubTree<T> VLSubTree<T>::OP[](CRUI i){assert(i < m_SZ);if(i <= m_SZ / 2){EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;for(uint n = 0;n < i;n++){p = p->m_right_branch;}RE VLSubTree<T>(*p);}EntryOfVLTree<T>* p = m_p_root->m_rightmost_node;for(uint n = m_SZ - 1;n > i;n--){p = p->m_left_branch;}RE VLSubTree<T>(*p);}TE <TY T>VLSubTree<T> VLSubTree<T>::OP[](TY VLSubTree<T>::iterator& IT){assert(CheckContain(IT));RE VLSubTree<T>(*(IT.m_p));}TE <TY T>VLTree<T> VLSubTree<T>::OP[](CO TY VLSubTree<T>::CO_iterator& IT)CO{assert(CheckContain(IT));RE VLTree<T>(0,IT.m_p);}TE <TY T>VLTree<T> VLSubTree<T>::GetBranchCopy(CRUI i)CO{assert(i < m_SZ);if(i <= m_SZ / 2){CO EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;for(uint n = 0;n < i;n++){p = p->m_right_branch;}RE VLTree<T>(0,*p);}CO EntryOfVLTree<T>* p = m_p_root->m_rightmost_node;for(uint n = m_SZ - 1;n > i;n--){p = p->m_left_branch;}RE VLTree<T>(0,*p);}TE <TY T>VLTree<T> VLSubTree<T>::GetBranchCopy(CO TY VLSubTree<T>::iterator& IT)CO{assert(CheckContain(IT));RE VLTree<T>(0,*(IT.m_p));}TE <TY T>VLTree<T> VLSubTree<T>::GetBranchCopy(CO TY VLSubTree<T>::CO_iterator& IT)CO{assert(CheckContain(IT));RE VLTree<T>(0,*(IT.m_p));}TE <TY T>VO VLSubTree<T>::Concatenate(CO VLTree<T>& t){EntryOfVLTree<T>* CO p_rightmost = m_p_root->m_rightmost_node;assert(p_rightmost->m_rightmost_node == p_rightmost);if(m_p_root == p_rightmost){LeafToTree(t);}else{VLSubTree<T>(*p_rightmost).LeafToTree(t);}RE;}TE <TY T>VO VLSubTree<T>::Concatenate(CO TY VLSubTree<T>::iterator& IT,CO VLTree<T>& t){assert(IT.IsLeaf());EntryOfVLTree<T>* CO p = IT.m_p;if(m_p_root == p){LeafToTree(t);}else{VLSubTree<T>(*p).LeafToTree(t);}RE;}TE <TY T>VO VLSubTree<T>::Graft(VLSubTree<T>& t){EntryOfVLTree<T>*& p_rightmost = m_p_root->m_rightmost_node;if(m_p_root == p_rightmost){p_rightmost = m_p_root->m_leftmost_node = t.m_p_root;}else{t.m_p_root->m_left_branch = p_rightmost;p_rightmost = p_rightmost->m_right_branch = t.m_p_root;}RE;}TE <TY T>bool VLSubTree<T>::CheckContain(CO iterator& IT)CO NE{auto p0 = IT.m_p;auto p1 = m_p_root->m_leftmost_node;for(uint i = 0;i < m_SZ;i++){if(p0 == p1){RE true;}p1 = p1->m_right_branch;}RE false;}TE <TY T>bool VLSubTree<T>::CheckContain(CO CO_iterator& IT)CO NE{auto p0 = IT.m_p;auto p1 = m_p_root->m_leftmost_node;for(uint i = 0;i < m_SZ;i++){if(p0 == p1){RE true;}p1 = p1->m_right_branch;}RE false;}TE <TY T>string VLSubTree<T>::Display()CO{string s = to_string(m_p_root->m_t);s += "(";CO EntryOfVLTree<T>* p = m_p_root->m_leftmost_node;for(uint i = 0;i < m_SZ;i++){if(i > 0){s += ",";}s += VLTree<T>(0,*p).Display();p = p->m_right_branch;}s += ")";RE s;}TE <TY T>bool OP==(CO VLTree<T>& t1,CO VLTree<T>& t2){if(t1.GetRoot()!= t2.GetRoot()){RE false;}if(t1.IsLeaf()){RE t2.IsLeaf();}if(t2.IsLeaf()){RE false;}auto IT1 = t1.LeftMostNode();auto IT2 = t2.LeftMostNode();WH(IT1.IsValid()&& IT2.IsValid()){if(t1.GetBranchCopy(*IT1)!= t2.GetBranchCopy(*IT2)){RE false;}IT1++;IT2++;}RE !(IT1.IsValid()|| IT2.IsValid());}TE <TY T> IN bool OP!=(CO VLTree<T>& t1,CO VLTree<T>& t2){RE !(t1 == t2);}
TE <TY T>CL EntryOfLinkedVE{PU:T m_t;uint m_prev_entry;uint m_next_entry;IN EntryOfLinkedVE();IN EntryOfLinkedVE(CRUI prev_entry,CRUI next_entry);IN EntryOfLinkedVE(EntryOfLinkedVE<T>&& e);};
TE <TY T> IN EntryOfLinkedVE<T>::EntryOfLinkedVE(): m_t(),m_prev_entry(0),m_next_entry(0){}TE <TY T> IN EntryOfLinkedVE<T>::EntryOfLinkedVE(CRUI prev_entry,CRUI next_entry): m_t(),m_prev_entry(prev_entry),m_next_entry(next_entry){}TE <TY T> IN EntryOfLinkedVE<T>::EntryOfLinkedVE(EntryOfLinkedVE<T>&& e): m_t(MO(e.m_t)),m_prev_entry(MO(e.m_prev_entry)),m_next_entry(MO(e.m_next_entry)){}
TE <TY T> CL LinkedVE;
TE <TY T>CL IteratorOfLinkedVE{PU:LinkedVE<T>* m_p;uint m_i;IN IteratorOfLinkedVE(LinkedVE<T>* CO& p,CRUI i)NE;IN IteratorOfLinkedVE(CO IteratorOfLinkedVE<T>& IT)NE;IN T& OP*()CO;IN T* OP->()CO;IteratorOfLinkedVE<T>& OP=(CO IteratorOfLinkedVE<T>& IT)NE;IN VO OP++(int);IN VO OP--(int);IN CO LinkedVE<T>& GetLinkedVE()CO NE;IN LinkedVE<T>& RefLinkedVE()NE;IN CRUI GetIndex()CO NE;IN CRUI RefIndex()NE;};
TE <TY T>CL COIteratorOfLinkedVE{PU:CO LinkedVE<T>* m_p;uint m_i;IN COIteratorOfLinkedVE(CO LinkedVE<T>* CO& p,CRUI i)NE;IN COIteratorOfLinkedVE(CO COIteratorOfLinkedVE<T>& IT)NE;IN COIteratorOfLinkedVE(CO IteratorOfLinkedVE<T>& IT)NE;IN CO T& OP*()CO;IN CO T* OP->()CO;COIteratorOfLinkedVE<T>& OP=(CO COIteratorOfLinkedVE<T>& IT)NE;COIteratorOfLinkedVE<T>& OP=(CO IteratorOfLinkedVE<T>& IT)NE;IN VO OP++(int);IN VO OP--(int);IN CO LinkedVE<T>& GetLinkedVE()CO NE;IN CRUI GetIndex()CO NE;IN CRUI RefIndex()NE;ST IN bool Equal(CO IteratorOfLinkedVE<T>&,CO IteratorOfLinkedVE<T>&)NE;ST IN bool Equal(CO COIteratorOfLinkedVE<T>&,CO IteratorOfLinkedVE<T>&)NE;ST IN bool Equal(CO IteratorOfLinkedVE<T>&,CO COIteratorOfLinkedVE<T>&)NE;ST IN bool Equal(CO COIteratorOfLinkedVE<T>&,CO COIteratorOfLinkedVE<T>&)NE;};
TE <TY T> IN IteratorOfLinkedVE<T>::IteratorOfLinkedVE(LinkedVE<T>* CO& p,CRUI i)NE:m_p(p),m_i(i){}TE <TY T> IN IteratorOfLinkedVE<T>::IteratorOfLinkedVE(CO IteratorOfLinkedVE<T>& IT)NE:m_p(IT.m_p),m_i(IT.m_i){}TE <TY T> IN T& IteratorOfLinkedVE<T>::OP*()CO{RE(*m_p)[m_i];}TE <TY T> IN T* IteratorOfLinkedVE<T>::OP->()CO{RE &((*m_p)[m_i]);}TE <TY T> IN IteratorOfLinkedVE<T>& IteratorOfLinkedVE<T>::OP=(CO IteratorOfLinkedVE<T>& IT)NE{m_p = IT.m_p;m_i = IT.m_i;RE *TH;}TE <TY T> IN VO IteratorOfLinkedVE<T>::OP++(int){m_i = m_p->m_entry[m_i].m_next_entry;}TE <TY T> IN VO IteratorOfLinkedVE<T>::OP--(int){m_i = m_p->m_entry[m_i].m_prev_entry;}TE <TY T> IN CO LinkedVE<T>& IteratorOfLinkedVE<T>::GetLinkedVE()CO NE{RE *m_p;}TE <TY T> IN LinkedVE<T>& IteratorOfLinkedVE<T>::RefLinkedVE()NE{RE *m_p;}TE <TY T> IN CRUI IteratorOfLinkedVE<T>::GetIndex()CO NE{RE m_i;}TE <TY T> IN CRUI IteratorOfLinkedVE<T>::RefIndex()NE{RE m_i;}TE <TY T> IN COIteratorOfLinkedVE<T>::COIteratorOfLinkedVE(CO LinkedVE<T>* CO& p,CRUI i)NE:m_p(p),m_i(i){}TE <TY T> IN COIteratorOfLinkedVE<T>::COIteratorOfLinkedVE(CO COIteratorOfLinkedVE<T>& IT)NE:m_p(IT.m_p),m_i(IT.m_i){}TE <TY T> IN COIteratorOfLinkedVE<T>::COIteratorOfLinkedVE(CO IteratorOfLinkedVE<T>& IT)NE:m_p(IT.m_p),m_i(IT.m_i){}TE <TY T> IN CO T& COIteratorOfLinkedVE<T>::OP*()CO{RE(*m_p)[m_i];}TE <TY T> IN CO T* COIteratorOfLinkedVE<T>::OP->()CO{RE &((*m_p)[m_i]);}TE <TY T>COIteratorOfLinkedVE<T>& COIteratorOfLinkedVE<T>::OP=(CO COIteratorOfLinkedVE<T>& IT)NE{m_p = IT.m_p;m_i = IT.m_i;RE *TH;}TE <TY T>COIteratorOfLinkedVE<T>& COIteratorOfLinkedVE<T>::OP=(CO IteratorOfLinkedVE<T>& IT)NE{m_p = IT.m_p;m_i = IT.m_i;RE *TH;}TE <TY T> IN VO COIteratorOfLinkedVE<T>::OP++(int){m_i = m_p->m_entry[m_i].m_next_entry;}TE <TY T> IN VO COIteratorOfLinkedVE<T>::OP--(int){m_i = m_p->m_entry[m_i].m_prev_entry;}TE <TY T> IN CO LinkedVE<T>& COIteratorOfLinkedVE<T>::GetLinkedVE()CO NE{RE *m_p;}TE <TY T> IN CRUI COIteratorOfLinkedVE<T>::GetIndex()CO NE{RE m_i;}TE <TY T> IN CRUI COIteratorOfLinkedVE<T>::RefIndex()NE{RE m_i;}TE <TY T> IN bool COIteratorOfLinkedVE<T>::Equal(CO IteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE IT0.m_p == IT1.m_p && IT0.m_i == IT1.m_i;}TE <TY T> IN bool COIteratorOfLinkedVE<T>::Equal(CO COIteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE IT0.m_p == IT1.m_p && IT0.m_i == IT1.m_i;}TE <TY T> IN bool COIteratorOfLinkedVE<T>::Equal(CO IteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE IT0.m_p == IT1.m_p && IT0.m_i == IT1.m_i;}TE <TY T> IN bool COIteratorOfLinkedVE<T>::Equal(CO COIteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE IT0.m_p == IT1.m_p && IT0.m_i == IT1.m_i;}TE <TY T> IN bool OP==(CO IteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE COIteratorOfLinkedVE<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO IteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO COIteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE COIteratorOfLinkedVE<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO COIteratorOfLinkedVE<T>& IT0,CO IteratorOfLinkedVE<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO IteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE COIteratorOfLinkedVE<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO IteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE !(IT0 == IT1);}TE <TY T> IN bool OP==(CO COIteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE COIteratorOfLinkedVE<T>::Equal(IT0,IT1);}TE <TY T> IN bool OP!=(CO COIteratorOfLinkedVE<T>& IT0,CO COIteratorOfLinkedVE<T>& IT1)NE{RE !(IT0 == IT1);}
TE <TY T>CL LinkedVE{PU:VE<EntryOfLinkedVE<T> > m_entry;uint m_front_linked_entry;uint m_back_linked_entry;uint m_SZ_of_VE;uint m_SZ_of_link;IN LinkedVE();IN LinkedVE(CRUI max_SZ);IN CO T& OP[](CRUI i)CO;IN T& OP[](CRUI i);uint GetLinkedEntry(CRUI i)CO;IN CRUI GetFrontLinkedEntryIndex()CO NE;IN CRUI GetBackLinkedEntryIndex()CO NE;IN CRUI GetSZOfVE()CO NE;IN CRUI GetSZOfLink()CO NE;IN bool EmptyVE()CO NE;IN bool EmptyLink()CO NE;IN VO push_back();TE <TY U> VO push_back(CO U& u);TE <TY U,TY... ARGS> IN VO push_back(CO U& u,CO ARGS&... args);IN VO SetPreviousLink(CRUI i,CRUI j);IN VO SetNexttLink(CRUI i,CRUI j);IN CRUI GetPreviousLinkIndex(CRUI i)CO;IN CRUI GetNexttLinkIndex(CRUI i)CO;CRUI DeLink(CRUI i);VO ReLink(CRUI i);US iterator = IteratorOfLinkedVE<T>;US CO_iterator = COIteratorOfLinkedVE<T>;IN iterator GetIterator(CRUI i)NE;IN CO_iterator GetIterator(CRUI i)CO NE;IN iterator BE()NE;IN CO_iterator BE()CO NE;IN iterator EN()NE;IN CO_iterator EN()CO NE;iterator erase(iterator& IT);IN EntryOfLinkedVE<T>& push_back_Body_0();IN VO push_back_Body_1(EntryOfLinkedVE<T>& e);};
TE <TY T> IN LinkedVE<T>::LinkedVE(): m_entry(1),m_front_linked_entry(0),m_back_linked_entry(0),m_SZ_of_VE(0),m_SZ_of_link(0){}TE <TY T> IN LinkedVE<T>::LinkedVE(CRUI max_SZ): m_entry(),m_front_linked_entry(0),m_back_linked_entry(0),m_SZ_of_VE(0),m_SZ_of_link(0){m_entry.reserve(max_SZ + 1);m_entry.push_back(EntryOfLinkedVE<T>());}TE <TY T> IN CO T& LinkedVE<T>::OP[](CRUI i)CO{RE m_entry[i].m_t;}TE <TY T> IN T& LinkedVE<T>::OP[](CRUI i){RE m_entry[i].m_t;}TE <TY T>uint LinkedVE<T>::GetLinkedEntry(CRUI i)CO{uint linked_entry = m_front_linked_entry;for(uint j = 0;j < i;j++){linked_entry = m_entry[linked_entry].m_next_entry;}RE linked_entry;}TE <TY T> IN CRUI LinkedVE<T>::GetFrontLinkedEntryIndex()CO NE{RE m_front_linked_entry;}TE <TY T> IN CRUI LinkedVE<T>::GetBackLinkedEntryIndex()CO NE{RE m_back_linked_entry;}TE <TY T> IN CRUI LinkedVE<T>::GetSZOfVE()CO NE{RE m_SZ_of_VE;}TE <TY T> IN CRUI LinkedVE<T>::GetSZOfLink()CO NE{RE m_SZ_of_link;}TE <TY T> IN bool LinkedVE<T>::EmptyVE()CO NE{RE m_SZ_of_VE == 0;}TE <TY T> IN bool LinkedVE<T>::EmptyLink()CO NE{RE m_SZ_of_link == 0;}TE <TY T> IN VO LinkedVE<T>::push_back(){}TE <TY T> TE <TY U>VO LinkedVE<T>::push_back(CO U& u){EntryOfLinkedVE<T>& e = push_back_Body_0();e.m_t = u;push_back_Body_1(e);RE;}TE <TY T> TE <TY U,TY... ARGS> IN VO LinkedVE<T>::push_back(CO U& u,CO ARGS&... args){push_back(u);push_back(args...);}TE <TY T> IN EntryOfLinkedVE<T>& LinkedVE<T>::push_back_Body_0(){m_entry.push_back(EntryOfLinkedVE<T>(m_SZ_of_VE,m_front_linked_entry));RE m_entry[m_SZ_of_VE];}TE <TY T> IN VO LinkedVE<T>::push_back_Body_1(EntryOfLinkedVE<T>& e){e.m_next_entry = m_SZ_of_VE + 1;m_entry[m_front_linked_entry].m_prev_entry = m_SZ_of_VE + 1;m_back_linked_entry = m_SZ_of_VE;m_SZ_of_VE++;m_SZ_of_link++;}TE <TY T> IN VO LinkedVE<T>::SetPreviousLink(CRUI i,CRUI j){m_entry[i].m_prev_entry = j;}TE <TY T> IN VO LinkedVE<T>::SetNexttLink(CRUI i,CRUI j){m_entry[i].m_next_entry = j;}TE <TY T> IN CRUI LinkedVE<T>::GetPreviousLinkIndex(CRUI i)CO{RE m_entry[i].m_prev_entry;}TE <TY T> IN CRUI LinkedVE<T>::GetNexttLinkIndex(CRUI i)CO{RE m_entry[i].m_next_entry;}TE <TY T>CRUI LinkedVE<T>::DeLink(CRUI i){CO EntryOfLinkedVE<T>& e = m_entry[i];m_entry[e.m_prev_entry].m_next_entry = e.m_next_entry;m_entry[e.m_next_entry].m_prev_entry = e.m_prev_entry;if(m_front_linked_entry == i){m_front_linked_entry = e.m_next_entry;}if(m_back_linked_entry == i){m_back_linked_entry = e.m_prev_entry;}m_SZ_of_link--;RE e.m_next_entry;}TE <TY T>VO LinkedVE<T>::ReLink(CRUI i){EntryOfLinkedVE<T>& current_entry = m_entry[i];if(m_SZ_of_link == 0){EntryOfLinkedVE<T>& EN_entry = m_entry[m_SZ_of_VE];EN_entry.m_prev_entry = EN_entry.m_next_entry = i;current_entry.m_prev_entry = current_entry.m_next_entry = m_SZ_of_VE;m_front_linked_entry = m_back_linked_entry = i;}else{uint prev;if(m_front_linked_entry > i){m_front_linked_entry = i;prev = m_SZ_of_VE;}else{prev = m_front_linked_entry;}if(m_back_linked_entry < i){m_back_linked_entry = i;}prev = m_entry[prev].m_next_entry;WH(prev < i){prev = m_entry[prev].m_next_entry;}CO uint next = prev;EntryOfLinkedVE<T>& next_entry = m_entry[next];prev = next_entry.m_prev_entry;EntryOfLinkedVE<T>& prev_entry = m_entry[prev];prev_entry.m_next_entry = i;current_entry.m_prev_entry = prev;current_entry.m_next_entry = next;next_entry.m_prev_entry = i;}m_SZ_of_link++;RE;}TE <TY T> IN TY LinkedVE<T>::iterator LinkedVE<T>::GetIterator(CRUI i)NE{RE TY LinkedVE<T>::iterator(TH,i);}TE <TY T> IN TY LinkedVE<T>::CO_iterator LinkedVE<T>::GetIterator(CRUI i)CO NE{RE TY LinkedVE<T>::CO_iterator(TH,i);}TE <TY T> IN TY LinkedVE<T>::iterator LinkedVE<T>::BE()NE{RE TY LinkedVE<T>::iterator(TH,m_front_linked_entry);}TE <TY T> IN TY LinkedVE<T>::CO_iterator LinkedVE<T>::BE()CO NE{RE TY LinkedVE<T>::CO_iterator(TH,m_front_linked_entry);}TE <TY T> IN TY LinkedVE<T>::iterator LinkedVE<T>::EN()NE{RE TY LinkedVE<T>::iterator(TH,m_SZ_of_VE);}TE <TY T> IN TY LinkedVE<T>::CO_iterator LinkedVE<T>::EN()CO NE{RE TY LinkedVE<T>::CO_iterator(TH,m_SZ_of_VE);}TE <TY T> TY LinkedVE<T>::iterator LinkedVE<T>::erase(TY LinkedVE<T>::iterator& IT){RE TY LinkedVE<T>::iterator(TH,DeLink(IT.m_i));}
TE <TY T>CL EntryOfUnionFindForest{PU:VLSubTree<T> m_node;uint m_pred_node;uint m_root;uint m_depth;IN EntryOfUnionFindForest();IN EntryOfUnionFindForest(CO T& t,CRUI num);IN EntryOfUnionFindForest(EntryOfUnionFindForest&& e);};TE <TY T> IN EntryOfUnionFindForest<T>::EntryOfUnionFindForest(): m_node(),m_pred_node(0),m_root(0),m_depth(0){}TE <TY T> IN EntryOfUnionFindForest<T>::EntryOfUnionFindForest(CO T& t,CRUI num): m_node(),m_pred_node(num),m_root(num),m_depth(0){m_node.SetRoot(t);}TE <TY T> IN EntryOfUnionFindForest<T>::EntryOfUnionFindForest(EntryOfUnionFindForest<T>&& e): m_node(),m_pred_node(MO(e.m_pred_node)),m_root(MO(e.m_root)),m_depth(MO(e.m_depth)){m_node.SetRoot(MO(e.m_node.m_p_root->m_t));}
TE <TY T=char>CL UnionFindForest:PU LinkedVE<EntryOfUnionFindForest<T> >{PU:IN UnionFindForest(CRUI max_SZ);IN UnionFindForest(CRUI max_SZ,CRUI SZ);IN CO VLSubTree<T>& GetSubTree(CRUI num)CO;IN CRUI GetPredecessorNode(CRUI num)CO;CRUI GetRootOfNode(CRUI num);uint GetRoot(CRUI num)CO;TE <TE <TY...> TY V> VO SetRoot(V<uint>&a)CO;IN CO T& OP[](CRUI num)CO;IN T& OP[](CRUI num);IN CRUI GetSZOfNode()CO NE;IN CRUI GetSZOfRoot()CO NE;IN VO push_RightMost();VO push_RightMost(CO T& t);TE <TY... ARGS> IN VO push_RightMost(CO T& t,CO ARGS&... args);IN VO push_back()= delete;TE <TY U> VO push_back(CO U& u)= delete;TE <TY U,TY... ARGS> IN VO push_back(CO U& u,CO ARGS&... args)= delete;IN VO SetPreviousLink(CRUI i,CRUI j)= delete;IN VO SetNexttLink(CRUI i,CRUI j)= delete;IN CRUI GetPreviousLinkIndex(CRUI i)CO = delete;IN CRUI GetNexttLinkIndex(CRUI i)CO = delete;CRUI DeLink(CRUI i)= delete;VO ReLink(CRUI i)= delete;VO Graft(CRUI num0,CRUI num1);};
TE <TY T> IN UnionFindForest<T>::UnionFindForest(CRUI max_SZ): LinkedVE<EntryOfUnionFindForest<T> >(max_SZ){}TE <TY T> IN UnionFindForest<T>::UnionFindForest(CRUI max_SZ,CRUI SZ): UnionFindForest(max_SZ){T t{};for(int i=0;i<SZ;i++){push_RightMost(t);}}TE <TY T> IN CO VLSubTree<T>& UnionFindForest<T>::GetSubTree(CRUI num)CO{RE LinkedVE<EntryOfUnionFindForest<T> >::OP[](num).m_node;}TE <TY T> IN CRUI UnionFindForest<T>::GetPredecessorNode(CRUI num)CO{RE LinkedVE<EntryOfUnionFindForest<T> >::OP[](num).m_pred_node;}TE <TY T>CRUI UnionFindForest<T>::GetRootOfNode(CRUI num){uint& root = LinkedVE<EntryOfUnionFindForest<T> >::OP[](num).m_root;if(root != LinkedVE<EntryOfUnionFindForest<T> >::OP[](root).m_root){root = GetRootOfNode(root);}RE root;}TE <TY T>uint UnionFindForest<T>::GetRoot(CRUI num)CO{auto IT = LinkedVE<EntryOfUnionFindForest<T> >::BE();for(uint i = 0;i < num;i++){IT++;}RE IT.GetIndex();}TE <TY T> TE <TE <TY...> TY V>VO UnionFindForest<T>::SetRoot(V<uint>&a)CO{a.clear();for(auto IT = LinkedVE<EntryOfUnionFindForest<T> >::BE(),EN = LinkedVE<EntryOfUnionFindForest<T> >::EN();IT != EN;IT++){a.push_back(IT.GetIndex());}RE;}TE <TY T> IN CO T& UnionFindForest<T>::OP[](CRUI num)CO{RE LinkedVE<EntryOfUnionFindForest<T> >::OP[](num).m_node.GetRoot();}TE <TY T> IN T& UnionFindForest<T>::OP[](CRUI num){RE LinkedVE<EntryOfUnionFindForest<T> >::OP[](num).m_node.RefRoot();}TE <TY T> IN CRUI UnionFindForest<T>::GetSZOfNode()CO NE{RE LinkedVE<EntryOfUnionFindForest<T> >::GetSZOfVE();}TE <TY T> IN CRUI UnionFindForest<T>::GetSZOfRoot()CO NE{RE LinkedVE<EntryOfUnionFindForest<T> >::GetSZOfLink();}TE <TY T> IN VO UnionFindForest<T>::push_RightMost(){}TE <TY T>VO UnionFindForest<T>::push_RightMost(CO T& t){EntryOfLinkedVE<EntryOfUnionFindForest<T> >& e = LinkedVE<EntryOfUnionFindForest<T> >::push_back_Body_0();e.m_t.m_node.SetRoot(t);e.m_t.m_pred_node = e.m_t.m_root = LinkedVE<EntryOfUnionFindForest<T> >::m_SZ_of_VE;LinkedVE<EntryOfUnionFindForest<T> >::push_back_Body_1(e);RE;}TE <TY T> TE <TY... ARGS> IN VO UnionFindForest<T>::push_RightMost(CO T& t,CO ARGS&... args){push_RightMost(t);push_RightMost(args...);}TE <TY T>VO UnionFindForest<T>::Graft(CRUI num0,CRUI num1){CRUI e0_root_index = GetRootOfNode(num0);CRUI e1_root_index = GetRootOfNode(num1);if(e0_root_index == e1_root_index){RE;}EntryOfUnionFindForest<T>& e0_root = LinkedVE<EntryOfUnionFindForest<T> >::OP[](e0_root_index);EntryOfUnionFindForest<T>& e1_root = LinkedVE<EntryOfUnionFindForest<T> >::OP[](e1_root_index);CO uint i0 =(e0_root.m_depth < e1_root.m_depth?0:1);CO uint i1 = 1 - i0;EntryOfUnionFindForest<T>* CO p_e_root[2] ={&e0_root,&e1_root};EntryOfUnionFindForest<T>& root_0 = *(p_e_root[i0]);EntryOfUnionFindForest<T>& root_1 = *(p_e_root[i1]);if(root_0.m_depth == root_1.m_depth){root_1.m_depth++;}root_1.m_node.Graft(root_0.m_node);LinkedVE<EntryOfUnionFindForest<T> >::DeLink(root_0.m_root);root_0.m_root = root_0.m_pred_node = root_1.m_root;RE;}
