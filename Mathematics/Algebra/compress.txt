TE <TY U>CL VirtualPointedSet{PU:virtual CO U& Point()CO NE = 0;IN CO U& Unit()CO NE;IN CO U& Zero()CO NE;IN CO U& One()CO NE;IN CO U& Infty()CO NE;IN CO U& SZ()CO NE;};TE <TY U>CL PointedSet:virtual PU VirtualPointedSet<U>{PU:U m_b_U;IN PointedSet(CO U& b_u = U());IN CO U& Point()CO NE;};TE <TY U>CL VirtualNSet{PU:virtual U Transfer(CO U& u)= 0;IN U Inverse(CO U& u);};TE <TY U,TY F_U>CL AbstractNSet:virtual PU VirtualNSet<U>{PU:F_U m_f_U;IN AbstractNSet(F_U f_U);IN U Transfer(CO U& u);};TE <TY U>CL VirtualMagma{PU:virtual U Product(CO U& u0,CO U& u1)= 0;IN U Sum(CO U& u0,CO U& u1);};TE <TY U,TY M_U>CL AbstractMagma:virtual PU VirtualMagma<U>{PU:M_U m_m_U;IN AbstractMagma(M_U m_U);IN U Product(CO U& u0,CO U& u1);};
TE <TY U> IN PointedSet<U>::PointedSet(CO U& b_U):m_b_U(b_U){}TE <TY U> IN CO U& PointedSet<U>::Point()CO NE{RE m_b_U;}TE <TY U> IN CO U& VirtualPointedSet<U>::Unit()CO NE{RE Point();}TE <TY U> IN CO U& VirtualPointedSet<U>::Zero()CO NE{RE Point();}TE <TY U> IN CO U& VirtualPointedSet<U>::One()CO NE{RE Point();}TE <TY U> IN CO U& VirtualPointedSet<U>::Infty()CO NE{RE Point();}TE <TY U> IN CO U& VirtualPointedSet<U>::SZ()CO NE{RE Point();}TE <TY U,TY F_U> IN AbstractNSet<U,F_U>::AbstractNSet(F_U f_U):m_f_U(MO(f_U)){ST_AS(is_invocable_r_v<U,F_U,U>);}TE <TY U,TY F_U> IN U AbstractNSet<U,F_U>::Transfer(CO U& u){RE m_f_U(u);}TE <TY U> IN U VirtualNSet<U>::Inverse(CO U& u){RE Transfer(u);}TE <TY U,TY M_U> IN AbstractMagma<U,M_U>::AbstractMagma(M_U m_U):m_m_U(MO(m_U)){ST_AS(is_invocable_r_v<U,M_U,U,U>);}TE <TY U,TY M_U> IN U AbstractMagma<U,M_U>::Product(CO U& u0,CO U& u1){RE m_m_U(u0,u1);}TE <TY U> IN U VirtualMagma<U>::Sum(CO U& u0,CO U& u1){RE Product(u0,u1);}

TE <TY U>CL VirtualMonoid:virtual PU VirtualMagma<U>,virtual PU VirtualPointedSet<U>{};TE <TY U = ll>CL AdditiveMonoid:virtual PU VirtualMonoid<U>,PU PointedSet<U>{PU:IN U Product(CO U& u0,CO U& u1);};TE <TY U = ll>CL MultiplicativeMonoid:virtual PU VirtualMonoid<U>,PU PointedSet<U>{PU:IN MultiplicativeMonoid(CO U& e_U);IN U Product(CO U& u0,CO U& u1);};TE <TY U,TY M_U>CL AbstractMonoid:virtual PU VirtualMonoid<U>,PU AbstractMagma<U,M_U>,PU PointedSet<U>{PU:IN AbstractMonoid(M_U m_U,CO U& e_U);IN U Product(CO U& u0,CO U& u1);};
TE <TY U> IN MultiplicativeMonoid<U>::MultiplicativeMonoid(CO U& e_U):PointedSet<U>(e_U){}TE <TY U,TY M_U> IN AbstractMonoid<U,M_U>::AbstractMonoid(M_U m_U,CO U& e_U):AbstractMagma<U,M_U>(MO(m_U)),PointedSet<U>(e_U){}TE <TY U> IN U AdditiveMonoid<U>::Product(CO U& u0,CO U& u1){RE u0 + u1;}TE <TY U> IN U MultiplicativeMonoid<U>::Product(CO U& u0,CO U& u1){RE u0 * u1;}TE <TY U,TY M_U> IN U AbstractMonoid<U,M_U>::Product(CO U& u0,CO U& u1){RE m_m_U(u0,u1);}

TE <TY U>CL VirtualGroup:virtual PU VirtualMonoid<U>,virtual PU VirtualPointedSet<U>,virtual PU VirtualNSet<U>{};TE <TY U = ll>CL AdditiveGroup:virtual PU VirtualGroup<U>,PU AdditiveMonoid<U>{PU:IN U Transfer(CO U& u);};TE <TY U,TY M_U,TY I_U>CL AbstractGroup:virtual PU VirtualGroup<U>,PU AbstractMonoid<U,M_U>,PU AbstractNSet<U,I_U>{PU:IN AbstractGroup(M_U m_U,CO U& e_U,I_U i_U);IN U Transfer(CO U& u);};TE <TY U,TY M_U,TY I_U> IN AbstractGroup<U,M_U,I_U>::AbstractGroup(M_U m_U,CO U& e_U,I_U i_U):AbstractMonoid<U,M_U>(MO(m_U),e_U),AbstractNSet<U,I_U>(MO(i_U)){}TE <TY U,TY M_U,TY I_U> IN U AbstractGroup<U,M_U,I_U>::Transfer(CO U& u){RE m_i_U(u);}TE <TY U> IN U AdditiveGroup<U>::Transfer(CO U& u){RE -u;}

TE <TY U,TY GROUP,TY MONOID>CL VirtualRing{PU:GROUP m_R0;MONOID m_R1;IN VirtualRing(GROUP R0,MONOID R1);IN U Sum(CO U& u0,CO U& u1);IN CO U& Zero()CO NE;IN U Inverse(CO U& u);IN U Product(CO U& u0,CO U& u1);IN CO U& One()CO NE;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY U = ll>CL Ring:virtual PU VirtualRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(CO U& one_U);};TE <TY U,TY A_U,TY I_U,TY M_U>CL AbstractRing:virtual PU VirtualRing<U,AbstractGroup<U,A_U,I_U>,AbstractMonoid<U,M_U>>{PU:IN AbstractRing(A_U a_U,CO U& z_U,I_U i_U,M_U m_U,CO U& e_U);};
TE <TY U,TY GROUP,TY MONOID> IN VirtualRing<U,GROUP,MONOID>::VirtualRing(GROUP R0,MONOID R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Ring<U>::Ring(CO U& one_U):VirtualRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(one_U)){}TE <TY U,TY A_U,TY I_U,TY M_U> IN AbstractRing<U,A_U,I_U,M_U>::AbstractRing(A_U a_U,CO U& z_U,I_U i_U,M_U m_U,CO U& e_U):VirtualRing<U,AbstractGroup<U,A_U,I_U>,AbstractMonoid<U,M_U>>(AbstractGroup<U,A_U,I_U>(MO(a_U),z_U,MO(i_U)),AbstractMonoid<U,M_U>(MO(m_U),e_U)){}TE <TY U,TY GROUP,TY MONOID> IN U VirtualRing<U,GROUP,MONOID>::Sum(CO U& u0,CO U& u1){RE m_R0.Sum(u0,u1);}TE <TY U,TY GROUP,TY MONOID> IN CO U& VirtualRing<U,GROUP,MONOID>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY GROUP,TY MONOID> IN U VirtualRing<U,GROUP,MONOID>::Inverse(CO U& u){RE m_R0.Inverse(u);}TE <TY U,TY GROUP,TY MONOID> IN U VirtualRing<U,GROUP,MONOID>::Product(CO U& u0,CO U& u1){RE m_R1.Product(u0,u1);}TE <TY U,TY GROUP,TY MONOID> IN CO U& VirtualRing<U,GROUP,MONOID>::One()CO NE{RE m_R1.One();}TE <TY U,TY GROUP,TY MONOID> IN GROUP& VirtualRing<U,GROUP,MONOID>::AdditiveGroup()NE{RE m_R0;}TE <TY U,TY GROUP,TY MONOID> IN MONOID& VirtualRing<U,GROUP,MONOID>::MultiplicativeMonoid()NE{RE m_R1;}
