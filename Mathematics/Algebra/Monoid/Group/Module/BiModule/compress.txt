#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Algebra/Monoid/Group/Module/BiModule/a_Body.hpp"
#else
TE <TY L,TY R,TY U>CL VirtualBiModule:VI PU UnderlyingSet<U>{PU:VI U LAction(CO L& l,U u)= 0;VI U RAction(U u,CO R& r)= 0;IN U ScalarProduct(CO L& l,U u);IN U PW(U u,CO R& r);};TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP>CL AbstractBiModule:PU VirtualBiModule<L,R,U>,PU GROUP{PU:O_U_L m_o_U_L;O_U_R m_o_U_R;IN AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M);IN AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>& OP=(CO AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>&)NE;IN U LAction(CO L& l,U u);IN U RAction(U u,CO R& r);};TE <TY L,TY R,TY O_U_L,TY O_U_R,TY GROUP> AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M)-> AbstractBiModule<L,R,inner_t<GROUP>,O_U_L,O_U_R,GROUP>;TE <TY L,TY R,TY U>CL BiModule:VI PU VirtualBiModule<L,R,U>,PU AdditiveGroup<U>{PU:IN U LAction(CO L& r,U u);IN U RAction(U u,CO R& r);};
TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M):GROUP(MO(M)),m_o_U_L(MO(o_U_L)),m_o_U_R(MO(o_U_R)){ST_AS(is_same_v<U,inner_t<GROUP>> && is_invocable_r_v<U,O_U_L,CO L&,U> && is_invocable_r_v<U,O_U_R,U,CO R&>);}TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN U AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::LAction(CO L& l,U u){RE m_o_U_L(l,MO(u));}TE <TY L,TY R,TY U> IN U BiModule<L,R,U>::LAction(CO L& l,U u){RE MO(u *= l);}TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN U AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::RAction(U u,CO R& r){RE m_o_U_R(MO(u),r);}TE <TY L,TY R,TY U> IN U BiModule<L,R,U>::RAction(U u,CO R& r){RE MO(u *= r);}TE <TY L,TY R,TY U> IN U VirtualBiModule<L,R,U>::ScalarProduct(CO L& l,U u){RE LAction(l,MO(u));}TE <TY L,TY R,TY U> IN U VirtualBiModule<L,R,U>::PW(U u,CO R& r){RE RAction(MO(u),r);}
#endif

