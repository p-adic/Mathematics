#define SET_MA_MULTIPOINT_EVALUATION(SAMPLE_NUM_MAX,FINAL_LENGTH,POINT) point = VE<T>(SAMPLE_NUM_MAX + 1);for(UI t = 0;t <= SAMPLE_NUM_MAX;t++){point[t] = POINT;} LI<LI<PO<T> > > pt{};SetPointTree(point,pt);VE<T> eval[Y][Y] = {};for(UI y = 0;y < Y;y++){CO VE<PO<T> >& M_ref_y = M_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(UI x = 0;x < Y;x++){SetPointTreeEvaluation(M_ref_y[x],pt,eval_y[x]);}} VE<MA<Y,Y,T> > sample(SAMPLE_NUM_MAX + 1,MA<Y,Y,T>::Zero());sample.reserve(FINAL_LENGTH);for(UI t = 0;t <= SAMPLE_NUM_MAX;t++){VE<VE<T> >& sample_t_ref = sample[t].RefTable();for(UI y = 0;y < Y;y++){VE<T>& sample_t_ref_y = sample_t_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(UI x = 0;x < Y;x++){sample_t_ref_y[x] = eval_y[x][t];}}} 
#define MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(REST_INTERVAL_LENGTH) VE<MA<Y,Y,T> > eval_odd{};VE<MA<Y,Y,T> > eval_even{};SetIntervalEvaluation(subinterval_num_max,subinterval_length / interval_length,REST_INTERVAL_LENGTH + subinterval_num_max + 1,sample,eval_odd);SetIntervalEvaluation(subinterval_num_max,T(subinterval_num_max + 1),REST_INTERVAL_LENGTH,sample,eval_even);for(UI t = 0;t <= subinterval_num_max;t++){sample[t] = eval_odd[t] * sample[t];} for(UI t = 0;t < REST_INTERVAL_LENGTH;t++){sample.push_back(eval_odd[t + subinterval_num_max + 1] * eval_even[t]);} 
TE <TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI length,VE<T>& eval);TE <UI Y,UI X,TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI length,CO VE<MA<Y,X,T> >& sample,VE<MA<Y,X,T> >& eval);TE <UI Y,TY T>VO SetPRecursiveMAAction(CO MA<Y,Y,PO<T> >& M,MA<Y,1,T>& v,CRUI length);TE <TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI length,VE<T>& eval){for(UI d = 0;d <= deg;d++){eval[d] *= PO<T>::factorial_inverse(d);} VE<T> v{};v.swap(eval);TRPO<T> f{deg + 1,MO(v)};ST PO<T> exp_inv{};for(UI d = exp_inv.SZ();d <= deg;d++){exp_inv[d] = (d % 2 == 0 ? PO<T>::factorial_inverse(d):- PO<T>::factorial_inverse(d));} f *= exp_inv;f.ReMORedundantZero();UI deg_f = f.SZ();if(deg_f == 0){eval = VE<T>(length,PO<T>::CO_zero());RE;} f.SetTruncation(deg_f);deg_f--;for(UI d = 0;d <= deg_f;d++){f[d] *= PO<T>::factorial(d);} UI deg_f_half = (deg_f + 1) / 2;for(UI d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);} PO<T> exp_t_Mahler{};T t_Mahler = PO<T>::CO_one();for(UI d = 0;d <= deg_f;d++){exp_t_Mahler[d] = PO<T>::factorial_inverse(d) * t_Mahler;t_Mahler *= t_start - d;} f *= exp_t_Mahler;for(UI d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);} for(UI d = 0;d <= deg_f;d++){f[d] *= PO<T>::factorial_inverse(d);} f.SetTruncation(length);ST PO<T> exp{};for(UI d = exp.SZ();d < length;d++){exp[d] = PO<T>::factorial_inverse(d);} f *= exp;for(UI d = 0;d < length;d++){f[d] *= PO<T>::factorial(d);} f.swap(eval);RE;}TE <UI Y,UI X,TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI length,CO VE<MA<Y,X,T> >& sample,VE<MA<Y,X,T> >& eval){eval = VE<MA<Y,X,T> >(length,MA<Y,X,T>::Zero());VE<T> sample_copy[Y][X] = {};for(UI t = 0;t <= deg;t++){CO VE<VE<T> >& table = sample[t].GetTable();for(UI y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];CO VE<T>& table_y = table[y];for(UI x = 0;x < X;x++){sample_copy_y[x].push_back(table_y[x]);}}}  for(UI y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];for(UI x = 0;x < X;x++){VE<T>& sample_copy_yx = sample_copy_y[x];SetIntervalEvaluation(deg,t_start,length,sample_copy_yx);for(UI i = 0;i < length;i++){VE<VE<T> >& table = eval[i].RefTable();table[y][x] = sample_copy_yx[i];} }} RE;}TE <UI Y,TY T>VO SetPRecursiveMAAction(CO MA<Y,Y,PO<T> >& M,MA<Y,1,T>& v,CRUI length){if(length == 0){RE;} CO VE<VE<PO<T> > >& M_ref = M.GetTable();UI deg = 1;for(UI y = 0;y < Y;y++){CO VE<PO<T>>& M_ref_y = M_ref[y];for(UI x = 0;x < Y;x++){CRUI SZ = M_ref_y[x].SZ();if(deg < SZ){deg = SZ;} }} deg--;UI interval_length = 1;int exponent = 0;WH(interval_length * (interval_length * deg + 1) <= length){interval_length *= 2;exponent++;} interval_length /= 2;exponent--;UI interval_num_max;UI t_rest_start;VE<T> point{};if(exponent > 0){CO UI interval_num_lim = length / interval_length;interval_num_max = interval_num_lim - 1;t_rest_start = interval_length * interval_num_lim;UI subinterval_num_max = deg;T subinterval_length = PO<T>::CO_one();SET_MA_MULTIPOINT_EVALUATION(subinterval_num_max,interval_num_lim,t * interval_length);for(int e = 1;e < exponent;e++){MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(subinterval_num_max);subinterval_num_max *= 2;subinterval_length *= 2;} UI rest_interval_length = interval_num_max - subinterval_num_max;MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(rest_interval_length);for(UI t = 0;t <= interval_num_max;t++){v = sample[t] * v;}} else {interval_num_max = t_rest_start = 0;} if(t_rest_start < length){CO UI rest_num_lim = length - t_rest_start;CO UI rest_num_max = rest_num_lim - 1;SET_MA_MULTIPOINT_EVALUATION(rest_num_max,rest_num_lim,t + t_rest_start);for(UI t = 0;t <= rest_num_max;t++){v = sample[t] * v;}} RE;}
