#define SET_MA_MULTIPOINT_EVALUATION(SAMPLE_NUM_MAX,POINT) point = VE<T>(SAMPLE_NUM_MAX + 1); for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){ point[t] = POINT; } VE<T> eval[Y][Y] = {}; for(uint y = 0;y < Y;y++){ CO VE<PO<T> >& M_ref_y = M_ref[y]; VE<T> (&eval_y)[Y] = eval[y]; for(uint x = 0;x < Y;x++){ SetMultipointEvaluation(M_ref_y[x],point,eval_y[x]); } } VE<MA<Y,Y,T> > sample(SAMPLE_NUM_MAX + 1,MA<Y,Y,T>::Zero()); for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){ VE<VE<T> >& sample_t_ref = sample[t].RefTable(); for(uint y = 0;y < Y;y++){ VE<T>& sample_t_ref_y = sample_t_ref[y]; VE<T> (&eval_y)[Y] = eval[y]; for(uint x = 0;x < Y;x++){ sample_t_ref_y[x] = eval_y[x][t]; } } }
#define MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(REST_INTERVAL_LENGTH) VE<MA<Y,Y,T> > eval_odd{}; VE<MA<Y,Y,T> > eval_even{}; SetIntervalEvaluation(subinterval_num_max,subinterval_length / interval_length,REST_INTERVAL_LENGTH + subinterval_num_max + 1,sample,eval_odd); SetIntervalEvaluation(subinterval_num_max,T(subinterval_num_max + 1),REST_INTERVAL_LENGTH,sample,eval_even); for(uint t = 0;t <= subinterval_num_max;t++){ sample[t] = eval_odd[t] * sample[t]; } for(uint t = 0;t < REST_INTERVAL_LENGTH;t++){ sample.push_back(eval_odd[t + subinterval_num_max + 1] * eval_even[t]); }
TE <TY T>void SetIntervalEvaluation(CO uint& deg,CO T& t_start,CO uint& length,VE<T>& eval){for(uint d = 0;d <= deg;d++){eval[d] *= PO<T>::factorial_inverse(d);}VE<T> v{};v.swap(eval);TRPO<T> f{ deg + 1,MO(v) };ST PO<T> exp_inv{};for(uint d = exp_inv.SZ();d <= deg;d++){exp_inv[d] = (d % 2 == 0 ? PO<T>::factorial_inverse(d):- PO<T>::factorial_inverse(d));}f *= exp_inv;f.ReMORedundantZero();uint deg_f = f.SZ();if(deg_f == 0){eval = VE<T>(length,PO<T>::CO_zero());RE;}f.SetTruncation(deg_f);deg_f--;for(uint d = 0;d <= deg_f;d++){f[d] *= PO<T>::factorial(d);}uint deg_f_half = (deg_f + 1) / 2;for(uint d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}PO<T> exp_t_Mahler{};T t_Mahler = PO<T>::CO_one();for(uint d = 0;d <= deg_f;d++){exp_t_Mahler[d] = PO<T>::factorial_inverse(d) * t_Mahler;t_Mahler *= t_start - d;}f *= exp_t_Mahler;for(uint d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}for(uint d = 0;d <= deg_f;d++){f[d] *= PO<T>::factorial_inverse(d);}f.SetTruncation(length);ST PO<T> exp{};for(uint d = exp.SZ();d < length;d++){exp[d] = PO<T>::factorial_inverse(d);}f *= exp;for(uint d = 0;d < length;d++){f[d] *= PO<T>::factorial(d);}f.swap(eval);RE;}TE <uint Y,uint X,TY T>void SetIntervalEvaluation(CO uint& deg,CO T& t_start,CO uint& length,CO VE<MA<Y,X,T> >& sample,VE<MA<Y,X,T> >& eval){eval = VE<MA<Y,X,T> >(length,MA<Y,X,T>::Zero());VE<T> sample_copy[Y][X] = {};for(uint t = 0;t <= deg;t++){CO VE<VE<T> >& table = sample[t].GetTable();for(uint y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];CO VE<T>& table_y = table[y];for(uint x = 0;x < X;x++){sample_copy_y[x].push_back(table_y[x]);}}}for(uint y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];for(uint x = 0;x < X;x++){VE<T>& sample_copy_yx = sample_copy_y[x];SetIntervalEvaluation(deg,t_start,length,sample_copy_yx);for(uint i = 0;i < length;i++){VE<VE<T> >& table = eval[i].RefTable();table[y][x] = sample_copy_yx[i];}}}RE;}TE <uint Y,TY T>void SetPRecursiveMAAction(CO MA<Y,Y,PO<T> >& M,MA<Y,1,T>& v,CO uint& length){if(length == 0){RE;}CO VE<VE<PO<T> > >& M_ref = M.GetTable();uint deg = 1;for(uint y = 0;y < Y;y++){CO VE<PO<T>>& M_ref_y = M_ref[y];for(uint x = 0;x < Y;x++){CO uint SZ = M_ref_y[x].SZ();if(deg < SZ){deg = SZ;}}}deg--;uint interval_length = 1;int exponent = 0;WH(interval_length * (interval_length * deg + 1) < length){interval_length *= 2;exponent++;}interval_length /= 2;exponent--;uint interval_num_max;uint t_rest_start;VE<T> point{};if(interval_length > 0){interval_num_max = length / interval_length - 1;t_rest_start = interval_length * (interval_num_max + 1);uint subinterval_num_max = deg;T subinterval_length = PO<T>::CO_one();SET_MA_MULTIPOINT_EVALUATION(subinterval_num_max,t * interval_length);for(int e = 1;e < exponent;e++){MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(subinterval_num_max);subinterval_num_max *= 2;subinterval_length *= 2;}uint rest_interval_length = interval_num_max - subinterval_num_max;MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(rest_interval_length);for(uint t = 0;t <= interval_num_max;t++){v = sample[t] * v;}} else {interval_num_max = t_rest_start = 0;}if(t_rest_start < length){uint rest_num_max = length - t_rest_start - 1;SET_MA_MULTIPOINT_EVALUATION(rest_num_max,t + t_rest_start);for(uint t = 0;t <= rest_num_max;t++){v = sample[t] * v;}}RE;}