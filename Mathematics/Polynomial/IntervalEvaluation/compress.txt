#define SET_MA_MULTIPOINT_EVALUATION(SAMPLE_NUM_MAX,FINAL_LE,POINT) point = VE<T>(SAMPLE_NUM_MAX + 1);for(UI t = 0;t <= SAMPLE_NUM_MAX;t++){point[t] = POINT;}LI<LI<PO<T> > > pt{};SetPointTree(point,pt);VE<T> eval[Y][Y] ={};for(UI y = 0;y < Y;y++){CO VE<PO<T> >& M_ref_y = M_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(UI x = 0;x < Y;x++){SetPointTreeEvaluation(M_ref_y[x],pt,eval_y[x]);}}VE<MA<Y,Y,T> > sample(SAMPLE_NUM_MAX + 1,MA<Y,Y,T>::Zero());sample.reserve(FINAL_LE);for(UI t = 0;t <= SAMPLE_NUM_MAX;t++){VE<VE<T> >& sample_t_ref = sample[t].RefTable();for(UI y = 0;y < Y;y++){VE<T>& sample_t_ref_y = sample_t_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(UI x = 0;x < Y;x++){sample_t_ref_y[x] = eval_y[x][t];}}}
#define MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(REST_INTERVAL_LE) VE<MA<Y,Y,T> > eval_odd{};VE<MA<Y,Y,T> > eval_even{};SetIntervalEvaluation(subinterval_num_max,subinterval_LE / interval_LE,REST_INTERVAL_LE + subinterval_num_max + 1,sample,eval_odd);SetIntervalEvaluation(subinterval_num_max,T(subinterval_num_max + 1),REST_INTERVAL_LE,sample,eval_even);for(UI t = 0;t <= subinterval_num_max;t++){sample[t] = eval_odd[t] * sample[t];}for(UI t = 0;t < REST_INTERVAL_LE;t++){sample.push_back(eval_odd[t + subinterval_num_max + 1] * eval_even[t]);}
TE <TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI LE,VE<T>& eval){for(UI d = 0;d <= deg;d++){eval[d] *= T::FactorialInverse(d);}VE<T> v{};v.swap(eval);TRPO<T> f{deg + 1,MO(v)};ST PO<T> exp_inv{};for(UI d = exp_inv.SZ();d <= deg;d++){exp_inv[d] = (d % 2 == 0?T::FactorialInverse(d):- T::FactorialInverse(d));}f *= exp_inv;f.ReMORedundantZero();UI deg_f = f.SZ();if(deg_f == 0){eval = VE<T>(LE,PO<T>::CO_zero());RE;}f.SetTruncation(deg_f);deg_f--;for(UI d = 0;d <= deg_f;d++){f[d] *= T::Factorial(d);}UI deg_f_half = (deg_f + 1) / 2;for(UI d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}PO<T> exp_t_Mahler{};T t_Mahler = PO<T>::CO_one();for(UI d = 0;d <= deg_f;d++){exp_t_Mahler[d] = T::FactorialInverse(d) * t_Mahler;t_Mahler *= t_start - d;}f *= exp_t_Mahler;for(UI d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}for(UI d = 0;d <= deg_f;d++){f[d] *= T::FactorialInverse(d);}f.SetTruncation(LE);ST PO<T> exp{};for(UI d = exp.SZ();d < LE;d++){exp[d] = T::FactorialInverse(d);}f *= exp;for(UI d = 0;d < LE;d++){f[d] *= T::Factorial(d);}f.swap(eval);RE;}TE <UI Y,UI X,TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI LE,CO VE<MA<Y,X,T> >& sample,VE<MA<Y,X,T> >& eval){eval = VE<MA<Y,X,T> >(LE,MA<Y,X,T>::Zero());VE<T> sample_copy[Y][X] ={};for(UI t = 0;t <= deg;t++){CO VE<VE<T> >& table = sample[t].GetTable();for(UI y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];CO VE<T>& table_y = table[y];for(UI x = 0;x < X;x++){sample_copy_y[x].push_back(table_y[x]);}}}for(UI y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];for(UI x = 0;x < X;x++){VE<T>& sample_copy_yx = sample_copy_y[x];SetIntervalEvaluation(deg,t_start,LE,sample_copy_yx);for(UI i = 0;i < LE;i++){VE<VE<T> >& table = eval[i].RefTable();table[y][x] = sample_copy_yx[i];}}}RE;}TE <UI Y,TY T>VO SetPRecursiveMAAction(CO MA<Y,Y,PO<T> >& M,MA<Y,1,T>& v,CRUI LE){if(LE == 0){RE;}CO VE<VE<PO<T> > >& M_ref = M.GetTable();UI deg = 1;for(UI y = 0;y < Y;y++){CO VE<PO<T>>& M_ref_y = M_ref[y];for(UI x = 0;x < Y;x++){CRUI SZ = M_ref_y[x].SZ();if(deg < SZ){deg = SZ;}}}deg--;UI interval_LE = 1;int EX = 0;WH(interval_LE * (interval_LE * deg + 1) <= LE){interval_LE *= 2;EX++;}interval_LE /= 2;EX--;UI interval_num_max;UI t_rest_start;VE<T> point{};if(EX > 0){CO UI interval_num_lim = LE / interval_LE;interval_num_max = interval_num_lim - 1;t_rest_start = interval_LE * interval_num_lim;UI subinterval_num_max = deg;T subinterval_LE = PO<T>::CO_one();SET_MA_MULTIPOINT_EVALUATION(subinterval_num_max,interval_num_lim,t * interval_LE);for(int e = 1;e < EX;e++){MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(subinterval_num_max);subinterval_num_max *= 2;subinterval_LE *= 2;}UI rest_interval_LE = interval_num_max - subinterval_num_max;MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(rest_interval_LE);for(UI t = 0;t <= interval_num_max;t++){v = sample[t] * v;}}else{interval_num_max = t_rest_start = 0;}if(t_rest_start < LE){CO UI rest_num_lim = LE - t_rest_start;CO UI rest_num_max = rest_num_lim - 1;SET_MA_MULTIPOINT_EVALUATION(rest_num_max,rest_num_lim,t + t_rest_start);for(UI t = 0;t <= rest_num_max;t++){v = sample[t] * v;}}RE;}
