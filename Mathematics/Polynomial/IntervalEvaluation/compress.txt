#define SET_MA_MULTIPOINT_EVALUATION(SAMPLE_NUM_MAX,FINAL_LE,POINT) point = VE<T>(SAMPLE_NUM_MAX + 1);for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){point[t] = POINT;}LI<LI<PO<T> > > pt{};SetPointTree(point,pt);VE<T> eval[Y][Y] ={};for(uint y = 0;y < Y;y++){CO PO<T> (&M_ref_y)[Y] = M_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(uint x = 0;x < Y;x++){SetPointTreeEvaluation(M_ref_y[x],pt,eval_y[x]);}}VE<MA<Y,Y,T> > sample(SAMPLE_NUM_MAX + 1,MA<Y,Y,T>::Zero());sample.reserve(FINAL_LE);for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){T (&sample_t_ref)[Y][Y] = sample[t].RefTable();for(uint y = 0;y < Y;y++){T (&sample_t_ref_y)[Y] = sample_t_ref[y];VE<T> (&eval_y)[Y] = eval[y];for(uint x = 0;x < Y;x++){sample_t_ref_y[x] = eval_y[x][t];}}}
#define MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(REST_INTERVAL_LE) VE<MA<Y,Y,T> > eval_odd{};VE<MA<Y,Y,T> > eval_even{};SetIntervalEvaluation(subinterval_num_max,subinterval_LE / interval_LE,REST_INTERVAL_LE + subinterval_num_max + 1,sample,eval_odd);SetIntervalEvaluation(subinterval_num_max,T(subinterval_num_max + 1),REST_INTERVAL_LE,sample,eval_even);for(uint t = 0;t <= subinterval_num_max;t++){sample[t] = eval_odd[t] * sample[t];}for(uint t = 0;t < REST_INTERVAL_LE;t++){sample.push_back(eval_odd[t + subinterval_num_max + 1] * eval_even[t]);}
#define SET_TTMA_MULTIPOINT_EVALUATION(SAMPLE_NUM_MAX,FINAL_LE,POINT) point = VE<T>(SAMPLE_NUM_MAX + 1);for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){point[t] = POINT;}LI<LI<PO<T> > > pt{};SetPointTree(point,pt);VE<T> eval[2][2] ={};for(uint y = 0;y < 2;y++){VE<T> (&eval_y)[2] = eval[y];for(uint x = 0;x < 2;x++){SetPointTreeEvaluation(M.GetEntry(y,x),pt,eval_y[x]);}}VE<TTMA<T> > sample(SAMPLE_NUM_MAX + 1,TTMA<T>());sample.reserve(FINAL_LE);for(uint t = 0;t <= SAMPLE_NUM_MAX;t++){TTMA<T>& sample_t = sample[t];for(uint y = 0;y < 2;y++){VE<T> (&eval_y)[2] = eval[y];for(uint x = 0;x < 2;x++){sample_t.RefEntry(y,x) = eval_y[x][t];}}}
#define MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_TTMA(REST_INTERVAL_LE) VE<TTMA<T> > eval_odd{};VE<TTMA<T> > eval_even{};SetIntervalEvaluation(subinterval_num_max,subinterval_LE / interval_LE,REST_INTERVAL_LE + subinterval_num_max + 1,sample,eval_odd);SetIntervalEvaluation(subinterval_num_max,T(subinterval_num_max + 1),REST_INTERVAL_LE,sample,eval_even);for(uint t = 0;t <= subinterval_num_max;t++){sample[t] = eval_odd[t] * sample[t];}for(uint t = 0;t < REST_INTERVAL_LE;t++){sample.push_back(eval_odd[t + subinterval_num_max + 1] * eval_even[t]);}

TE <TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI LE,VE<T>& eval){for(uint d = 0;d <= deg;d++){eval[d] *= T::FactorialInverse(d);}VE<T> v{};v.swap(eval);TRPO<T> f{deg + 1,MO(v)};ST PO<T> exp_inv{};for(uint d = exp_inv.SZ();d <= deg;d++){exp_inv[d] = (d % 2 == 0?T::FactorialInverse(d):- T::FactorialInverse(d));}f *= exp_inv;f.ReMORedundantZero();uint deg_f = f.SZ();if(deg_f == 0){eval = VE<T>(LE,PO<T>::c_zero());RE;}f.SetTruncation(deg_f);deg_f--;for(uint d = 0;d <= deg_f;d++){f[d] *= T::Factorial(d);}uint deg_f_half = (deg_f + 1) / 2;for(uint d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}PO<T> exp_t_Mahler{};T t_Mahler = PO<T>::c_one();for(uint d = 0;d <= deg_f;d++){exp_t_Mahler[d] = T::FactorialInverse(d) * t_Mahler;t_Mahler *= t_start - d;}f *= exp_t_Mahler;for(uint d = 0;d < deg_f_half;d++){swap(f[d],f[deg_f - d]);}for(uint d = 0;d <= deg_f;d++){f[d] *= T::FactorialInverse(d);}f.SetTruncation(LE);ST PO<T> exp{};for(uint d = exp.SZ();d < LE;d++){exp[d] = T::FactorialInverse(d);}f *= exp;for(uint d = 0;d < LE;d++){f[d] *= T::Factorial(d);}f.swap(eval);RE;}TE <uint Y,uint X,TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI LE,CO VE<MA<Y,X,T> >& sample,VE<MA<Y,X,T> >& eval){eval = VE<MA<Y,X,T> >(LE,MA<Y,X,T>::Zero());VE<T> sample_copy[Y][X] ={};for(uint t = 0;t <= deg;t++){CO T (&table)[Y][Y] = sample[t].GetTable();for(uint y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];CO T (&table_y)[Y] = table[y];for(uint x = 0;x < X;x++){sample_copy_y[x].push_back(table_y[x]);}}}for(uint y = 0;y < Y;y++){VE<T> (&sample_copy_y)[X] = sample_copy[y];for(uint x = 0;x < X;x++){VE<T>& sample_copy_yx = sample_copy_y[x];SetIntervalEvaluation(deg,t_start,LE,sample_copy_yx);for(uint i = 0;i < LE;i++){T (&table)[Y][Y] = eval[i].RefTable();table[y][x] = sample_copy_yx[i];}}}RE;}TE <TY T>VO SetIntervalEvaluation(CRUI deg,CO T& t_start,CRUI LE,CO VE<TTMA<T> >& sample,VE<TTMA<T> >& eval){eval = VE<TTMA<T> >(LE,TTMA<T>());VE<T> sample_copy[2][2] ={};for(uint t = 0;t <= deg;t++){CO TTMA<T>& sample_t = sample[t];for(uint y = 0;y < 2;y++){VE<T> (&sample_copy_y)[2] = sample_copy[y];for(uint x = 0;x < 2;x++){sample_copy_y[x].push_back(sample_t.GetEntry(y,x));}}}for(uint y = 0;y < 2;y++){VE<T> (&sample_copy_y)[2] = sample_copy[y];for(uint x = 0;x < 2;x++){VE<T>& sample_copy_yx = sample_copy_y[x];SetIntervalEvaluation(deg,t_start,LE,sample_copy_yx);for(uint i = 0;i < LE;i++){eval[i].RefEntry(y,x) = sample_copy_yx[i];}}}RE;}TE <uint Y,TY T>VO SetPRecursiveMAAction(CO MA<Y,Y,PO<T> >& M,MA<Y,1,T>& v,CRUI LE){if(LE == 0){RE;}CO PO<T> (&M_ref)[Y][Y] = M.GetTable();uint deg = 1;for(uint y = 0;y < Y;y++){CO PO<T> (&M_ref_y)[Y] = M_ref[y];for(uint x = 0;x < Y;x++){CRUI SZ = M_ref_y[x].SZ();if(deg < SZ){deg = SZ;}}}deg--;uint interval_LE = 1;int EX = 0;WH(interval_LE * (interval_LE * deg + 1) <= LE){interval_LE *= 2;EX++;}interval_LE /= 2;EX--;uint interval_num_max;uint t_rest_start;VE<T> point{};if(EX > 0){CO uint interval_num_lim = LE / interval_LE;interval_num_max = interval_num_lim - 1;t_rest_start = interval_LE * interval_num_lim;uint subinterval_num_max = deg;T subinterval_LE = PO<T>::c_one();SET_MA_MULTIPOINT_EVALUATION(subinterval_num_max,interval_num_lim,t * interval_LE);for(int e = 1;e < EX;e++){MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(subinterval_num_max);subinterval_num_max *= 2;subinterval_LE *= 2;}uint rest_interval_LE = interval_num_max - subinterval_num_max;MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_MA(rest_interval_LE);for(uint t = 0;t <= interval_num_max;t++){v = sample[t] * v;}}else{interval_num_max = t_rest_start = 0;}if(t_rest_start < LE){CO uint rest_num_lim = LE - t_rest_start;CO uint rest_num_max = rest_num_lim - 1;SET_MA_MULTIPOINT_EVALUATION(rest_num_max,rest_num_lim,t + t_rest_start);for(uint t = 0;t <= rest_num_max;t++){v = sample[t] * v;}}RE;}TE <TY T>VO SetPRecursiveMAAction(CO TTMA<PO<T> >& M,TwoByOneMA<T>& v,CRUI LE){if(LE == 0){RE;}uint deg = 1;for(uint y = 0;y < 2;y++){for(uint x = 0;x < 2;x++){CRUI SZ = M.GetEntry(y,x).SZ();if(deg < SZ){deg = SZ;}}}deg--;uint interval_LE = 1;int EX = 0;WH(interval_LE * (interval_LE * deg + 1) <= LE){interval_LE *= 2;EX++;}interval_LE /= 2;EX--;uint interval_num_max;uint t_rest_start;VE<T> point{};if(EX > 0){CO uint interval_num_lim = LE / interval_LE;interval_num_max = interval_num_lim - 1;t_rest_start = interval_LE * interval_num_lim;uint subinterval_num_max = deg;T subinterval_LE = PO<T>::c_one();SET_TTMA_MULTIPOINT_EVALUATION(subinterval_num_max,interval_num_lim,t * interval_LE);for(int e = 1;e < EX;e++){MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_TTMA(subinterval_num_max);subinterval_num_max *= 2;subinterval_LE *= 2;}uint rest_interval_LE = interval_num_max - subinterval_num_max;MULTIPLY_SUBPRODUCT_OF_PRECURSIVE_TTMA(rest_interval_LE);for(uint t = 0;t <= interval_num_max;t++){v = sample[t] * v;}}else{interval_num_max = t_rest_start = 0;}if(t_rest_start < LE){CO uint rest_num_lim = LE - t_rest_start;CO uint rest_num_max = rest_num_lim - 1;SET_TTMA_MULTIPOINT_EVALUATION(rest_num_max,rest_num_lim,t + t_rest_start);for(uint t = 0;t <= rest_num_max;t++){v = sample[t] * v;}}RE;}
