#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Polynomial/a_Body.hpp"
#else
// ../Truncate/compress.txtÇ©ÇÁ
// - FFT_MU_border_0<T>
// - DF_OF_MU_FOR_TR_PO
// à»äOÇÃëSÇƒÇÃFFTÅ^PARTIAL_SPECIALISATIONä÷åWÇÃÉ}ÉNÉçÅ^íËêîÅ^ä÷êîÇçÌèúÇµÇΩÇ‡ÇÃÅB
#define PO Polynomial
#define TRPO TruncatedPolynomial

#define DC_OF_AR_FOR_PO(FUNC)IN PO<T> OP FUNC(PO<T> f)CO;IN PO<T> OP FUNC(T t)CO
#define DF_OF_AR_FOR_PO(FUNC,DEF)TE <TY T> IN PO<T> PO<T>::OP FUNC(PO<T> f)CO{RE MO(DEF);};TE <TY T> IN PO<T> PO<T>::OP FUNC(T t)CO{RE *TH FUNC PO<T>(MO(t));}
TE <TY T>CL TRPO;TE <TY T>CL PO{PU:VE<T> m_f;uint m_SZ;IN PO();IN PO(CO PO<T>& f);IN PO(PO<T>&& f);IN PO(VE<T> f);IN PO(T t);IN PO(CRUI i,T t);IN PO<T>& OP=(T n);IN PO<T>& OP=(PO<T> f);IN PO<T>& OP=(VE<T> f);IN CO T& OP[](CRUI i)CO;IN T& OP[](CRUI i);IN T OP()(CO T& t)CO;PO<T>& OP+=(CO PO<T>& f);PO<T>& OP-=(CO PO<T>& f);PO<T>& OP*=(CO PO<T>& f);PO<T>& OP*=(PO<T>&& f);IN PO<T>& OP/=(CO PO<T>& f);PO<T>& OP/=(CO T& t);PO<T>& OP%=(CO PO<T>& f);PO<T>& OP%=(CO T& t);bool OP==(CO PO<T>& f)CO;bool OP==(CO T& t)CO;TE <TY P> IN bool OP!=(CO P& f)CO;DC_OF_AR_FOR_PO(+);IN PO<T> OP-()CO;DC_OF_AR_FOR_PO(-);DC_OF_AR_FOR_PO(*);IN PO<T> OP/(CO PO<T>& f)CO;IN PO<T> OP/(CO T& t)CO;IN PO<T> OP%(CO PO<T>& f)CO;IN PO<T> OP%(CO T& t)CO;IN CO VE<T>& GetCoefficient()CO NE;IN CRUI SZ()CO NE;IN VO resize(CRUI deg_plus)NE;IN VO swap(PO<T>& f);IN VO swap(VE<T>& f);VO ReMORedundantZero();IN string Display()CO NE;ST PO<T> Quotient(CO PO<T>& f0,CO PO<T>& f1);ST PO<T> TP(CO PO<T>& f,CRUI f_TP_SZ);ST IN CO PO<T>& zero();ST IN CO PO<T>& one();ST IN CO PO<T>& x();ST IN CO T& c_zero();ST IN CO T& c_one();ST IN CO T& c_minus_one();IN PO<T>& SignInvert();};

#define DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(TYPE,ARG,RHS)TE <> IN PO<TYPE>& PO<TYPE>::OP*=(ARG f){if(m_SZ != 0){VE<TYPE> v{};v.swap(m_f);TRPO<TYPE> TH_copy{m_SZ + f.m_SZ - 1,MO(v)};TH_copy *= RHS;m_f = MO(TH_copy.PO<TYPE>::m_f);m_SZ = m_f.SZ();}RE *TH;}
#define RE_ZERO_FOR_MU_FOR_TR_PO_IF(CONDITION)if(CONDITION){RE OP=(zero);}
#define RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(CONDITION)if(CONDITION){RE TRPO<T>(m_N);}
#define RE_ZERO_FOR__FOR_TR_PO_IF(MU,CONDITION)RE_ZERO_FOR_ ## MU ## _FOR_TR_PO_IF(CONDITION)
#define SET_VE_FOR_AN_OF_MU_FOR_TR_PO(N_OUTPUT_LIM)if(PO<T>::m_SZ < N_OUTPUT_LIM){for(uint i = PO<T>::m_SZ;i < N_OUTPUT_LIM;i++){PO<T>::m_f.push_back(0);}PO<T>::m_SZ = N_OUTPUT_LIM;}
#define SET_VE_FOR_AN_OF_TR_MU_CO_FOR_TR_PO(N_OUTPUT_LIM)VE<T> AN(N_OUTPUT_LIM)
#define SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_OUTPUT_LIM)SET_VE_FOR_AN_OF_ ## MU ## _FOR_TR_PO(N_OUTPUT_LIM)
#define SET_SUM_OF_MU_FOR_TR_PO PO<T>::m_f[i]= sum
#define SET_SUM_OF_TR_MU_CO_FOR_TR_PO AN[i]= sum
#define SET_SUM_OF__FOR_TR_PO(MU)SET_SUM_OF_ ## MU ## _FOR_TR_PO
#define SET_N_INPUT_START_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_START_NUM)uint N_INPUT_START_NUM{};for(uint i = 0;i < SZ && searching;i++){if(F[i]!= zero){N_INPUT_START_NUM = i;searching = false;}}
#define SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_MAX_NUM)uint N_INPUT_MAX_NUM{};searching = true;for(uint i =(SZ)- 1;searching;i--){if(F[i]!= zero){N_INPUT_MAX_NUM = i;searching = false;}}
#define CN_FOR_MU_FOR_TR_PO(J_MIN)CO uint j_max = i < N_input_max_0_start_1?i - N_input_start_1:N_input_max_0;T sum{zero};for(uint j = J_MIN;j <= j_max;j++){sum += PO<T>::m_f[j]* f.PO<T>::m_f[i - j];}PO<T>::m_f[i]= sum;
#define CN_FOR_TR_MU_CO_FOR_TR_PO(J_MIN)CO uint j_max = i < N_input_max_0_start_1?i - N_input_start_1:N_input_max_0;T& m_fi = AN[i];for(uint j = J_MIN;j <= j_max;j++){m_fi += PO<T>::m_f[j]* f.PO<T>::m_f[i - j];}
#define CN_FOR__FOR_TR_PO(MU,J_MIN)CN_FOR_ ## MU ## _FOR_TR_PO(J_MIN)
#define ZEROIFICATION_FOR_MU_FOR_TR_PO for(uint i = 0;i < N_input_start_0_start_1;i++){PO<T>::m_f[i]= 0;}
#define ZEROIFICATION_FOR_TR_MU_CO_FOR_TR_PO CRUI N_output_start_fixed = N_output_start < N_input_start_0_start_1?N_output_start:N_input_start_0_start_1;for(uint i = 0;i < N_output_start_fixed;i++){AN[i]= 0;}
#define ZEROIFICATION_FOR__FOR_TR_PO(MU)ZEROIFICATION_FOR_ ## MU ## _FOR_TR_PO
#define DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY,N_OUTPUT_START)RE_ZERO_FOR__FOR_TR_PO_IF(MU,PO<T>::m_SZ == 0);uint N_output_max = PO<T>::m_SZ + f.PO<T>::m_SZ - 2;if(N_output_max >= m_N){N_output_max = m_N - 1;}CO uint N_output_lim = N_output_max + 1;SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_output_lim);for(uint i = N_output_max;searching;i--){T sum{zero};for(uint j = 0;j <= i;j++){sum += ACCESS_ENTRY * f.PO<T>::OP[](i - j);}SET_SUM_OF__FOR_TR_PO(MU);searching = i > N_OUTPUT_START;}
#define DF_1_OF__FOR_TR_PO(MU)SET_N_INPUT_START_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_start_0);RE_ZERO_FOR__FOR_TR_PO_IF(MU,searching);searching = true;SET_N_INPUT_START_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ,N_input_start_1);
#define SET_N_INPUT_RANGE SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_max_0);SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ < m_N?f.PO<T>::m_SZ:m_N,N_input_max_1);CO uint N_input_max_0_max_1 = N_input_max_0 + N_input_max_1;CO uint N_input_start_0_start_1 = N_input_start_0 + N_input_start_1;uint N_output_lim_fixed = N_input_max_0_max_1 < m_N?N_input_max_0_max_1 + 1:m_N;
#define DF_3_OF__FOR_TR_PO(MU)CO uint N_input_start_0_max_1 = N_input_start_0 + N_input_max_1;CO uint N_input_max_0_start_1 = N_input_max_0 + N_input_start_1;CO uint N_output_max_fixed = N_output_lim_fixed - 1;SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_output_lim_fixed);for(uint i = N_output_max_fixed;i > N_input_start_0_max_1;i--){CN_FOR__FOR_TR_PO(MU,i - N_input_max_1);}searching = true;for(uint i = N_input_start_0_max_1 < N_output_max_fixed?N_input_start_0_max_1:N_output_max_fixed;searching;i--){CN_FOR__FOR_TR_PO(MU,N_input_start_0);searching = i > N_input_start_0_start_1;}ZEROIFICATION_FOR__FOR_TR_PO(MU);
#define SET_SHIFTED_VE_FOR_MU(V,F,I_START,I_MAX,I_SHIFT)VE<T> V(product_LE);for(uint i = I_START;i <= I_MAX;i++){V[I_SHIFT + i]= F[i];}
#define DF_OF_MU_FOR_TR_PO(RE_LINE_0,RE_LINE_1,RE_LINE_2,RE_LINE_3,RE_LINE_4,MU,ACCESS_ENTRY,N_OUTPUT_START,FIX_N_OUTPUT_LIM)CE CRUI border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::c_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){RE_LINE_0;DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY,N_OUTPUT_START);RE_LINE_1;}DF_1_OF__FOR_TR_PO(MU);RE_LINE_2;SET_N_INPUT_RANGE;FIX_N_OUTPUT_LIM;RE_LINE_3;DF_3_OF__FOR_TR_PO(MU);RE_LINE_4;
#define DF_OF_INVERSE_FOR_TR_PO(TYPE,RECURSION)CRUI N = f.GetTruncation();uint PW;uint PW_2 = 1;TRPO< TYPE > f_inv{PW_2,PO< TYPE >::c_one()/ f[0]};WH(PW_2 < N){PW = PW_2;PW_2 *= 2;f_inv.SetTruncation(PW_2);RECURSION;}f_inv.SetTruncation(N);RE f_inv
#define DF_OF_EXP_FOR_TR_PO(TYPE,RECURSION)assert(f[0]== PO< TYPE >::c_zero());CRUI N = f.GetTruncation();uint PW;uint PW_2 = 1;TRPO< TYPE > f_exp{PW_2,PO< TYPE >::c_one()};WH(PW_2 < N){PW = PW_2;PW_2 *= 2;f_exp.SetTruncation(PW_2);RECURSION;}f_exp.SetTruncation(N);RE f_exp

TE <TY T>CL TRPO:PU PO<T>{PU:uint m_N;PU:IN TRPO(CRUI N = 0);IN TRPO(CO TRPO<T>& f);IN TRPO(TRPO<T>&& f);IN TRPO(CRUI N,T t);IN TRPO(CRUI N,CO PO<T>& f);IN TRPO(CRUI N,PO<T>&& f);IN TRPO(CRUI N,VE<T>&& f);IN TRPO(CRUI N,CRUI i,T t);IN TRPO<T>& OP=(TRPO<T> f);IN TRPO<T>& OP=(T n);IN TRPO<T>& OP=(PO<T> f);IN TRPO<T>& OP+=(CO T& t);IN TRPO<T>& OP+=(CO PO<T>& f);IN TRPO<T>& OP+=(CO TRPO<T>& f);TRPO<T>& TRPlus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_limit);IN TRPO<T>& OP-=(CO T& t);IN TRPO<T>& OP-=(CO PO<T>& f);IN TRPO<T>& OP-=(CO TRPO<T>& f);TRPO<T>& TRMinus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_limit);IN TRPO<T>& OP*=(CO T& t);TRPO<T>& OP*=(CO PO<T>& f);IN TRPO<T>& OP*=(PO<T>&& f);TRPO<T>& TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim);TRPO<T> TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim)CO;IN TRPO<T>& OP/=(CO T& t);IN TRPO<T>& OP/=(CO TRPO<T>& t);IN TRPO<T>& OP%=(CO T& t);IN TRPO<T> OP-()CO;IN TRPO<T> OP()(CO TRPO<T>& f)CO;IN VO SetTruncation(CRUI N)NE;IN CRUI GetTruncation()CO NE;IN TRPO<T>& TruncateInitial(CRUI N)NE;IN TRPO<T>& TruncateFinal(CRUI N)NE;};TE <TY T> CE CO uint FFT_MU_border_0 = 17;

TE <TY T> IN TRPO<T>::TRPO(CRUI N):PO<T>(),m_N(N){AS(m_N > 0);}TE <TY T> IN TRPO<T>::TRPO(CO TRPO<T>& f):PO<T>(f),m_N(f.m_N){}TE <TY T> IN TRPO<T>::TRPO(TRPO<T>&& f):PO<T>(MO(f.m_f)),m_N(f.m_N){}TE <TY T> IN TRPO<T>::TRPO(CRUI N,T t):PO<T>(MO(t)),m_N(N){AS(m_N > 0);}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CO PO<T>& f):PO<T>(),m_N(N){AS(m_N > 0);PO<T>::m_SZ = f.PO<T>::m_SZ < m_N?f.PO<T>::m_SZ:m_N;PO<T>::m_f = VE<T>(PO<T>::m_SZ);for(uint i = 0;i < PO<T>::m_SZ;i++){PO<T>::m_f[i]= f.PO<T>::m_f[i];}}TE <TY T> IN TRPO<T>::TRPO(CRUI N,PO<T>&& f):PO<T>(),m_N(N){AS(m_N > 0);if(f.PO<T>::m_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f.PO<T>::m_SZ > m_N){TruncateFinal(m_N);}}else{PO<T>::m_f = VE<T>(m_N);for(uint i = 0;i < m_N;i++){PO<T>::m_f[i]= MO(f.PO<T>::m_f[i]);}PO<T>::m_SZ = m_N;}}TE <TY T> IN TRPO<T>::TRPO(CRUI N,VE<T>&& f):PO<T>(),m_N(N){AS(m_N > 0);CO uint f_SZ = f.SZ();if(f_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f_SZ > m_N){TruncateFinal(m_N);}}else{PO<T>::m_f = VE<T>(m_N);for(uint i = 0;i < m_N;i++){PO<T>::m_f[i]= MO(f[i]);}}}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CRUI i,T t):PO<T>(),m_N(N){AS(m_N > 0);if(i < m_N?t != PO<T>::c_zero():false){PO<T>::OP[](i)= MO(t);}}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(TRPO<T> f){PO<T>::OP=(MO(f.m_f));m_N = f.m_N;RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(T n){PO<T>::OP=(MO(n));RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(PO<T> f){RE OP=(TRPO<T>(m_N,MO(f)));}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO T& t){PO<T>::OP+=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO PO<T>& f){RE TRPlus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO TRPO<T>& f){RE TRPlus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRPlus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_lim){CRUI SZ = N_input_lim < m_N?N_input_lim < f.PO<T>::m_SZ?N_input_lim:f.PO<T>::m_SZ:m_N < f.PO<T>::m_SZ?m_N:f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(uint i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i]+= f.PO<T>::m_f[i];}for(uint i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;}else{for(uint i = N_input_start;i < SZ;i++){PO<T>::m_f[i]+= f.PO<T>::m_f[i];}}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO T& t){PO<T>::OP-=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO PO<T>& f){RE TRMinus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO TRPO<T>& f){RE TRMinus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRMinus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_lim){CRUI SZ = N_input_lim < m_N?N_input_lim < f.PO<T>::m_SZ?N_input_lim:f.PO<T>::m_SZ:m_N < f.PO<T>::m_SZ?m_N:f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(uint i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i]-= f.PO<T>::m_f[i];}for(uint i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(- f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;}else{for(uint i = N_input_start;i < SZ;i++){PO<T>::m_f[i]-= f.PO<T>::m_f[i];}}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP*=(CO T& t){PO<T>::OP*=(t);RE *TH;}TE <TY T>TRPO<T>& TRPO<T>::OP*=(CO PO<T>& f){DF_OF_MU_FOR_TR_PO(RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0),RE *TH,RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching),RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= m_N),RE *TH,MU,PO<T>::m_f[j],0,);}TE <TY T> IN TRPO<T>& TRPO<T>::OP*=(PO<T>&& f){RE OP*=(f);}TE <TY T>TRPO<T>& TRPO<T>::TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim){DF_OF_MU_FOR_TR_PO(,RE *TH,,RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,MU,PO<T>::m_f[j],N_output_start,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;});}TE <TY T>TRPO<T> TRPO<T>::TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim)CO{DF_OF_MU_FOR_TR_PO(,RE TRPO<T>(m_N,MO(AN)),,RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE TRPO<T>(m_N,MO(AN)),TR_MU_CO,PO<T>::OP[](j),N_output_start,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;});}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO T& t){PO<T>::OP/=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO TRPO<T>& f){RE OP*=(Inverse(m_N <= f.m_N?f:TRPO<T>(m_N,f)));}TE <TY T> IN TRPO<T>& TRPO<T>::OP%=(CO T& t){PO<T>::OP%=(t);RE *TH;}TE <TY T> IN TRPO<T> TRPO<T>::OP-()CO{RE MO(TRPO<T>(m_N)-= *TH);}TE <TY T> IN TRPO<T> TRPO<T>::OP()(CO TRPO<T>& f)CO{AS(f[0]== PO<T>::c_zero());CO uint N_minus = m_N - 1;if(N_minus == 0){RE *TH;}CO uint H = sqrt(N_minus);CO uint K = N_minus / H;VE<TRPO<T> > f_PW(K < 2?2:K);(f_PW[1]= f).SetTruncation(m_N);for(uint k = 2;k < K;k++){f_PW[k]= f_PW[k-1]* f_PW[1];}VE<TRPO<T> > f_PW2(H + 1);f_PW2[1]= K < 2?f_PW[1]:f_PW[K-1]* f_PW[1];for(uint h = 2;h <= H;h++){f_PW2[h]= f_PW2[h-1]* f_PW2[1];}uint k = 0;uint h = 0;uint n_max = N_minus;TRPO<T> AN{m_N};TRPO<T> AN_h{m_N};for(uint d = 0;d < m_N;d++){for(uint n = k;n <= n_max;n++){AN_h[n]+= k == 0?n == 0?(*TH)[d]:T{}:(*TH)[d]* f_PW[k][n];}if(++k == K || d == N_minus){AN += h == 0?AN_h:AN_h *= f_PW2[h];k = 0;h++;n_max -= K;AN_h = TRPO<T>(m_N);}}RE AN;}TE <TY T> IN VO TRPO<T>::SetTruncation(CRUI N)NE{if(N < m_N){TruncateFinal(N);}m_N = N;}TE <TY T> IN CRUI TRPO<T>::GetTruncation()CO NE{RE m_N;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateInitial(CRUI N)NE{CRUI SZ = N < PO<T>::m_SZ?N:PO<T>::m_SZ;for(uint i = 0;i < SZ;i++){PO<T>::m_f[i]= 0;}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateFinal(CRUI N)NE{WH(PO<T>::m_SZ > N){PO<T>::m_f.pop_back();PO<T>::m_SZ--;}RE *TH;}TE <TY T,TY P> IN TRPO<T> OP+(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0)+= f1);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f){RE MO(TRPO<T>(f.GetTurncation())-= f);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0)-= f1);}TE <TY T,TY P> IN TRPO<T> OP*(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0)*= f1);}TE <TY T,TY P> IN TRPO<T> OP/(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0)/= f1);}TE <TY T> IN TRPO<T> OP%(CO TRPO<T>& f0,CO T& t1){RE MO(TRPO<T>(f0)%= t1);}TE <TY T>TRPO<T> Differential(CRUI n,CO TRPO<T>& f){if(f.PO<T>::m_SZ < n){RE TRPO<T>(n < f.m_N?f.m_N - n:1,PO<T>::zero());}VE<T> df(n < f.m_N?f.m_N - n:1);T coef = T::Factorial(n);uint i = n;WH(i < f.PO<T>::m_SZ){df[i - n]= f[i]* coef;i++;(coef *= i)/=(i - n);}RE TRPO<T>(f.m_N - n,MO(df));}TE <TY T>TRPO<T> TRDifferential(CO TRPO<T>& f,CRUI N_output_start_plus_one){TRPO<T> f_dif{1 < f.m_N?f.m_N - 1:1};if(N_output_start_plus_one < f.PO<T>::m_SZ){CO uint SZ = f.PO<T>::m_SZ - 1;f_dif.PO<T>::m_f = VE<T>(SZ);for(uint i = N_output_start_plus_one;i < f.PO<T>::m_SZ;i++){f_dif.PO<T>::m_f[i-1]= f.PO<T>::m_f[i]* i;}f_dif.PO<T>::m_SZ = SZ;}RE f_dif;}TE <TY T> IN TRPO<T> Differential(CO TRPO<T>& f){RE TRDifferential<T>(f,1);}TE <TY T>TRPO<T> TRIntegral(CO TRPO<T>& f,CRUI N_output_start){TRPO<T> f_int{f.m_N + 1};if(N_output_start <= f.PO<T>::m_SZ){CO uint SZ = f.PO<T>::m_SZ + 1;f_int.PO<T>::m_f = VE<T>(SZ);for(uint i = N_output_start;i <= f.PO<T>::m_SZ;i++){f_int.PO<T>::m_f[i]= f.PO<T>::m_f[i - 1]/ T(i);}f_int.PO<T>::m_SZ = SZ;}RE f_int;}TE <TY T> IN TRPO<T> Integral(CO TRPO<T>& f){RE TRIntegral<T>(f,1);}TE <TY T>TRPO<T> Inverse(CO TRPO<T>& f){DF_OF_INVERSE_FOR_TR_PO(T,f_inv.TRMinus(f_inv.TRMU_CO(f,PW,PW_2).TRMU(f_inv,PW,PW_2),PW,PW_2));}TE <TY T>TRPO<T> Exp(CO TRPO<T>& f){DF_OF_EXP_FOR_TR_PO(T,f_exp.TRMinus((TRIntegral(Differential(f_exp).TRMU_CO(Inverse(f_exp),PW - 1,PW_2),PW).TRMinus(f,PW,PW_2)).TRMU(f_exp,PW),PW,PW_2));}TE <TY T> IN TRPO<T> Log(CO TRPO<T>& f){assert(f[0]== PO<T>::c_one());RE Integral<T>(Differential<T>(f)/= f);}

TE <TY T> IN PO<T>::PO():m_f(),m_SZ(0){}TE <TY T> IN PO<T>::PO(CO PO<T>& f):m_f(f.m_f),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(PO<T>&& f):m_f(MO(f.m_f)),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(VE<T> f):m_f(MO(f)),m_SZ(m_f.SZ()){}TE <TY T> IN PO<T>::PO(T t):PO(){if(t != c_zero()){OP[](0)= MO(t);}}TE <TY T> IN PO<T>::PO(CRUI i,T t):PO(){if(t != c_zero()){OP[](i)= MO(t);}}TE <TY T> IN PO<T>& PO<T>::OP=(T n){m_f.clear();m_SZ = 0;OP[](0)= MO(n);RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(PO<T> f){m_f = MO(f.m_f);m_SZ = f.m_SZ;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(VE<T> f){m_f = MO(f);m_SZ = m_f.SZ();RE *TH;}TE <TY T> IN CO T& PO<T>::OP[](CRUI i)CO{RE m_SZ <= i?c_zero():m_f[i];}TE <TY T> IN T& PO<T>::OP[](CRUI i){if(m_SZ <= i){CO T& z = c_zero();WH(m_SZ <= i){m_f.push_back(z);m_SZ++;}}RE m_f[i];}TE <TY T> IN T PO<T>::OP()(CO T& t)CO{RE MO((*TH %(PO<T>(1,c_one())- t))[0]);}TE <TY T>PO<T>& PO<T>::OP+=(CO PO<T>& f){if(m_SZ < f.m_SZ){m_f.reserve(f.m_SZ);for(uint i = 0;i < m_SZ;i++){m_f[i]+= f.m_f[i];}for(uint i = m_SZ;i < f.m_SZ;i++){m_f.push_back(f.m_f[i]);}m_SZ = f.m_SZ;}else{for(uint i = 0;i < f.m_SZ;i++){m_f[i]+= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP-=(CO PO<T>& f){if(m_SZ < f.m_SZ){m_f.reserve(f.m_SZ);for(uint i = 0;i < m_SZ;i++){m_f[i]-= f.m_f[i];}for(uint i = m_SZ;i < f.m_SZ;i++){m_f.push_back(- f.m_f[i]);}m_SZ = f.m_SZ;}else{for(uint i = 0;i < f.m_SZ;i++){m_f[i]-= f.m_f[i];}}RE *TH;}TE <TY T>PO<T>& PO<T>::OP*=(CO PO<T>& f){if(m_SZ == 0){RE *TH;}if(f.m_SZ == 0){m_f.clear();m_SZ = 0;RE *TH;}CO uint SZ = m_SZ + f.m_SZ - 1;PO<T> product{};for(uint i = 0;i < SZ;i++){T& product_i = product[i];CO uint j_min = m_SZ > i?0:i - m_SZ + 1;CO uint j_lim = i < f.m_SZ?i + 1:f.m_SZ;for(uint j = j_min;j < j_lim;j++){product_i += m_f[i - j]* f.m_f[j];}}RE *TH = MO(product);}TE <TY T> IN PO<T>& PO<T>::OP*=(PO<T>&& f){RE *TH *= f;};TE <TY T>PO<T>& PO<T>::OP/=(CO T& t){if(t == c_one()){RE *TH;}CO T t_inv{c_one()/ t};for(uint i = 0;i < m_SZ;i++){OP[](i)*= t_inv;}RE *TH;}TE <TY T>PO<T> PO<T>::TP(CO PO<T>& f,CRUI f_TP_SZ){VE<T> f_TP(f_TP_SZ);for(uint d = 0;d < f_TP_SZ;d++){f_TP[d]= f.m_f[f.m_SZ - 1 - d];}RE PO<T>(MO(f_TP));}TE <TY T>PO<T>& PO<T>::OP%=(CO T& t){if(t == c_one()){RE *TH = zero();}for(uint i = 0;i < m_SZ;i++){m_f[i]%= t;}RE *TH;}TE <TY T>bool PO<T>::OP==(CO PO<T>& f)CO{CRUI SZ0 = SZ();CRUI SZ1 = f.SZ();CRUI SZ_max = SZ0 < SZ1?SZ1:SZ0;for(uint i = 0;i < SZ_max;i++){if(OP[](i)!= f[i]){RE false;}}RE true;}TE <TY T>bool PO<T>::OP==(CO T& t)CO{CRUI SZ_max = SZ();CO T& zero = PO<T>::c_zero();for(uint i = 1;i < SZ_max;i++){if(m_f[i]!= zero){RE false;}}RE OP[](0)== t;}TE <TY T> TE<TY P> IN bool PO<T>::OP!=(CO P& f)CO{RE !(*TH == f);}DF_OF_AR_FOR_PO(+,f += *TH);TE <TY T> IN PO<T>& PO<T>::SignInvert(){ReMORedundantZero();for(auto& fi:m_f){fi = -fi;}RE *TH;}TE <TY T> IN PO<T> PO<T>::OP-()CO{RE MO(PO<T>(*TH).SignInvert());}DF_OF_AR_FOR_PO(-,f.SignInvert()+= *TH);DF_OF_AR_FOR_PO(*,f *= *TH);TE <TY T> IN PO<T> PO<T>::OP/(CO T& t)CO{RE MO(PO<T>(*TH)/= t);}TE <TY T> IN PO<T> PO<T>::OP%(CO T& t)CO{RE MO(PO<T>(*TH)%= t);}TE <TY T> IN CO VE<T>& PO<T>::GetCoefficient()CO NE{RE m_f;}TE <TY T> IN CRUI PO<T>::SZ()CO NE{RE m_SZ;}TE <TY T> IN VO PO<T>::resize(CRUI deg_plus)NE{m_f.resize(m_SZ = deg_plus);}TE <TY T> IN VO PO<T>::swap(PO<T>& f){m_f.swap(f.m_f);swap(m_SZ,f.m_SZ);}TE <TY T> IN VO PO<T>::swap(VE<T>& f){m_f.swap(f);m_SZ = m_f.SZ();}TE <TY T>VO PO<T>::ReMORedundantZero(){CO T& z = c_zero();WH(m_SZ > 0?m_f[m_SZ - 1]== z:false){m_f.pop_back();m_SZ--;}RE;}TE <TY T>string PO<T>::Display()CO NE{string s = "(";if(m_SZ > 0){s += to_string(m_f[0]);for(uint i = 1;i < m_SZ;i++){s += "," + to_string(m_f[i]);}}s += ")";RE s;}TE <TY T> IN CO PO<T>& PO<T>::zero(){ST CO PO<T> z{};RE z;}TE <TY T> IN CO PO<T>& PO<T>::one(){ST CO PO<T> o{c_one()};RE o;}TE <TY T> IN CO PO<T>& PO<T>::x(){ST CO PO<T> f{1u,c_one()};RE f;}TE <TY T> IN CO T& PO<T>::c_zero(){ST CO T z{0};RE z;}TE <TY T> IN CO T& PO<T>::c_one(){ST CO T o{1};RE o;}TE <TY T> IN CO T& PO<T>::c_minus_one(){ST CO T m{-1};RE m;}TE <TY T>PO<T> Differential(CRUI n,CO PO<T>& f){CRUI SZ = f.SZ();if(SZ < n){RE PO<T>::zero();}VE<T> df(SZ - n);T coef = T::Factorial(n);uint i = n;WH(i < SZ){df[i - n]= f[i]* coef;i++;(coef *= i)/=(i - n);}RE PO<T>(MO(df));}
TE <TY T> IN PO<T>& PO<T>::OP/=(CO PO<T>& f){RE *TH = Quotient(*TH,f);}TE <TY T>PO<T> PO<T>::Quotient(CO PO<T>& f0,CO PO<T>& f1){AS(f1.m_SZ == 0 || f1[f1.m_SZ-1] != c_zero());if(f0.m_SZ < f1.m_SZ){RE PO<T>::zero();}AS(f1.m_SZ != 0);CO uint f0_TP_SZ = f0.m_SZ - f1.m_SZ + 1;CO uint f1_TP_SZ = f0_TP_SZ < f1.m_SZ?f0_TP_SZ:f1.m_SZ;CO TRPO<T> f1_TP_inverse = Inverse(TRPO<T>(f0_TP_SZ,TP(f1,f1_TP_SZ)));TRPO<T> f0_TP{f0_TP_SZ,TP(f0,f0_TP_SZ)};f0_TP *= f1_TP_inverse;for(uint d0 =(f0_TP_SZ + 1)/ 2;d0 < f0_TP_SZ;d0++){::swap(f0_TP[d0],f0_TP[f0_TP_SZ - 1 - d0]);}RE f0_TP;}TE <TY T>PO<T>& PO<T>::OP%=(CO PO<T>& f){if(m_SZ >= f.m_SZ){*TH -=(*TH / f)* f;ReMORedundantZero();}RE *TH;}TE <TY T> IN PO<T> PO<T>::OP/(CO PO<T>& f)CO{RE PO<T>::Quotient(*TH,f);}TE <TY T> IN PO<T> PO<T>::OP%(CO PO<T>& f)CO{RE MO(PO<T>(*TH)%= f);}
#endif
