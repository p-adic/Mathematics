#define RE_ZERO_FOR_MU_FOR_TR_PO_IF(CONDITION) if(CONDITION){RE OP=(zero);} 
#define RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(CONDITION) if(CONDITION){RE TRPO<T>(m_N);} 
#define SET_VE_FOR_AN_OF_MU_FOR_TR_PO(N_OUTPUT_LIM) if(PO<T>::m_SZ < N_OUTPUT_LIM){for(UINT i = PO<T>::m_SZ;i < N_OUTPUT_LIM;i++){PO<T>::m_f.push_back(0);} PO<T>::m_SZ = N_OUTPUT_LIM;} 
#define SET_VE_FOR_AN_OF_TR_MU_CO_FOR_TR_PO(N_OUTPUT_LIM) VE<T> AN(N_OUTPUT_LIM) 
#define SET_SUM_OF_MU_FOR_TR_PO PO<T>::m_f[i] = sum 
#define SET_SUM_OF_TR_MU_CO_FOR_TR_PO AN[i] = sum 
#define SET_N_INPUT_START_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_START_NUM) UINT N_INPUT_START_NUM; for(UINT i = 0;i < SZ && searching;i++){if(F[i] != zero){N_INPUT_START_NUM = i; searching = false;}} 
#define SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_MAX_NUM) UINT N_INPUT_MAX_NUM; searching = true; for(UINT i = (SZ) - 1;searching;i--){if(F[i] != zero){N_INPUT_MAX_NUM = i; searching = false;}} 
#define CONVOLUTION_FOR_MU_FOR_TR_PO(J_MIN) CO UINT j_max = i < N_input_max_0_start_1 ? i - N_input_start_1:N_input_max_0; T sum{zero}; for(UINT j = J_MIN;j <= j_max;j++){sum += PO<T>::m_f[j] * f.PO<T>::m_f[i - j];} PO<T>::m_f[i] = sum; 
#define CONVOLUTION_FOR_TR_MU_CO_FOR_TR_PO(J_MIN) CO UINT j_max = i < N_input_max_0_start_1 ? i - N_input_start_1:N_input_max_0; T& m_fi = AN[i]; for(UINT j = J_MIN;j <= j_max;j++){m_fi += PO<T>::m_f[j] * f.PO<T>::m_f[i - j];} 
#define ZEROIFICATION_FOR_MU_FOR_TR_PO for(UINT i = 0;i < N_input_start_0_start_1;i++){PO<T>::m_f[i] = 0;} 
#define ZEROIFICATION_FOR_TR_MU_CO_FOR_TR_PO for(UINT i = 0;i < N_input_start_0_start_1;i++){AN[i] = 0;} 
#define CN(S1,S2) SUBSTITUTE_CN(S1,S2) 
#define SUBSTITUTE_CN(S1,S2) S1 ## S2 
#define DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY) CN(CN(RE_ZERO_FOR_,MU),_FOR_TR_PO_IF)(PO<T>::m_SZ == 0); UINT N_output_max = PO<T>::m_SZ + f.PO<T>::m_SZ - 2; if(N_output_max >= m_N){N_output_max = m_N - 1;} CO UINT N_output_lim = N_output_max + 1; CN(CN(SET_VE_FOR_AN_OF_,MU),_FOR_TR_PO)(N_output_lim); for(UINT i = N_output_max;searching;i--){T sum{zero}; for(UINT j = 0;j <= i;j++){sum += ACCESS_ENTRY * f.PO<T>::OP[](i - j);} CN(CN(SET_SUM_OF_,MU),_FOR_TR_PO); searching = i > 0;} 
#define DF_0_OF_MU_FOR_TR_PO DF_0_OF__FOR_TR_PO(MU,PO<T>::m_f[j]) 
#define DF_0_OF_TR_MU_CO_FOR_TR_PO DF_0_OF__FOR_TR_PO(TR_MU_CO,PO<T>::OP[](j)) 
#define DF_1_OF__FOR_TR_PO(MU) SET_N_INPUT_START_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_start_0); CN(CN(RE_ZERO_FOR_,MU),_FOR_TR_PO_IF)(searching); searching = true; SET_N_INPUT_START_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ,N_input_start_1); 
#define DF_1_OF_MU_FOR_TR_PO DF_1_OF__FOR_TR_PO(MU) 
#define DF_1_OF_TR_MU_CO_FOR_TR_PO DF_1_OF__FOR_TR_PO(TR_MU_CO) 
#define DF_2_OF_MU_FOR_TR_PO SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_max_0); SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ < m_N ? f.PO<T>::m_SZ:m_N,N_input_max_1); CO UINT N_input_max_0_max_1 = N_input_max_0 + N_input_max_1; CO UINT N_input_start_0_start_1 = N_input_start_0 + N_input_start_1; 
#define DF_2_OF_TR_MU_CO_FOR_TR_PO DF_2_OF_MU_FOR_TR_PO 
#define DF_3_OF__FOR_TR_PO(MU) CO UINT N_input_start_0_max_1 = N_input_start_0 + N_input_max_1; CO UINT N_input_max_0_start_1 = N_input_max_0 + N_input_start_1; CO UINT N_output_max_fixed = N_output_lim_fixed - 1; CN(CN(SET_VE_FOR_AN_OF_,MU),_FOR_TR_PO)(N_output_lim_fixed); for(UINT i = N_output_max_fixed;i > N_input_start_0_max_1;i--){CN(CN(CONVOLUTION_FOR_,MU),_FOR_TR_PO)(i - N_input_max_1);} searching = true; for(UINT i = N_input_start_0_max_1 < N_output_max_fixed ? N_input_start_0_max_1:N_output_max_fixed;searching;i--){CN(CN(CONVOLUTION_FOR_,MU),_FOR_TR_PO)(N_input_start_0); searching = i > N_input_start_0_start_1;} CN(CN(ZEROIFICATION_FOR_,MU),_FOR_TR_PO); 
#define DF_3_OF_MU_FOR_TR_PO DF_3_OF__FOR_TR_PO(MU) 
#define DF_3_OF_TR_MU_CO_FOR_TR_PO DF_3_OF__FOR_TR_PO(TR_MU_CO) 
#define DF_4_OF_MU_FOR_TR_PO UINT two_power = FFT_MU_border_1_2<T>; UINT exponent = FFT_MU_border_1_2_exponent<T>; T two_power_inv{FFT_MU_border_1_2_inv<T>}; WH(N_input_TR_deg_0_deg_1 >= two_power){two_power *= 2; two_power_inv /= 2; exponent++;} VE<T> f0{FFT<T>(PO<T>::m_f,N_input_start_0,N_input_max_0 + 1,0,two_power,exponent)}; CO VE<T> f1{FFT<T>(f.PO<T>::m_f,N_input_start_1,N_input_max_1 + 1,0,two_power,exponent)}; for(UINT i = 0;i < two_power;i++){f0[i] *= f1[i];} 
#define DF_4_OF_TR_MU_CO_FOR_TR_PO DF_4_OF_MU_FOR_TR_PO 
#define DF_OF_INVERSE_FOR_TR_PO(TYPE,RECURSION) CO UINT& N = f.GetTruncation(); UINT power; UINT power_2 = 1; TRPO< TYPE > f_inv{power_2,PO< TYPE >::CO_one() / f[0]}; WH(power_2 < N){power = power_2; power_2 *= 2; f_inv.SetTruncation(power_2); RECURSION;} f_inv.SetTruncation(N); RE MO(f_inv) 
#define DF_OF_EXP_FOR_TR_PO(TYPE,RECURSION) CO UINT& N = f.GetTruncation(); UINT power; UINT power_2 = 1; TRPO< TYPE > f_exp{power_2,PO< TYPE >::CO_one()}; WH(power_2 < N){power = power_2; power_2 *= 2; f_exp.SetTruncation(power_2); RECURSION;} f_exp.SetTruncation(N); RE MO(f_exp) 
#define DF_OF_PARTIAL_SPECIALISATION_OF_MU_OF_TR_PO(TYPE,BORDER_0,BORDER_1,BORDER_1_2,BORDER_1_2_EXPONENT,BORDER_1_2_INV) TE <> CE CO UINT FFT_MU_border_0< TYPE > = BORDER_0; TE <> CE CO UINT FFT_MU_border_1< TYPE > = BORDER_1; TE <> CE CO UINT FFT_MU_border_1_2< TYPE > = BORDER_1_2; TE <> CE CO UINT FFT_MU_border_1_2_exponent< TYPE > = BORDER_1_2_EXPONENT; TE <> CE CO UINT FFT_MU_border_1_2_inv< TYPE > = BORDER_1_2_INV; TE <> IN TRPO< TYPE >& TRPO< TYPE >::OP*=(CO PO< TYPE >& f) {RE TRPO< TYPE >::FFT_MU(f);} TE <> TRPO< TYPE > Inverse(CO TRPO< TYPE >& f) {DF_OF_INVERSE_FOR_TR_PO(TYPE,f_inv.TRMinus(f_inv.FFT_TRMU_CO(f,power,power_2).FFT_TRMU(f_inv,power,power_2),power,power_2));} TE <> TRPO< TYPE > Exp(CO TRPO< TYPE >& f) {DF_OF_EXP_FOR_TR_PO(TYPE,f_exp.TRMinus((TRIntegral(Differential(f_exp).FFT_TRMU_CO(Inverse(f_exp),power - 1,power_2),power).TRMinus(f,power,power_2)).FFT_TRMU(f_exp,power,power_2),power,power_2));} 
#define DF_OF_PARTIAL_SPECIALISATION_OF_MU_OF_PO(TYPE) TE <> PO<TYPE>& PO<TYPE>::OP*=(CO PO<TYPE>& f) {if(m_SZ != 0){VE<TYPE> v{}; v.swap(m_f); TRPO<TYPE> this_copy{m_SZ + f.m_SZ - 1,MO(v)}; this_copy *= this == &f ? this_copy : f; m_f = MO(this_copy.PO<TYPE>::m_f); m_SZ = m_f.SZ();} RE *this;} 
IN CEXPR(ll,P,998244353);TE <TY T> CL TRPO;TE <TY T>CL PO{friend CL TRPO<T>;PR:VE<T> m_f;UINT m_SZ;PU:IN PO();IN PO(CO T& t);IN PO(CO PO<T>& f);IN PO(PO<T>&& f);IN PO(CO UINT& i,CO T& t);IN PO(VE<T>&& f);PO<T>& OP=(CO T& t);PO<T>& OP=(CO PO<T>& f);PO<T>& OP=(PO<T>&& f);IN CO T& OP[](CO UINT& i) CO;IN T& OP[](CO UINT& i);IN T OP()(CO T& t) CO;IN PO<T>& OP+=(CO T& t);PO<T>& OP+=(CO PO<T>& f);IN PO<T>& OP-=(CO T& t);PO<T>& OP-=(CO PO<T>& f);PO<T>& OP*=(CO T& t);PO<T>& OP*=(CO PO<T>& f);PO<T>& OP/=(CO T& t);IN PO<T>& OP/=(CO PO<T>& f);PO<T>& OP%=(CO T& t);PO<T>& OP%=(CO PO<T>& f);IN PO<T> OP-() CO;PO<T>& OP<<=(CO T& t);IN CO VE<T>& GetCoefficient() CO noexcept;IN CO UINT& SZ() CO noexcept;IN void swap(PO<T>& f);IN void swap(VE<T>& f);void ReMORedundantZero();IN string Display() CO noexcept;ST PO<T> Quotient(CO PO<T>& f0,CO PO<T>& f1);ST PO<T> TransposeQuotient(CO PO<T>& f0,CO UINT& f0_transpose_SZ,CO PO<T>& f1_transpose_inverse,CO UINT& f1_SZ);ST PO<T> Transpose(CO PO<T>& f,CO UINT& f_transpose_SZ);ST IN CO PO<T>& zero();ST IN CO T& CO_zero();ST IN CO T& CO_one();ST IN CO T& CO_minus_one();ST IN CO T& factorial(CO UINT& i);ST IN CO T& factorial_inverse(CO UINT& i);};TE <TY T>bool OP==(CO PO<T>& f0,CO T& t1);TE <TY T>bool OP==(CO PO<T>& f0,CO PO<T>& f1);TE <TY T,TY P> IN bool OP!=(CO PO<T>& f0,CO P& f1);TE <TY T,TY P> IN PO<T> OP+(CO PO<T>& f0,CO P& f1);TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f);TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f0,CO P& f1);TE <TY T,TY P> IN PO<T> OP*(CO PO<T>& f0,CO P& f1);TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO T& t1);TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO PO<T>& f1);TE <TY T,TY P> IN PO<T> OP%(CO PO<T>& f0,CO P& f1);TE <TY T> IN PO<T> OP<<(CO PO<T>& f,CO T& t);TE <TY T,TE <TY> TY V>T& Prod(V<T>& f);TE <TY T> TRPO<T> Differential(CO UINT& n,CO TRPO<T>& f);TE <TY T> TRPO<T> TRDifferential(CO TRPO<T>& f,CO UINT& N_output_start_plus_one);TE <TY T> TRPO<T> TRIntegral(CO TRPO<T>& f,CO UINT& N_output_start);TE <TY T>CL TRPO :PU PO<T>{friend TRPO<T> Differential<T>(CO UINT& n,CO TRPO<T>& f);friend TRPO<T> TRDifferential<T>(CO TRPO<T>& f,CO UINT& N_output_start_plus_one);friend TRPO<T> TRIntegral<T>(CO TRPO<T>& f,CO UINT& N_output_start);PR:UINT m_N;PU:IN TRPO(CO UINT& N = 0);IN TRPO(CO TRPO<T>& f);IN TRPO(TRPO<T>&& f);IN TRPO(CO UINT& N,CO T& t);IN TRPO(CO UINT& N,CO PO<T>& f);IN TRPO(CO UINT& N,PO<T>&& f);IN TRPO(CO UINT& N,CO UINT& i,CO T& t);IN TRPO(CO UINT& N,VE<T>&& f);IN TRPO<T>& OP=(CO TRPO<T>& f);IN TRPO<T>& OP=(TRPO<T>&& f);IN TRPO<T>& OP=(CO T& t);IN TRPO<T>& OP=(CO PO<T>& f);IN TRPO<T>& OP=(PO<T>&& f);IN TRPO<T>& OP+=(CO T& t);IN TRPO<T>& OP+=(CO PO<T>& f);IN TRPO<T>& OP+=(CO TRPO<T>& f);TRPO<T>& TRPlus(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_limit);IN TRPO<T>& OP-=(CO T& t);IN TRPO<T>& OP-=(CO PO<T>& f);IN TRPO<T>& OP-=(CO TRPO<T>& f);TRPO<T>& TRMinus(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_limit);IN TRPO<T>& OP*=(CO T& t);TRPO<T>& OP*=(CO PO<T>& f);TRPO<T>& FFT_MU(CO PO<T>& f);TRPO<T>& TRMU(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim);TRPO<T>& FFT_TRMU(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim);TRPO<T> TRMU_CO(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim) CO;TRPO<T> FFT_TRMU_CO(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim) CO;IN TRPO<T>& OP/=(CO T& t);IN TRPO<T>& OP/=(CO TRPO<T>& t);IN TRPO<T>& OP%=(CO T& t);IN TRPO<T> OP-() CO;IN void SetTruncation(CO UINT& N) noexcept;IN CO UINT& GetTruncation() CO noexcept;IN TRPO<T>& TruncateInitial(CO UINT& N) noexcept;IN TRPO<T>& TruncateFinal(CO UINT& N) noexcept;};TE <TY T> IN CE CO UINT FFT_MU_border_0{};TE <TY T> IN CE CO UINT FFT_MU_border_1{};TE <TY T> IN CE CO UINT FFT_MU_border_1_2{};TE <TY T> IN CE CO UINT FFT_MU_border_1_2_exponent{};TE <TY T> IN CE CO UINT FFT_MU_border_1_2_inv{};TE <TY T,TY P> IN TRPO<T> OP+(CO TRPO<T>& f0,CO P& f1);TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f);TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f0,CO P& f1);TE <TY T,TY P> IN TRPO<T> OP*(CO TRPO<T>& f0,CO P& f1);TE <TY T,TY P> IN TRPO<T> OP/(CO TRPO<T>& f0,CO P& f1);TE <TY T> IN TRPO<T> OP%(CO TRPO<T>& f0,CO T& t1);TE <TY T> IN TRPO<T> Differential(CO TRPO<T>& f);TE <TY T> IN TRPO<T> Differential(CO UINT& n,CO TRPO<T>& f);TE <TY T> TRPO<T> TRDifferential(CO TRPO<T>& f,CO UINT& N_output_start_plus_one);TE <TY T> IN TRPO<T> Integral(CO TRPO<T>& f);TE <TY T>TRPO<T> TRIntegral(CO TRPO<T>& f,CO UINT& N_output_start);TE <TY T>TRPO<T> Inverse(CO TRPO<T>& f);TE <TY T>TRPO<T> Exp(CO TRPO<T>& f);TE <TY T> IN TRPO<T> Log(CO TRPO<T>& f);TE <TY T>TRPO<T> Power(CO TRPO<T>& f,CO T& t);TE <> IN CE CO UINT LimitOfPowerForFFT<Mod<998244353> > = 24;TE <> IN CE CO UINT BorderForFFT<Mod<998244353> > = 4; TE <> IN CO Mod<998244353> (&PrimitiveRootOfTwoForFFT() noexcept)[LimitOfPowerForFFT<Mod<998244353> >]{ST CO Mod<998244353> PRT[ LimitOfPowerForFFT<Mod<998244353> > ] ={Mod<998244353>(1) ,Mod<998244353>(998244352) ,Mod<998244353>(911660635) ,Mod<998244353>(625715529) ,Mod<998244353>(373294451) ,Mod<998244353>(827987769) ,Mod<998244353>(280333251) ,Mod<998244353>(581015842) ,Mod<998244353>(628092333) ,Mod<998244353>(300892551) ,Mod<998244353>(586046298) ,Mod<998244353>(615001099) ,Mod<998244353>(318017948) ,Mod<998244353>(64341522) ,Mod<998244353>(106061068) ,Mod<998244353>(304605202) ,Mod<998244353>(631920086) ,Mod<998244353>(857779016) ,Mod<998244353>(841431251) ,Mod<998244353>(805775211) ,Mod<998244353>(390359979) ,Mod<998244353>(923521) ,Mod<998244353>(961) ,Mod<998244353>(31)};RE PRT;}TE <> IN CO Mod<998244353> (&InversePrimitiveRootOfTwoForFFT() noexcept)[LimitOfPowerForFFT<Mod<998244353> >]{ST CO Mod<998244353> PRT[ LimitOfPowerForFFT<Mod<998244353> > ] ={Mod<998244353>(1) ,Mod<998244353>(998244352) ,Mod<998244353>(86583718) ,Mod<998244353>(488723995) ,Mod<998244353>(369330050) ,Mod<998244353>(543653592) ,Mod<998244353>(382946991) ,Mod<998244353>(844956623) ,Mod<998244353>(91420391) ,Mod<998244353>(433414612) ,Mod<998244353>(288894979) ,Mod<998244353>(260490556) ,Mod<998244353>(857007890) ,Mod<998244353>(736054570) ,Mod<998244353>(474649464) ,Mod<998244353>(948509906) ,Mod<998244353>(114942468) ,Mod<998244353>(962405921) ,Mod<998244353>(667573957) ,Mod<998244353>(46809892) ,Mod<998244353>(304321983) ,Mod<998244353>(30429817) ,Mod<998244353>(293967900) ,Mod<998244353>(128805723)};RE PRT;}TE <TY T>ST VE<T> FFT_Body(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& N_output_start,CO UINT& N_output_lim,CO UINT& N_output_shift,CO UINT& two_power,CO UINT& exponent,CO T (&PRT)[LimitOfPowerForFFT<T>]);TE <TY T>ST VE<T> FFT_Body(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& two_power,CO UINT& exponent,CO UINT& start,CO UINT& depth,CO T (&PRT)[LimitOfPowerForFFT<T>]);TE <TY T> IN VE<T> FFT(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& two_power,CO UINT& exponent) {RE FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power,exponent,0,1,PrimitiveRootOfTwoForFFT<T>());}TE <TY T> IN VE<T> FFT(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& N_output_start,CO UINT& N_output_lim,CO UINT& N_output_shift,CO UINT& two_power,CO UINT& exponent) {RE FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,N_output_start,N_output_lim,N_output_shift,two_power,exponent,PrimitiveRootOfTwoForFFT<T>());}TE <TY T>VE<T> IFFT(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& two_power,CO T& two_power_inv,CO UINT& exponent){VE<T> AN{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power,exponent,InversePrimitiveRootOfTwoForFFT<T>())};CO UINT SZ = AN.SZ();for(UINT i = 0;i < SZ;i++){AN[i] *= two_power_inv;}RE AN;}TE <TY T>VE<T> IFFT(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& N_output_start,CO UINT& N_output_lim,CO UINT& N_output_shift,CO UINT& two_power,CO T& two_power_inv,CO UINT& exponent){VE<T> AN{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,N_output_start,N_output_lim,N_output_shift,two_power,exponent,InversePrimitiveRootOfTwoForFFT<T>())};UINT SZ = AN.SZ();CO UINT N_output_length = N_output_lim - N_output_start + N_output_shift;if(SZ < N_output_length){SZ = N_output_length;}for(UINT i = N_output_shift;i < SZ;i++){AN[i] *= two_power_inv;}RE AN;}TE <TY T>ST VE<T> FFT_Body(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& N_output_start,CO UINT& N_output_lim,CO UINT& N_output_shift,CO UINT& two_power,CO UINT& exponent,CO T (&PRT)[LimitOfPowerForFFT<T>]){CO UINT length = N_output_lim - N_output_start + N_output_shift;VE<T> AN(length);if(two_power == 1){if(N_input_shift == 0 && N_output_shift < length){if(N_input_start < N_input_lim){AN[N_output_shift] = f[N_input_start];}}} else {CO T& zeta = PRT[exponent];T zeta_power = PRT[0];UINT N_output_start_copy = N_output_start;UINT digit = 0;if(N_output_start_copy != 0){if(N_output_start_copy % 2 == 1){zeta_power *= zeta;}N_output_start_copy /= 2;digit++;}WH(N_output_start_copy != 0){if(N_output_start_copy % 2 == 1){zeta_power *= PRT[exponent - digit];}N_output_start_copy /= 2;digit++;}CO UINT two_power_sub = two_power / 2;CO UINT exponent_sub = exponent - 1;VE<T> AN_sub0{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power_sub,exponent_sub,0,2,PRT)};VE<T> AN_sub1{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power_sub,exponent_sub,1,2,PRT)};for(UINT i = N_output_start;i < N_output_lim;i++){CO UINT i_sub = i % two_power_sub;AN[i - N_output_start + N_output_shift] = AN_sub0[i_sub] + zeta_power * AN_sub1[i_sub];zeta_power *= zeta;}}RE AN;}TE <TY T>ST VE<T> FFT_Body(CO VE<T>& f,CO UINT& N_input_start,CO UINT& N_input_lim,CO UINT& N_input_shift,CO UINT& two_power,CO UINT& exponent,CO UINT& start,CO UINT& depth,CO T (&PRT)[LimitOfPowerForFFT<T>]){VE<T> AN(two_power);CO UINT start_depth = start + ((two_power - 1) * depth);CO UINT N_input_length = N_input_lim - N_input_start + N_input_shift;if(start < N_input_length && N_input_shift <= start_depth){UINT j_min;if(start < N_input_shift){CO UINT N_input_shift_shift = N_input_shift - start;j_min = N_input_shift_shift / depth + (N_input_shift_shift % depth == 0 ? 0 : 1);} else {j_min = 0;}UINT j_lim;if(N_input_length <= start_depth){CO UINT N_input_length_shift = N_input_length - start;j_lim = N_input_length_shift / depth + (N_input_length_shift % depth == 0 ? 0 : 1);} else {j_lim = two_power;}CO T zero{0};UINT count = 0;UINT index_hit;UINT j_hit;for(UINT j = j_min;j < j_lim && count < 2;j++){CO UINT index = start + j * depth - N_input_shift + N_input_start;if(f[index] != zero){if(count == 0){index_hit = index;j_hit = j;}count++;}}if(count == 1){CO T& zeta = PRT[exponent];CO T& one = PRT[0];T zeta_power{one};T zeta_power_2{zeta};WH(j_hit != 0){if(j_hit % 2 == 1){zeta_power *= zeta_power_2;}zeta_power_2 *= zeta_power_2;j_hit /= 2;}AN[0] = f[index_hit];for(UINT i = 1;i < two_power;i++){AN[i] = zeta_power * AN[i-1];}} else if(count > 1){CO T& zeta = PRT[exponent];CO T& one = PRT[0];T zeta_power{one};CE CO UINT& border = BorderForFFT<T>;if(exponent < border){for(UINT i = 0;i < two_power;i++){T& AN_i = AN[i];T zeta_power_power{one};T zeta_power_power_2{zeta_power};UINT j_min_copy = j_min;WH(j_min_copy != 0){if(j_min_copy % 2 == 1){zeta_power_power *= zeta_power_power_2;}zeta_power_power_2 *= zeta_power_power_2;j_min_copy /= 2;}UINT index = start + j_min * depth - N_input_shift + N_input_start;for(UINT j = j_min;j < j_lim;j++){AN_i += zeta_power_power * f[index];zeta_power_power *= zeta_power;index += depth;}zeta_power *= zeta;}} else {CO UINT two_power_sub = two_power / 2;CO UINT exponent_sub = exponent - 1;CO UINT depth_sub = depth * 2;VE<T> AN_sub0{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power_sub,exponent_sub,start,depth_sub,PRT)};VE<T> AN_sub1{FFT_Body<T>(f,N_input_start,N_input_lim,N_input_shift,two_power_sub,exponent_sub,start + depth,depth_sub,PRT)};for(UINT i = 0;i < two_power;i++){CO UINT i_sub = i % two_power_sub;AN[i] = AN_sub0[i_sub] + zeta_power * AN_sub1[i_sub];zeta_power *= zeta;}}}}RE AN;}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N) : PO<T>(),m_N(N) {}TE <TY T> IN TRPO<T>::TRPO(CO TRPO<T>& f) : PO<T>(f),m_N(f.m_N) {}TE <TY T> IN TRPO<T>::TRPO(TRPO<T>&& f) : PO<T>(MO(f)),m_N(MO(f.m_N)) {}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N,CO T& t) : PO<T>(t),m_N(N) {}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N,CO PO<T>& f) : PO<T>(),m_N(N) {PO<T>::m_SZ = f.PO<T>::m_SZ < m_N ? f.PO<T>::m_SZ : m_N; PO<T>::m_f = VE<T>(PO<T>::m_SZ); for(UINT i = 0;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] = f.PO<T>::m_f[i];}}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N,PO<T>&& f) : PO<T>(),m_N(N) {if(f.PO<T>::m_SZ < m_N * 2){PO<T>::OP=(MO(f)); TruncateFinal(m_N);} else {PO<T>::m_f = VE<T>(m_N); for(UINT i = 0;i < m_N;i++){PO<T>::m_f[i] = MO(f.PO<T>::m_f[i]);} PO<T>::m_SZ = m_N;}}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N,CO UINT& i,CO T& t) : PO<T>(),m_N(N) {if(i < m_N ? t != PO<T>::CO_zero() : false){PO<T>::OP[](i) = t;}}TE <TY T> IN TRPO<T>::TRPO(CO UINT& N,VE<T>&& f) : PO<T>(),m_N(N) {if(f.SZ() < m_N * 2){PO<T>::OP=(MO(f)); TruncateFinal(m_N);} else {PO<T>::m_f = VE<T>(m_N); for(UINT i = 0;i < m_N;i++){PO<T>::m_f[i] = MO(f[i]);} PO<T>::m_SZ = m_N;}}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO TRPO<T>& f) {PO<T>::OP=(f); m_N = f.m_N; RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(TRPO<T>&& f) {PO<T>::OP=(MO(f)); m_N = MO(f.m_N); RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO T& t) {PO<T>::OP=(t); RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO PO<T>& f) {RE OP=(TRPO<T>(m_N,f));}TE <TY T> IN TRPO<T>& TRPO<T>::OP=(PO<T>&& f) {RE OP=(TRPO<T>(m_N,MO(f)));}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO T& t) {PO<T>::OP+=(t); RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO PO<T>& f) {RE TRPO<T>::TRPlus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO TRPO<T>& f) {RE m_N == 0 ? OP=(f) : TRPO<T>::TRPlus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRPlus(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_limit){CO UINT& SZ = N_input_limit < m_N ? N_input_limit < f.PO<T>::m_SZ ? N_input_limit : f.PO<T>::m_SZ : m_N < f.PO<T>::m_SZ ? m_N : f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(UINT i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] += f.PO<T>::m_f[i];}for(UINT i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;} else {for(UINT i = N_input_start;i < SZ;i++){PO<T>::m_f[i] += f.PO<T>::m_f[i];}}RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO T& t) {PO<T>::OP-=(t); RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO PO<T>& f) {RE TRPO<T>::TRMinus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO TRPO<T>& f) {RE m_N == 0 ? OP=(-f) : TRPO<T>::TRMinus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRMinus(CO PO<T>& f,CO UINT& N_input_start,CO UINT& N_input_limit){CO UINT& SZ = N_input_limit < m_N ? N_input_limit < f.PO<T>::m_SZ ? N_input_limit : f.PO<T>::m_SZ : m_N < f.PO<T>::m_SZ ? m_N : f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(UINT i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] -= f.PO<T>::m_f[i];}for(UINT i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(- f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;} else {for(UINT i = N_input_start;i < SZ;i++){PO<T>::m_f[i] -= f.PO<T>::m_f[i];}}RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP*=(CO T& t) {PO<T>::OP*=(t); RE *this;}DF_OF_PARTIAL_SPECIALISATION_OF_MU_OF_TR_PO(Mod<998244353>,17,512,1024,10,997269505); TE <TY T>TRPO<T>& TRPO<T>::OP*=(CO PO<T>& f){CE CO UINT border_0 = 21;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0);DF_0_OF_MU_FOR_TR_PO;} else {DF_1_OF_MU_FOR_TR_PO;RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching);DF_2_OF_MU_FOR_TR_PO;CO UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= m_N);DF_3_OF_MU_FOR_TR_PO;}RE *this;}TE <TY T>TRPO<T>& TRPO<T>::FFT_MU(CO PO<T>& f){CE CO UINT& border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0);DF_0_OF_MU_FOR_TR_PO;} else {DF_1_OF_MU_FOR_TR_PO;RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching);DF_2_OF_MU_FOR_TR_PO;CO UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed);CO UINT N_input_TR_deg_0_deg_1 = N_input_max_0 - N_input_start_0 + N_input_max_1 - N_input_start_1;CE CO UINT& border_1 = FFT_MU_border_1<T>;if(N_input_TR_deg_0_deg_1 < border_1){DF_3_OF_MU_FOR_TR_PO;} else {DF_4_OF_MU_FOR_TR_PO;PO<T>::m_f = IFFT<T>(f0,0,two_power,0,0,N_output_lim_fixed - N_input_start_0_start_1,N_input_start_0_start_1,two_power,two_power_inv,exponent);PO<T>::m_SZ = PO<T>::m_f.SZ();}}RE *this;}TE <TY T> TRPO<T>& TRPO<T>::TRMU(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim){CE CO UINT border_0 = 21;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){DF_0_OF_MU_FOR_TR_PO;} else {DF_1_OF_MU_FOR_TR_PO;DF_2_OF_MU_FOR_TR_PO;UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;}RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed);DF_3_OF_MU_FOR_TR_PO;}RE *this;}TE <TY T> TRPO<T>& TRPO<T>::FFT_TRMU(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim){CE CO UINT& border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){DF_0_OF_MU_FOR_TR_PO;} else {DF_1_OF_MU_FOR_TR_PO;DF_2_OF_MU_FOR_TR_PO;UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;}RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed);CO UINT N_input_TR_deg_0_deg_1 = N_input_max_0 - N_input_start_0 + N_input_max_1 - N_input_start_1;CE CO UINT& border_1 = FFT_MU_border_1<T>;if(N_input_TR_deg_0_deg_1 < border_1){DF_3_OF_MU_FOR_TR_PO;} else {DF_4_OF_MU_FOR_TR_PO;UINT N_output_start_shifted;UINT N_output_shift_shifted;if(N_output_start < N_input_start_0_start_1){N_output_start_shifted = 0;N_output_shift_shifted = N_input_start_0_start_1;} else {N_output_start_shifted = N_output_start - N_input_start_0_start_1;N_output_shift_shifted = N_output_start;}CO UINT N_output_lim_shifted = N_output_lim_fixed - N_input_start_0_start_1;f0 = IFFT<T>(f0,0,two_power,0,N_output_start_shifted,N_output_lim_shifted,N_output_shift_shifted,two_power,two_power_inv,exponent);SET_VE_FOR_AN_OF_MU_FOR_TR_PO(N_output_lim_fixed);for(UINT i = N_output_start;i < N_output_lim_fixed;i++){PO<T>::m_f[i] = f0[i];}}}RE *this;}TE <TY T> TRPO<T> TRPO<T>::TRMU_CO(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim) CO{CE CO UINT border_0 = 21;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){DF_0_OF_TR_MU_CO_FOR_TR_PO;RE TRPO<T>(m_N,MO(AN));}DF_1_OF_TR_MU_CO_FOR_TR_PO;DF_2_OF_TR_MU_CO_FOR_TR_PO;UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;}RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed);DF_3_OF_TR_MU_CO_FOR_TR_PO;RE TRPO<T>(m_N,MO(AN));}TE <TY T> TRPO<T> TRPO<T>::FFT_TRMU_CO(CO PO<T>& f,CO UINT& N_output_start,CO UINT& N_output_lim) CO{CE CO UINT& border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){DF_0_OF_TR_MU_CO_FOR_TR_PO;RE TRPO<T>(m_N,MO(AN));}DF_1_OF_TR_MU_CO_FOR_TR_PO;DF_2_OF_TR_MU_CO_FOR_TR_PO;UINT N_output_lim_fixed = N_input_max_0_max_1 < m_N ? N_input_max_0_max_1 + 1 : m_N;if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;}RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed);CO UINT N_input_TR_deg_0_deg_1 = N_input_max_0 - N_input_start_0 + N_input_max_1 - N_input_start_1;CE CO UINT& border_1 = FFT_MU_border_1<T>;if(N_input_TR_deg_0_deg_1 < border_1){DF_3_OF_TR_MU_CO_FOR_TR_PO;RE TRPO<T>(m_N,MO(AN));}DF_4_OF_TR_MU_CO_FOR_TR_PO;UINT N_output_start_shifted;UINT N_output_shift_shifted;if(N_output_start < N_input_start_0_start_1){N_output_start_shifted = 0;N_output_shift_shifted = N_input_start_0_start_1;} else {N_output_start_shifted = N_output_start - N_input_start_0_start_1;N_output_shift_shifted = N_output_start;}CO UINT N_output_lim_shifted = N_output_lim_fixed - N_input_start_0_start_1;RE TRPO<T>(m_N,IFFT<T>(f0,0,two_power,0,N_output_start_shifted,N_output_lim_shifted,N_output_shift_shifted,two_power,two_power_inv,exponent));}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO T& t) {PO<T>::OP/=(t); RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO TRPO<T>& f) {RE OP*=(Inverse(m_N > f.m_N ? f : TRPO<T>(m_N,f)));}TE <TY T> IN TRPO<T>& TRPO<T>::OP%=(CO T& t) {PO<T>::OP%=(t); RE *this;}TE <TY T> IN TRPO<T> TRPO<T>::OP-() CO {RE MO(TRPO<T>(m_N) -= *this);}TE <TY T> IN void TRPO<T>::SetTruncation(CO UINT& N) noexcept {m_N = N; TruncateFinal(m_N);}TE <TY T> IN CO UINT& TRPO<T>::GetTruncation() CO noexcept {RE m_N;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateInitial(CO UINT& N) noexcept {CO UINT& SZ = N < PO<T>::m_SZ ? N : PO<T>::m_SZ; for(UINT i = 0;i < SZ;i++){PO<T>::m_f[i] = 0;} RE *this;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateFinal(CO UINT& N) noexcept {WH(PO<T>::m_SZ > N){PO<T>::m_f.pop_back(); PO<T>::m_SZ--;} RE *this;}TE <TY T,TY P> IN TRPO<T> OP+(CO TRPO<T>& f0,CO P& f1) {RE MO(TRPO<T>(f0) += f1);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f) {RE MO(TRPO<T>(f.GetTurncation()) -= f);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f0,CO P& f1) {RE MO(TRPO<T>(f0) -= f1);}TE <TY T,TY P> IN TRPO<T> OP*(CO TRPO<T>& f0,CO P& f1) {RE MO(TRPO<T>(f0) *= f1);}TE <TY T,TY P> IN TRPO<T> OP/(CO TRPO<T>& f0,CO P& f1) {RE MO(TRPO<T>(f0) /= f1);}TE <TY T> IN TRPO<T> OP%(CO TRPO<T>& f0,CO T& t1) {RE MO(TRPO<T>(f0) %= t1);}TE <TY T> IN TRPO<T> Differential(CO TRPO<T>& f) {RE TRDifferential<T>(f,1);}TE <TY T>TRPO<T> Differential(CO UINT& n,CO TRPO<T>& f){if(f.PO<T>::m_SZ < n){RE TRPO(f.m_N - n,PO<T>::zero());}VE<T> df(f.PO<T>::m_SZ - n);T coef = PO<T>::factorial(n);UINT i = n;WH(i < f.PO<T>::m_SZ){df[i - n] = f[i] * coef;i++;(coef *= i) /= (i - n);}RE TRPO(f.m_N - n,MO(df));}TE <TY T>TRPO<T> TRDifferential(CO TRPO<T>& f,CO UINT& N_output_start_plus_one){if(f.m_N == 0){ERR_IMPUT(f,f.m_N);}TRPO<T> f_dif{f.m_N - 1};if(N_output_start_plus_one < f.PO<T>::m_SZ){CO UINT SZ = f.PO<T>::m_SZ - 1;f_dif.PO<T>::m_f = VE<T>(SZ);for(UINT i = N_output_start_plus_one;i < f.PO<T>::m_SZ;i++){f_dif.PO<T>::m_f[i-1] = i * f.PO<T>::m_f[i];}f_dif.PO<T>::m_SZ = SZ;}RE f_dif;}TE <TY T> IN TRPO<T> Integral(CO TRPO<T>& f) {RE TRIntegral<T>(f,1);}TE <TY T>TRPO<T> TRIntegral(CO TRPO<T>& f,CO UINT& N_output_start){TRPO<T> f_int{f.m_N + 1};if(N_output_start <= f.PO<T>::m_SZ){CO UINT SZ = f.PO<T>::m_SZ + 1;f_int.PO<T>::m_f = VE<T>(SZ);for(UINT i = N_output_start;i <= f.PO<T>::m_SZ;i++){f_int.PO<T>::m_f[i] = f.PO<T>::m_f[i - 1] / T(i);}f_int.PO<T>::m_SZ = SZ;}RE f_int;}TE <TY T>TRPO<T> Inverse(CO TRPO<T>& f){DF_OF_INVERSE_FOR_TR_PO(T,f_inv.TRMinus(f_inv.TRMU_CO(f,power,power_2).TRMU(f_inv,power,power_2),power,power_2));}TE <TY T>TRPO<T> Exp(CO TRPO<T>& f){DF_OF_EXP_FOR_TR_PO(T,f_exp.TRMinus((TRIntegral(Differential(f_exp).TRMU_CO(Inverse(f_exp),power - 1,power_2),power).TRMinus(f,power,power_2)).TRMU(f_exp,power),power,power_2));}TE <TY T> IN TRPO<T> Log(CO TRPO<T>& f) {RE Integral<T>(Differential<T>(f) /= f);}TE <TY T> IN TRPO<T> Power(CO TRPO<T>& f,CO T& t) {RE Exp(Log(f) *= t);}TE <TY T> IN PO<T>::PO() : m_f(),m_SZ(0) {}TE <TY T> IN PO<T>::PO(CO T& t) : PO() {if(t != CO_zero()){OP[](0) = t;}}TE <TY T> IN PO<T>::PO(CO PO<T>& f) : m_f(f.m_f),m_SZ(f.m_SZ) {}TE <TY T> IN PO<T>::PO(PO<T>&& f) : m_f(MO(f.m_f)),m_SZ(MO(f.m_SZ)) {}TE <TY T> IN PO<T>::PO(CO UINT& i,CO T& t) : PO() {if(t != CO_zero()){OP[](i) = t;}}TE <TY T> IN PO<T>::PO(VE<T>&& f) : m_f(MO(f)),m_SZ(m_f.SZ()) {}TE <TY T> IN PO<T>& PO<T>::OP=(CO T& t) {m_f.clear(); m_SZ = 0; OP[](0) = t; RE *this;}TE <TY T> IN PO<T>& PO<T>::OP=(CO PO<T>& f) {m_f = f.m_f; m_SZ = f.m_SZ; RE *this;}TE <TY T> IN PO<T>& PO<T>::OP=(PO<T>&& f) {m_f = MO(f.m_f); m_SZ = MO(f.m_SZ); RE *this;}TE <TY T>CO T& PO<T>::OP[](CO UINT& i) CO{if(m_SZ <= i){RE CO_zero();}RE m_f[i];}TE <TY T> IN T& PO<T>::OP[](CO UINT& i){if(m_SZ <= i){CO T& z = CO_zero();WH(m_SZ <= i){m_f.push_back(z);m_SZ++;}}RE m_f[i];}TE <TY T> IN T PO<T>::OP()(CO T& t) CO {RE MO((*this % (PO<T>(1,CO_one()) - t))[0]);}TE <TY T> IN PO<T>& PO<T>::OP+=(CO T& t) {OP[](0) += t; RE *this;}TE <TY T>PO<T>& PO<T>::OP+=(CO PO<T>& f){for(UINT i = 0;i < f.m_SZ;i++){OP[](i) += f.m_f[i];}RE *this;}TE <TY T> IN PO<T>& PO<T>::OP-=(CO T& t) {OP[](0) -= t; RE *this;}TE <TY T>PO<T>& PO<T>::OP-=(CO PO<T>& f){for(UINT i = 0;i < f.m_SZ;i++){OP[](i) -= f.m_f[i];}RE *this;}DF_OF_PARTIAL_SPECIALISATION_OF_MU_OF_PO(Mod<998244353>);TE <TY T>PO<T>& PO<T>::OP*=(CO T& t){if(m_SZ == 0 || t == CO_one()){RE *this;}if(t == CO_zero()){RE OP=(zero());}for(UINT i = 0;i < m_SZ;i++){OP[](i) *= t;}RE *this;}TE <TY T>PO<T>& PO<T>::OP*=(CO PO<T>& f){if(m_SZ == 0){RE *this;}if(f.m_SZ == 0){m_f.clear();m_SZ = 0;RE *this;}CO UINT SZ = m_SZ + f.m_SZ - 1;PO<T> product{}; for(UINT i = 0;i < SZ;i++){T& product_i = product[i];CO UINT j_min = m_SZ <= i ? i - m_SZ + 1 : 0;CO UINT j_lim = i < f.m_SZ ? i + 1 : f.m_SZ;for(UINT j = j_min;j < j_lim;j++){product_i += m_f[i - j] * f.m_f[j];}}RE OP=(MO(product));}TE <TY T>PO<T>& PO<T>::OP/=(CO T& t){if(t == CO_one()){RE *this;}CO T t_inv{CO_one() / t};for(UINT i = 0;i < m_SZ;i++){OP[](i) *= t_inv;}RE *this;}TE <TY T> IN PO<T>& PO<T>::OP/=(CO PO<T>& f) {RE m_SZ < f.m_SZ ? *this : OP=(Quotient(*this,f));}TE <TY T>PO<T> PO<T>::Quotient(CO PO<T>& f0,CO PO<T>& f1){if(f0.m_SZ < f1.m_SZ){RE f0;}if(f1.m_SZ == 0){ERR_IMPUT(f0,f1,f1.m_SZ);}CO UINT f0_transpose_SZ = f0.m_SZ - f1.m_SZ + 1;CO UINT f1_transpose_SZ = f0_transpose_SZ < f1.m_SZ ? f0_transpose_SZ : f1.m_SZ;RE TransposeQuotient(f0,f0_transpose_SZ,Inverse(TRPO<T>(f0_transpose_SZ,Transpose(f1,f1_transpose_SZ))),f1.m_SZ);}TE <TY T>PO<T> PO<T>::TransposeQuotient(CO PO<T>& f0,CO UINT& f0_transpose_SZ,CO PO<T>& f1_transpose_inverse,CO UINT& f1_SZ){TRPO<T> f0_transpose{f0_transpose_SZ,Transpose(f0,f0_transpose_SZ)};f0_transpose *= f1_transpose_inverse;for(UINT d0 = (f0_transpose_SZ + 1) / 2;d0 < f0_transpose_SZ;d0++){::swap(f0_transpose.PO<T>::m_f[d0],f0_transpose.PO<T>::m_f[ f0_transpose_SZ - 1 - d0 ]);}RE f0_transpose;}TE <TY T>PO<T> PO<T>::Transpose(CO PO<T>& f,CO UINT& f_transpose_SZ){VE<T> f_transpose(f_transpose_SZ);for(UINT d = 0;d < f_transpose_SZ;d++){f_transpose[d] = f.m_f[f.m_SZ - 1 - d];}RE PO<T>(MO(f_transpose));}TE <TY T>PO<T>& PO<T>::OP%=(CO T& t){if(t == CO_one()){RE OP=(zero());}for(UINT i = 0;i < m_SZ;i++){OP[](i) %= t;}RE *this;}TE <TY T>PO<T>& PO<T>::OP%=(CO PO<T>& f){if(m_SZ >= f.m_SZ){OP-=((*this / f) * f);ReMORedundantZero();}RE *this;}TE <TY T> IN PO<T> PO<T>::OP-() CO {RE MO(PO<T>() -= *this);}TE <TY T >PO<T>& PO<T>::OP<<=(CO T& t){if(m_SZ > 0){ST T factorial_curr = 1;ST VE<T> factorial = {1,1};ST T factorial_inv_curr = 1;ST VE<T> factorial_inv = {1,1};UINT SZ = factorial.SZ();WH(SZ < m_SZ){factorial.push_back(factorial_curr *= SZ);factorial_inv.push_back(factorial_inv_curr /= SZ);SZ++;}for(UINT d = 0;d < m_SZ;d++){m_f[d] *= factorial[d];}TRPO<T> exp_t_transpose{m_SZ * 2};T power_t = CO_one();for(UINT d = 0;d < m_SZ;d++){exp_t_transpose[m_SZ - 1 - d] = power_t * factorial_inv[d];power_t *= t;}exp_t_transpose *= *this;for(UINT d = 0;d < m_SZ;d++){m_f[d] = exp_t_transpose.PO<T>::m_f[d + m_SZ - 1] * factorial_inv[d];}}RE *this;}TE <TY T> IN CO VE<T>& PO<T>::GetCoefficient() CO noexcept {RE m_f;}TE <TY T> IN CO UINT& PO<T>::SZ() CO noexcept {RE m_SZ;}TE <TY T> IN void PO<T>::swap(PO<T>& f) {m_f.swap(f.m_f); swap(m_SZ,f.m_SZ);}TE <TY T> IN void PO<T>::swap(VE<T>& f) {m_f.swap(f); m_SZ = m_f.SZ();}TE <TY T>void PO<T>::ReMORedundantZero(){CO T& z = CO_zero();WH(m_SZ > 0 ? m_f[m_SZ - 1] == z : false){m_f.pop_back();m_SZ--;}RE;}TE <TY T>string PO<T>::Display() CO noexcept{string s = "(";if(m_SZ > 0){s += to_string(m_f[0]);for(UINT i = 1;i < m_SZ;i++){s += ", " + to_string(m_f[i]);}}s += ")";RE s;}TE <TY T> IN CO PO<T>& PO<T>::zero() {ST CO PO<T> z{}; RE z;}TE <TY T> IN CO T& PO<T>::CO_zero() {ST CO T z{0}; RE z;}TE <TY T> IN CO T& PO<T>::CO_one() {ST CO T o{1}; RE o;}TE <TY T> IN CO T& PO<T>::CO_minus_one() {ST CO T m{-1}; RE m;}TE <TY T> IN CO T& PO<T>::factorial(CO UINT& i) {ST VE<T> memory = {CO_one(),CO_one()}; ST T curr = CO_one(); ST UINT SZ = 2; WH(SZ <= i){memory.push_back(curr *= SZ++);} RE memory[i];}TE <TY T> IN CO T& PO<T>::factorial_inverse(CO UINT& i) {ST VE<T> memory = {CO_one(),CO_one()}; ST T curr = CO_one(); ST UINT SZ = 2; WH(SZ <= i){memory.push_back(curr /= SZ++);} RE memory[i];}TE <TY T>bool OP==(CO PO<T>& f0,CO T& t1){CO UINT& SZ = f0.SZ();CO T& zero = PO<T>::CO_zero();for(UINT i = 1;i < SZ;i++){if(f0[i] != zero){RE false;}}RE f0[0] == t1;}TE <TY T>bool OP==(CO PO<T>& f0,CO PO<T>& f1){CO UINT& SZ0 = f0.SZ();CO UINT& SZ1 = f1.SZ();CO UINT& SZ = SZ0 < SZ1 ? SZ1 : SZ0;for(UINT i = 0;i < SZ;i++){if(f0[i] != f1[i]){RE false;}}RE true;}TE <TY T,TY P> IN bool OP!=(CO PO<T>& f0,CO P& f1) {RE !(f0 == f1);}TE <TY T,TY P> IN PO<T> OP+(CO PO<T>& f0,CO P& f1) {RE MO(PO<T>(f0) += f1);}TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f) {RE PO<T>::zero() - f;}TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f0,CO P& f1) {RE MO(PO<T>(f0) -= f1);}TE <TY T,TY P> IN PO<T> OP*(CO PO<T>& f0,CO P& f1) {RE MO(PO<T>(f0) *= f1);}TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO T& t1) {RE MO(PO<T>(f0) /= t1);}TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO PO<T>& f1) {RE PO<T>::Quotient(f0,f1);}TE <TY T,TY P> IN PO<T> OP%(CO PO<T>& f0,CO P& f1) {RE MO(PO<T>(f0) %= f1);}TE <TY T> PO<T> OP<<(CO PO<T>& f,CO T& t) {RE MO(PO<T>(f) <<= t);};TE <TY T,TE <TY> TY V>T& Prod(V<T>& f){if(f.empty()){f.push_back(T(1));}if(f.SZ() == 1){RE f.front();}auto itr = f.begin(),end = f.end();WH(itr != end){T& t = *itr;itr++;if(itr != end){t *= *itr;itr = f.erase(itr);}}RE Prod(f);}
