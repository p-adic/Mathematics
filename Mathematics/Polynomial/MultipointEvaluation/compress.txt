// ../Truncate/compress.txtÇêÊÇ…ì\ÇÈÅB

TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2,TE <TY...> TY V3>VO SetPointTreeEvaluation(CO PO<T>& f,CO V1<V2<PO<T> > >& point_tree,V3<T>& AN){CO V2<PO<T> >& prod = point_tree.front();if(prod.empty()){RE;}LI<PO<T> > residue ={};CO PO<T>& zero = PO<T>::zero();residue.push_back(zero);residue.back() = f % prod.front();auto I_tree = point_tree.BE(),EN_tree = point_tree.EN();I_tree++;WH(I_tree != EN_tree){auto I_residue = residue.BE(),EN_residue = residue.EN();auto I_node = I_tree->BE(),EN_node = I_tree->EN();WH(I_residue != EN_residue){CO PO<T>& f = *I_node;I_node++;if(I_node != EN_node){*(residue.insert(I_residue,zero)) = *I_residue % f;*I_residue %= *I_node;I_node++;}I_residue++;}I_tree++;}for(auto I_residue = residue.BE(),EN_residue = residue.EN();I_residue != EN_residue;I_residue++){AN.push_back((*I_residue)[0]);}RE;}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2> IN VO SetMultipointEvaluation(CO PO<T>& f,CO V1<T>& point,V2<T>& AN){LI<LI<PO<T> > > pt{};SetPointTree(point,pt);SetPointTreeEvaluation(f,pt,AN);}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2 >VO SetProductTree(V1<V2<T> >& product_tree){V2<T> empty{};V2<T> *p_node = &(product_tree.back());WH(p_node->SZ() > 1){product_tree.push_front(empty);V2<T>& node_curr = product_tree.front();for(auto I = p_node->BE(),EN = p_node->EN();I != EN;I++){ST CO T null{};node_curr.push_back(null);T& f = *I;I++;if(I == EN){node_curr.back() = f;break;}else{node_curr.back() = f * *I;}}p_node = &node_curr;}RE;}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2,TE <TY...> TY V3>VO SetPointTree(CO V1<T>& point,V2<V3<PO<T> > >& point_tree){ST CO V3<PO<T> > empty{};point_tree.push_front(empty);V3<PO<T> >& linear = point_tree.front();for(auto I = point.BE(),EN = point.EN();I != EN;I++){ST CO PO<T> x{1,PO<T>::CO_one()};linear.push_back(x);linear.back()[0] -= *I;}SetProductTree(point_tree);RE;}
