// ../Truncate/compress.txtを先に貼る。

// 多点評価
TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2 >VO SetProductTree(V1<V2<T> >& product_tree){V2<T> empty{};V2<T> *p_node = &(product_tree.back());WH(p_node->SZ()> 1){product_tree.push_front(empty);V2<T>& node_curr = product_tree.front();for(auto I = p_node->BE(),EN = p_node->EN();I != EN;I++){ST CO T null{};node_curr.push_back(null);T& f = *I;I++;if(I == EN){node_curr.back()= f;break;}else{node_curr.back()= f * *I;}}p_node = &node_curr;}RE;}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2,TE <TY...> TY V3>VO SetPointTree(CO V1<T>& point,V2<V3<PO<T> > >& point_tree){ST CO V3<PO<T> > empty{};point_tree.push_front(empty);V3<PO<T> >& linear = point_tree.front();for(auto I = point.BE(),EN = point.EN();I != EN;I++){ST CO PO<T> x{1,PO<T>::CO_one()};linear.push_back(x);linear.back()[0]-= *I;}SetProductTree(point_tree);RE;}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2,TE <TY...> TY V3>VO SetPointTreeEvaluation(CO PO<T>& f,CO V1<V2<PO<T> > >& point_tree,V3<T>& AN){assert(!point_tree.empty());CO V2<PO<T> >& top = point_tree.front();if(top.empty()){RE;}LI<PO<T> > RS ={};CO PO<T>& zero = PO<T>::zero();RS.push_back(zero);RS.back()= f % top.front();auto I_tree = point_tree.BE(),EN_tree = point_tree.EN();I_tree++;WH(I_tree != EN_tree){auto I_RS = RS.BE(),EN_RS = RS.EN();auto I_node = I_tree->BE(),EN_node = I_tree->EN();WH(I_RS != EN_RS){CO PO<T>& f = *I_node;I_node++;if(I_node != EN_node){*(RS.insert(I_RS,zero))= *I_RS % f;*I_RS %= *I_node;I_node++;}I_RS++;}I_tree++;}for(auto I_RS = RS.BE(),EN_RS = RS.EN();I_RS != EN_RS;I_RS++){AN.push_back((*I_RS)[0]);}RE;}TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2> IN VO SetMultipointEvaluation(CO PO<T>& f,CO V1<T>& point,V2<T>& AN){LI<LI<PO<T> > > pt{};SetPointTree(point,pt);SetPointTreeEvaluation(f,pt,AN);}

// 差積（多点評価を用いる）
TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2> VO SetDifferenceProduct(CO PO<T>& f,CO V1<T>& point,V2<T>& AN){LI<LI<PO<T> > > pt{};SetPointTree(point,pt);CO LI<PO<T> >& top = pt.front();if(top.empty()){RE;}PO<T> g{Differential(1,top.front())};SetPointTreeEvaluation(g,pt,AN);RE;}

// 分子と評価点が与えられた時の部分分数分解（多点評価を用いる）
TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2> VO SetPartialFractionDecomposition(CO PO<T>& f,CO V1<T>& point,V2<T>& AN){assert(f.SZ()<= point.size());LI<LI<PO<T> > > pt{};SetPointTree(point,pt);CO LI<PO<T> >& top = pt.front();if(top.empty()){RE;}PO<T> g{Differential(1,top.front())};LI<T> r{};SetPointTreeEvaluation(f,pt,AN);SetPointTreeEvaluation(g,pt,r);auto IT1 = AN.BE(),EN1 = AN.EN();auto IT2 = r.BE();WH(IT1 != EN1){*(IT1++)/= *(IT2++);}RE;}
// 商と評価点が与えられた時の部分分数分解（多点評価を用いる）
TE <TY T,TE <TY...> TY V1,TE <TY...> TY V2> VO SetPartialFractionDecomposition(CRUI N,PO<T> f,CO V1<T>& point,V2<T>& AN){LI<LI<PO<T> > > pt{};SetPointTree(point,pt);CO LI<PO<T> >& top = pt.front();if(top.empty()){RE;}PO<T> g{top.front()};TRPO<T> fg{point.SZ()+1,MO(f)};fg *= g;CO PO<T>& h = fg;AN.push_back((h/g)[0]);g = Differential(1,g);LI<T> r{};SetPointTreeEvaluation(fg,pt,AN);SetPointTreeEvaluation(g,pt,r);auto IT1 = AN.BE(),EN1 = AN.EN();IT1++;auto IT2 = r.BE();WH(IT1 != EN1){*(IT1++)/= *(IT2++);}RE;}
