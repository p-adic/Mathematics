TE <TY T,TE <TY> TY V1,TE <TY> TY V2,TE <TY> TY V3>void SetPointTreeEvaluation(CO PO<T>& f,CO V1<V2<PO<T> > >& point_tree,V3<T>& AN){CO V2<PO<T> >& prod = point_tree.front();if(prod.empty()){RE;}LI<PO<T> > residue = {};CO PO<T>& zero = PO<T>::zero();residue.push_back(zero);residue.back() = f % prod.front();auto I_tree = point_tree.begin(),end_tree = point_tree.end();I_tree++;WH(I_tree != end_tree){auto I_residue = residue.begin(),end_residue = residue.end();auto I_node = I_tree->begin(),end_node = I_tree->end();WH(I_residue != end_residue){CO PO<T>& f = *I_node;I_node++;if(I_node != end_node){*(residue.insert(I_residue,zero)) = *I_residue % f;*I_residue %= *I_node;I_node++;}I_residue++;}I_tree++;}for(auto I_residue = residue.begin(),end_residue = residue.end();I_residue != end_residue;I_residue++){AN.push_back((*I_residue)[0]);}RE;}TE <TY T,TE <TY> TY V1,TE <TY> TY V2> IN void SetMultipointEvaluation(CO PO<T>& f,CO V1<T>& point,V2<T>& AN) { LI<LI<PO<T> > > pt{}; SetPointTree(point,pt); SetPointTreeEvaluation(f,pt,AN); }TE <TY T,TE <TY> TY V1,TE <TY> TY V2 >void SetProductTree(V1<V2<T> >& product_tree){V2<T> empty{};V2<T> *p_node = &(product_tree.back());WH(p_node->SZ() > 1){product_tree.push_front(empty);V2<T>& node_curr = product_tree.front();for(auto I = p_node->begin(),end = p_node->end();I != end;I++){ST CO T null{};node_curr.push_back(null);T& f = *I;I++;if(I == end){node_curr.back() = f;break;} else {node_curr.back() = f * *I;}}p_node = &node_curr;}RE;}TE <TY T,TE <TY> TY V1,TE <TY> TY V2,TE <TY> TY V3>void SetPointTree(CO V1<T>& point,V2<V3<PO<T> > >& point_tree){ST CO V3<PO<T> > empty{};point_tree.push_front(empty);V3<PO<T> >& linear = point_tree.front();for(auto I = point.begin(),end = point.end();I != end;I++){ST CO PO<T> x{ 1,PO<T>::CO_one() };linear.push_back(x);linear.back()[0] -= *I;}SetProductTree(point_tree);RE;}
