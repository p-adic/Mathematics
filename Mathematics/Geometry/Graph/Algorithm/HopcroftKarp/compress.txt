#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/HopcroftKarp/a_Body.hpp"
#else
TE <TY T,TY GRAPH>CL VirtualBreadthFirstSearch{PU:GRAPH& m_G;T m_not_found;bool m_initialised;LI<T> m_next;VE<bool> m_found;VE<T> m_prev;IN VirtualBreadthFirstSearch(GRAPH& G,CO T& not_found);TE <TY Arg> IN VirtualBreadthFirstSearch(GRAPH& G,CO T& not_found,Arg&& init);IN VO Initialise();IN VO Initialise(CO T& init);IN VO Initialise(LI<T> inits);IN VO Shift(CO T& init);IN VO Shift(LI<T> inits);IN CRI SZ()CO NE;IN VE<bool>::reference found(CO T& t);IN CO T& prev(CO T& t);IN T Next();TE <TY U = T> auto GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>;TE <TY U = T> auto GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>;pair<VE<int>,int> GetConnectedComponent();VI VO Push(LI<T>& next,CO T& t)= 0;TE <TY PATH> IN VO Push(LI<T>& next,CO PATH& p);};
TE <TY T,TY GRAPH> IN VirtualBreadthFirstSearch<T,GRAPH>::VirtualBreadthFirstSearch(GRAPH& G,CO T& not_found):m_G(G),m_not_found(not_found),m_initialised(false),m_next(),m_found(),m_prev(){ST_AS(is_same_v<inner_t<GRAPH>,T>);}TE <TY T,TY GRAPH> TE <TY Arg> IN VirtualBreadthFirstSearch<T,GRAPH>::VirtualBreadthFirstSearch(GRAPH& G,CO T& not_found,Arg&& init):VirtualBreadthFirstSearch<T,GRAPH>(G,not_found){Initialise(forward<Arg>(init));}TE <TY T,TY GRAPH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Initialise(){m_initialised = true;CRI V = SZ();m_next.clear();m_found = VE<bool>(V);m_prev = VE<T>(V,m_not_found);}TE <TY T,TY GRAPH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Initialise(CO T& init){auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < SZ());Initialise();m_next.push_back(init);m_found[i]= true;}TE <TY T,TY GRAPH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Initialise(LI<T> inits){Initialise();m_next = MO(inits);CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);m_found[i]= true;}}TE <TY T,TY GRAPH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Shift(CO T& init){if(m_initialised){CRI V = SZ();auto&& i = m_G.Enumeration_inv(init);AS(0 <= i && i < V);m_next.clear();if(! m_found[i]){m_next.push_back(init);m_found[i]= true;}}else{Initialise(init);}}TE <TY T,TY GRAPH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Shift(LI<T> inits){if(m_initialised){m_next.clear();CRI V = SZ();for(auto& u:m_next){auto&& i = m_G.Enumeration_inv(u);AS(0 <= i && i < V);if(! m_found[i]){m_next.push_back(u);m_found[i]= true;}}}else{Initialise(MO(inits));}}TE <TY T,TY GRAPH> IN CRI VirtualBreadthFirstSearch<T,GRAPH>::SZ()CO NE{RE m_G.SZ();}TE <TY T,TY GRAPH> IN VE<bool>::reference VirtualBreadthFirstSearch<T,GRAPH>::found(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_found[i];}TE <TY T,TY GRAPH> IN CO T& VirtualBreadthFirstSearch<T,GRAPH>::prev(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(0 <= i && i < SZ());if(!m_initialised){Initialise();}RE m_prev[i];}TE <TY T,TY GRAPH> IN T VirtualBreadthFirstSearch<T,GRAPH>::Next(){if(m_next.empty()){RE m_not_found;}CO T t_curr = m_next.front();m_next.pop_front();auto&& edge = m_G.Edge(t_curr);for(auto& t:edge){auto&& i = m_G.Enumeration_inv(t);auto&& found_i = m_found[i];if(! found_i){Push(m_next,t);m_prev[i]= t_curr;found_i = true;}}RE t_curr;}TE <TY T,TY GRAPH> TE <TY U>auto VirtualBreadthFirstSearch<T,GRAPH>::GetDistance()-> enable_if_t<is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,Map<T,int>>{Map<T,int> AN{};for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[*IT]= 0;}T t;WH((t = Next())!= m_not_found){if(AN.count(t) == 0){AN[t]= AN[m_prev[m_G.Enumeration_inv(t)]]+ 1;}}RE AN;}TE <TY T,TY GRAPH> TE <TY U>auto VirtualBreadthFirstSearch<T,GRAPH>::GetDistance()-> enable_if_t<!is_same_v<GRAPH,MemorisationGraph<U,decldecay_t(declval<GRAPH>().edge())>>,VE<int>>{VE AN(SZ(),-1);for(auto IT = m_next.BE(),EN = m_next.EN();IT != EN;IT++){AN[m_G.Enumeration_inv(*IT)]= 0;}T t;WH((t = Next())!= m_not_found){auto&& i = m_G.Enumeration_inv(t);int& AN_i = AN[i];AN_i == -1?AN_i = AN[m_G.Enumeration_inv(m_prev[i])]+ 1:AN_i;}RE AN;}TE <TY T,TY GRAPH>pair<VE<int>,int> VirtualBreadthFirstSearch<T,GRAPH>::GetConnectedComponent(){ST_AS(!is_same_v<GRAPH,MemorisationGraph<T,decldecay_t(m_G.edge())>>);CRI V = SZ();VE cc_num(V,-1);int count = 0;for(int i = 0;i < V;i++){if(cc_num[i]== -1){Shift(m_G.Enumeration(i));T t = Next();if(t != m_not_found){WH(t != m_not_found){cc_num[m_G.Enumeration_inv(t)]= count;t = Next();}count++;}}}RE{MO(cc_num),MO(count)};}TE <TY T,TY GRAPH> TE <TY PATH> IN VO VirtualBreadthFirstSearch<T,GRAPH>::Push(LI<T>& next,CO PATH& p){Push(next,get<0>(p));}

TE <TY T,TY GRAPH>CL BreadthFirstSearch:PU VirtualBreadthFirstSearch<T,GRAPH>{PU:TE <TY...Args> IN BreadthFirstSearch(GRAPH& G,CO T& not_found,Args&&... args);IN VO Push(LI<T>& next,CO T& t);};
TE <TY T,TY GRAPH> TE <TY...Args> IN BreadthFirstSearch<T,GRAPH>::BreadthFirstSearch(GRAPH& G,CO T& not_found,Args&&... args):VirtualBreadthFirstSearch<T,GRAPH>(G,not_found,forward<Args>(args)...){}TE <TY T,TY GRAPH> IN VO BreadthFirstSearch<T,GRAPH>::Push(LI<T>& next,CO T& t){next.push_back(t);}

CL HopcroftKarp{PU:TE <TY Edge> VE<pair<int,int>> GetMaximumMatching(CRI S,CRI T,Edge edge);};
TE <TY Edge> VE<pair<int,int>> HopcroftKarp::GetMaximumMatching(CRI S,CRI T,Edge edge){ST_AS(is_invocable_r_v<VE<int>,Edge,CRI>);unordered_set<int> unchosen_source{};VE<int> prev(T,-1);for(int s = 0;s < S;s++){unchosen_source.insert(s);}auto edge_shifted =[&](CRI w){VE<int> AN{};if(w == 0){for(auto& us:unchosen_source){AN.push_back(1 + us);}}else if(w <= S){auto&& edge_w = edge(w - 1);AN.reserve(edge_w.SZ());for(auto& t:edge_w){AN.push_back(1 + S + t);}}else{CO int t = w - 1 - S;AS(t < T);CRI s = prev[t];if(s != -1){AS(0 <= s && s < S);AN.push_back(1 + s);}}RE AN;};Graph graph{1 + S + T,MO(edge_shifted)};BreadthFirstSearch bfs{graph,-1};VE<bool> chosen_source(S);VE<bool> chosen_target(T);VE<unordered_map<int,bool>> chosen_edge(S);VE<int> depth(1 + S + T);int depth_min = -1;VE<int> root(S + T);VE<int> new_chosen_target{0};int v,w;bool found;WH(! new_chosen_target.empty()){new_chosen_target.clear();bfs.Initialise(0);v = bfs.Next();found = false;WH((v = bfs.Next())!= -1){w = bfs.prev(v);int& depth_v = depth[v]= depth[w]+ 1;if(found && depth_v > depth_min){break;}if(w == 0){CO int s = v - 1;AS(0 <= s && s < S);root[s]= s;}else{root[v - 1]= root[w - 1];}if((depth_v & 1)== 0){CO int t = v - 1 - S;AS(0 <= t && t < T);auto&& chosen_target_t = chosen_target[t];if(!chosen_target_t){CRI s = root[v - 1];AS(0 <= s && s < S);auto&& chosen_source_s = chosen_source[s];if(!chosen_source_s){chosen_source_s = true;chosen_target_t = true;new_chosen_target.push_back(v);if(!found){found = true;depth_min = depth_v;}}}}}for(auto& nct:new_chosen_target){int* p[2]={&w,&v};int*& p0 = p[0];int*& p1 = p[1];v = nct;WH((w = bfs.prev(v))!= 0){CO int s = *p0 - 1;CO int t = *p1 - 1 - S;AS(0 <= s && s < S && 0 <= t && t < T);if(chosen_edge[s][t]^= true){prev[t]= s;}swap(w,v);swap(p0,p1);}CO int s = v - 1;AS(0 <= s && s < S && unchosen_source.count(s)== 1);unchosen_source.erase(s);}}VE<pair<int,int>> AN{};for(int t = 0;t < T;t++){CRI s = prev[t];if(s != -1){AS(0 <= s && s < S && 0 <= t && t < T);AN.push_back({s,t});}}RE AN;}
#endif
