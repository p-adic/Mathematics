#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/Dijkstra/Potentialised/MinimumCostFlow/a_Body.hpp"
#else
TE <TY U,TY MONOID,TY SEMIGROUP>CL VirtualSemirng{PU:VI U Sum(CO U& u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(CO U& u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY U,TY MONOID,TY SEMIGROUP>CL AbstractSemirng:VI PU VirtualSemirng<U,MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(CO U& u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(CO U& u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY U>CL Semirng:PU AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY U,TY MONOID,TY SEMIGROUP> IN AbstractSemirng<U,MONOID,SEMIGROUP>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Sum(CO U& u0,CO U& u1){RE m_R0.Sum(u0,u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN CO U& AbstractSemirng<U,MONOID,SEMIGROUP>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Product(CO U& u0,CO U& u1){RE m_R1.Product(u0,u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN MONOID& AbstractSemirng<U,MONOID,SEMIGROUP>::AdditiveMonoid()NE{RE m_R0;}TE <TY U,TY MONOID,TY SEMIGROUP> IN SEMIGROUP& AbstractSemirng<U,MONOID,SEMIGROUP>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY U,TY GROUP,TY MONOID>CL VirtualRing:VI PU VirtualSemirng<U,GROUP,MONOID>{PU:VI U Inverse(CO U& u)= 0;VI CO U& One()CO NE = 0;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY U,TY GROUP,TY MONOID>CL AbstractRing:VI PU VirtualRing<U,GROUP,MONOID>,PU AbstractSemirng<U,GROUP,MONOID>{PU:IN AbstractRing(GROUP R0,MONOID R1);IN U Inverse(CO U& u);IN CO U& One()CO NE;};TE <TY U = ll>CL Ring:VI PU AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(CO U& one_U);};
TE <TY U,TY GROUP,TY MONOID> IN AbstractRing<U,GROUP,MONOID>::AbstractRing(GROUP R0,MONOID R1):AbstractSemirng<U,GROUP,MONOID>(MO(R0),MO(R1)){}TE <TY U> IN Ring<U>::Ring(CO U& one_U):AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(one_U)){}TE <TY U,TY GROUP,TY MONOID> IN U AbstractRing<U,GROUP,MONOID>::Inverse(CO U& u){RE TH->m_R0.Inverse(u);}TE <TY U,TY GROUP,TY MONOID> IN CO U& AbstractRing<U,GROUP,MONOID>::One()CO NE{RE TH->m_R1.One();}TE <TY U,TY GROUP,TY MONOID> IN GROUP& VirtualRing<U,GROUP,MONOID>::AdditiveGroup()NE{RE TH->AdditiveMonoid();}TE <TY U,TY GROUP,TY MONOID> IN MONOID& VirtualRing<U,GROUP,MONOID>::MultiplicativeMonoid()NE{RE TH->MultiplicativeSemigroup();}

#define DIJKSTRA_PREP(INITIALISE_PREV)CO U& one = m_M.One();AS(one < infty);auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);INITIALISE_PREV;
#define DIJKSTRA_BODY_1(SET_PREV)if(path_LE == -1){path_LE = SZ;}weight[i_start]= one;int i = i_start;for(int num = 0;num < path_LE;num++){if(fixed[i]){break;}fixed[i]= true;CO U& weight_i = weight[i];auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto&& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(get<0>(edge_ij));if(!fixed[j]){CO U& w_ij = get<1>(edge_ij);U temp = m_M.Product(weight_i,w_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){SET_PREV;weight_j = MO(temp);}}}U temp = infty;for(int j = 0;j < SZ;j++){if(!fixed[j]){U& weight_j = weight[j];if(weight_j < temp){temp = weight_j;i = j;}}}}
#define DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV)AS(path_LE == -1);set<pair<U,int>> vertex{};vertex.insert(pair<U,int>(weight[i_start]= one,i_start));WH(! vertex.empty()){auto BE = vertex.BE();auto[weight_i,i]= *BE;CHECK_FINAL;fixed[i]= true;vertex.erase(BE);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));VE<pair<U,int>> changed_vertex{};for(auto&& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(get<0>(edge_ij));if(!fixed[j]){CO U& w_ij = get<1>(edge_ij);U temp = m_M.Product(weight_i,w_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){if(weight_j != infty){vertex.erase(pair<U,int>(weight_j,j));}SET_PREV;changed_vertex.push_back(pair<U,int>(weight_j = MO(temp),j));}}}for(auto& v:changed_vertex){vertex.insert(v);}}
#define DIJKSTRA_BODY(INITIALISE_PREV,CHECK_FINAL,SET_PREV)DIJKSTRA_PREP(INITIALISE_PREV);if(many_edges){DIJKSTRA_BODY_1(SET_PREV);}else{DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV);}
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>CL AbstractDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;COMM_MONOID m_M;IN AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty);U GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = false,int path_LE = -1);VE<U> GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges = false,int path_LE = -1);VO SetDistance(VE<U>& weight,VE<bool>& fixed,CO inner_t<GRAPH>& t_start,CO bool& many_edges = false,int path_LE = -1);pair<U,LI<inner_t<GRAPH>>> GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = false,int path_LE = -1);TE <TE <TY...> TY V> pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges = false,int path_LE = -1);pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges = false,int path_LE = -1);};TE <TY GRAPH,TY U,TY COMM_MONOID> AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty)-> AbstractDijkstra<inner_t<GRAPH>,GRAPH,U,COMM_MONOID>;TE <TY T,TY GRAPH>CL Dijkstra:PU AbstractDijkstra<T,GRAPH,ll,AdditiveMonoid<>>{PU:IN Dijkstra(GRAPH& G,CRL infty = 1e18);};TE <TY GRAPH,TY...ARGS> Dijkstra(GRAPH& G,CO ARGS&... args)-> Dijkstra<inner_t<GRAPH>,GRAPH>;
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> IN AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){}TE <TY T,TY GRAPH> IN Dijkstra<T,GRAPH>::Dijkstra(GRAPH& G,CRL infty):AbstractDijkstra<T,GRAPH,ll,AdditiveMonoid<>>(G,AdditiveMonoid<>(),infty){}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>U AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(,if(i == i_final){break;},);U AN{MO(weight[i_final])};RE AN;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>VE<U> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(,,);RE weight;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>VO AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::SetDistance(VE<U>& weight,VE<bool>& fixed,CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();AS(int(weight.SZ())== SZ);AS(int(fixed.SZ())== SZ);DIJKSTRA_BODY(,,);RE;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>pair<U,LI<inner_t<GRAPH>>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(VE<int> prev(SZ),if(i == i_final){break;},prev[j]= i);int i = i_final;LI<inner_t<GRAPH>> path{};path.push_back(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path.push_front(m_G.Enumeration(i));}}U AN{MO(weight[i_final])};RE{MO(AN),MO(path)};}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> TE <TE <TY...> TY V>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(VE<int> prev(SZ),,prev[j]= i);CO int path_SZ = t_finals.SZ();VE<LI<inner_t<GRAPH>>> path;path.reserve(path_SZ);for(auto IT = t_finals.BE(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(weight),MO(path)};}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals,many_edges,path_LE);}

#define POTENTIALISED_DIJKSTRA_BODY(GET,WEIGHT)CO U& infty = TH->Infty();CO U& zero = m_M.Zero();auto edge =[&](CO T& t){CO U& potential_i = m_potential[m_G.Enumeration_inv(t)];AS(potential_i < infty);auto edge_i = m_G.Edge(t);VE<pair<T,U>> AN{};for(auto& e:edge_i){if(m_on(e)){CO auto& v_j = get<0>(e);U& w_j = get<1>(e);CO U& potential_j = m_potential[m_G.Enumeration_inv(v_j)];AS(w_j < infty && potential_j < infty);CO U potential_j_inv = m_M.Inverse(potential_j);w_j = m_M.Sum(m_M.Sum(w_j,potential_i),potential_j_inv);AS(!(w_j < zero)&& w_j < infty);AN.push_back({v_j,MO(w_j)});}}RE AN;};auto G = m_G.GetGraph(MO(edge));AbstractDijkstra d{G,m_M,infty};auto value = d.GET;CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){auto& weight_i = WEIGHT[i];if(weight_i != infty){weight_i = m_M.Sum(weight_i,m_potential[i]);}}RE value;
TE <TY T,TY GRAPH,TY U,TY GROUP,TY On>CL AbstractPotentialisedDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;GROUP m_M;T m_t_start;On m_on;VE<U> m_potential;IN AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,VE<U> potential ={});IN CO VE<U>& Potential()CO NE;IN VO SetPotential(VE<U> potential);TE <TY...Args> VE<U> GetDistance(Args&&... args);TE <TY...Args> pair<VE<U>,VE<LI<T>>> GetPath(Args&&... args);};TE <TY T,TY GRAPH,TY On>CL PotentialisedDijkstra:PU AbstractPotentialisedDijkstra<T,GRAPH,ll,AdditiveGroup<>,On>{PU:TE <TY...Args> IN PotentialisedDijkstra(GRAPH& G,CO T& t_start,On on,Args&&... args);};
TE <TY T,TY GRAPH,TY U,TY GROUP,TY On> IN AbstractPotentialisedDijkstra<T,GRAPH,U,GROUP,On>::AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,VE<U> potential):PointedSet<U>(infty),m_G(G),m_M(MO(M)),m_t_start(t_start),m_on(MO(on)),m_potential(potential){ST_AS(is_invocable_r_v<bool,On,decltype(declval<GRAPH>().Edge(declval<T>()).back())>);if(m_potential.empty()){m_potential = VE<U>(m_G.SZ(),m_M.Zero());}else{AS(int(m_potential.SZ())== m_G.SZ());}}TE <TY T,TY GRAPH,TY On> TE <TY...Args> IN PotentialisedDijkstra<T,GRAPH,On>::PotentialisedDijkstra(GRAPH& G,CO T& t_start,On on,Args&&... args):AbstractPotentialisedDijkstra<T,GRAPH,ll,AdditiveGroup<>,On>(G,AdditiveGroup<>(),t_start,1e18,MO(on),forward<decay_t<Args>>(args)...){}TE <TY T,TY GRAPH,TY U,TY GROUP,TY On> IN CO VE<U>& AbstractPotentialisedDijkstra<T,GRAPH,U,GROUP,On>::Potential()CO NE{RE m_potential;}TE <TY T,TY GRAPH,TY U,TY GROUP,TY On> IN VO AbstractPotentialisedDijkstra<T,GRAPH,U,GROUP,On>::SetPotential(VE<U> potential){AS(int(potential.SZ())== m_G.SZ());m_potential = MO(potential);}TE <TY T,TY GRAPH,TY U,TY GROUP,TY On> TE <TY...Args> VE<U> AbstractPotentialisedDijkstra<T,GRAPH,U,GROUP,On>::GetDistance(Args&&... args){POTENTIALISED_DIJKSTRA_BODY(GetDistance(m_t_start,forward<Args>(args)...),value);}TE <TY T,TY GRAPH,TY U,TY GROUP,TY On> TE <TY...Args> pair<VE<U>,VE<LI<T>>> AbstractPotentialisedDijkstra<T,GRAPH,U,GROUP,On>::GetPath(Args&&... args){POTENTIALISED_DIJKSTRA_BODY(GetPath(m_t_start,forward<Args>(args)...),get<0>(value));}

TE <TY T,TY GRAPH,TY U,TY RING>CL AbstractMinimumCostFlow{PU:GRAPH& m_G;RING m_R;U m_infty;VE<VE<tuple<int,U,U,int>>> m_full;VE<VE<tuple<T,U>>> m_flow;VE<VE<int>> m_edge_num;VE<VE<int>> m_edge_rev_num;IN AbstractMinimumCostFlow(GRAPH& G,RING R,CO U& infty);pair<U,VE<VE<tuple<T,U>>>> GetFlow(CO T& t_start,CO T& t_final,U f,CO bool& many_edges = false,int path_LE = -1);};TE <TY GRAPH,TY U,TY RING> AbstractMinimumCostFlow(GRAPH& G,RING R,CO U& infty)-> AbstractMinimumCostFlow<inner_t<GRAPH>,GRAPH,U,RING>;TE <TY T,TY GRAPH,TY U>CL MinimumCostFlow:PU AbstractMinimumCostFlow<T,GRAPH,U,Ring<U>>{PU:IN MinimumCostFlow(GRAPH& G,CO U& one_U,CO U& infty);};TE <TY GRAPH,TY U> MinimumCostFlow(GRAPH& G,CO U& one_U,CO U& infty)-> MinimumCostFlow<inner_t<GRAPH>,GRAPH,U>;
TE <TY T,TY GRAPH,TY U,TY RING> IN AbstractMinimumCostFlow<T,GRAPH,U,RING>::AbstractMinimumCostFlow(GRAPH& G,RING R,CO U& infty):m_G(G),m_R(MO(R)),m_infty(infty),m_full(),m_flow(),m_edge_num(),m_edge_rev_num(){CO U& zero = m_R.Zero();CRI SZ = m_G.SZ();m_full.resize(SZ);m_flow.resize(SZ);m_edge_num.resize(SZ,VE<int>(SZ,-1));m_edge_rev_num.resize(SZ,VE<int>(SZ,-1));for(int i = 0;i < SZ;i++){auto&& vi = m_G.Enumeration(i);for(auto&[vj,wj,fj]:m_G.Edge(vi)){AS(vi != vj && !(wj < zero)&& wj < m_infty && !(fj < zero)&& fj < m_infty);if(zero < fj){auto&& j = m_G.Enumeration_inv(vj);AS(m_edge_num[i][j]== -1);m_edge_num[i][j]= m_full[i].SZ();AS(m_edge_rev_num[j][i]== -1);m_edge_rev_num[j][i]= m_full[j].SZ();CO int flow_i_SZ = m_flow[i].SZ();m_full[i].push_back({j,wj,fj,flow_i_SZ});m_full[j].push_back({i,m_R.Inverse(wj),zero,flow_i_SZ});m_flow[i].push_back({vj,zero});if(m_edge_num[j][i]!= -1){swap(m_full[j][m_edge_num[j][i]],m_full[j][m_edge_rev_num[j][i]]);swap(m_edge_num[j][i],m_edge_rev_num[j][i]);}}}}}TE <TY T,TY GRAPH,TY U> IN MinimumCostFlow<T,GRAPH,U>::MinimumCostFlow(GRAPH& G,CO U& one_U,CO U& infty):AbstractMinimumCostFlow<T,GRAPH,U,Ring<U>>(G,Ring<U>(one_U),infty){}TE <TY T,TY GRAPH,TY U,TY RING>pair<U,VE<VE<tuple<T,U>>>> AbstractMinimumCostFlow<T,GRAPH,U,RING>::GetFlow(CO T& t_start,CO T& t_final,U f,CO bool& many_edges,int path_LE){CO U& zero = m_R.Zero();auto rest = m_full;auto flow = m_flow;auto edge =[&](CO T& t)-> CO VE<tuple<int,U,U,int>>&{RE rest[m_G.Enumeration_inv(t)];};auto on =[&](CO tuple<T,U,U,int>& e){RE zero < get<2>(e);};auto G = m_G.GetGraph(MO(edge));AbstractPotentialisedDijkstra pd{G,m_R.AdditiveGroup(),t_start,m_infty,MO(on)};auto&& i_start = m_G.Enumeration_inv(t_start);auto&& i_final = m_G.Enumeration_inv(t_final);CO VE<T> t_finals ={t_final};U w = zero;WH(zero < f){auto[weight,paths]= pd.GetPath(t_finals,many_edges,path_LE);CO U w_min = weight[i_final];pd.SetPotential(MO(weight));auto& path = paths.front();auto IT_path = path.BE(),IT_path_prev = IT_path,EN_path = path.EN();int i = i_start;U f_min = f;VE<tuple<U*,U*,U*,bool>> update{};update.reserve(path.SZ()- 1);WH(++IT_path != EN_path){auto&& j = m_G.Enumeration_inv(*IT_path);bool reversed = false;if(m_edge_rev_num[i][j]!= -1){auto&[j_copy,w_rev_ij,f_rev_ij,flow_num_ji]= rest[i][m_edge_rev_num[i][j]];if(zero < f_rev_ij){f_min = min(f_min,f_rev_ij);update.push_back({&f_rev_ij,&(get<2>(rest[j][m_edge_num[j][i]])),&(get<1>(flow[j][flow_num_ji])),reversed = true});}}if(!reversed){auto&[j_copy,w_ij,f_ij,flow_num_ij]= rest[i][m_edge_num[i][j]];f_min = min(f_min,f_ij);update.push_back({&f_ij,&(get<2>(rest[j][m_edge_rev_num[j][i]])),&(get<1>(flow[i][flow_num_ij])),reversed});}IT_path_prev = IT_path;i = j;}CO U f_min_inv = m_R.Inverse(f_min);f = m_R.Sum(f,f_min_inv);w = m_R.Sum(w,m_R.Product(f_min,w_min));for(auto&[p_f,p_f_rev,p_flow,reversed]:update){*p_f = m_R.Sum(MO(*p_f),f_min_inv);*p_f_rev = m_R.Sum(MO(*p_f_rev),f_min);*p_flow = m_R.Sum(MO(*p_flow),reversed?f_min_inv:f_min);}}RE{MO(w),MO(flow)};}
#endif

