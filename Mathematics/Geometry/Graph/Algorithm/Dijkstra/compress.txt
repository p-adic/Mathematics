#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/Dijkstra/Debug/a_Body.hpp"
#else
#define DIJKSTRA_PREP(INITIALISE_PREV)CO U& one = m_M.One();AS(one < infty);auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);INITIALISE_PREV;
#define DIJKSTRA_BODY_1(SET_PREV)if(path_LE == -1){path_LE = SZ;}weight[i_start]= one;int i = i_start;for(int num = 0;num < path_LE;num++){if(fixed[i]){break;}fixed[i]= true;CO U& weight_i = weight[i];auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto&& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(get<0>(edge_ij));if(!fixed[j]){CO U& w_ij = get<1>(edge_ij);U temp = m_M.Product(weight_i,w_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){SET_PREV;weight_j = MO(temp);}}}U temp = infty;for(int j = 0;j < SZ;j++){if(!fixed[j]){U& weight_j = weight[j];if(weight_j < temp){temp = weight_j;i = j;}}}}
#define DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV)AS(path_LE == -1);set<pair<U,int>> vertex{};vertex.insert(pair<U,int>(weight[i_start]= one,i_start));WH(! vertex.empty()){auto BE = vertex.BE();auto[weight_i,i]= *BE;CHECK_FINAL;fixed[i]= true;vertex.erase(BE);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));VE<pair<U,int>> changed_vertex{};for(auto&& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(get<0>(edge_ij));if(!fixed[j]){CO U& w_ij = get<1>(edge_ij);U temp = m_M.Product(weight_i,w_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){if(weight_j != infty){vertex.erase(pair<U,int>(weight_j,j));}SET_PREV;changed_vertex.push_back(pair<U,int>(weight_j = MO(temp),j));}}}for(auto& v:changed_vertex){vertex.insert(v);}}
#define DIJKSTRA_BODY(INITIALISE_PREV,CHECK_FINAL,SET_PREV)DIJKSTRA_PREP(INITIALISE_PREV);if(many_edges){DIJKSTRA_BODY_1(SET_PREV);}else{DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV);}
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>CL AbstractDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;COMM_MONOID m_M;IN AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty);U GetDistance(CO T& t_start,CO T& t_final,CO bool& many_edges = false,int path_le = -1);VE<U> GetDistance(CO T& t_start,CO bool& many_edges = false,int path_le = -1);VO SetDistance(VE<U>& weight,VE<bool>& fixed,CO T& t_start,CO bool& many_edges = false,int path_le = -1);pair<U,LI<T>> GetPath(CO T& t_start,CO T& t_final,CO bool& many_edges = false,int path_le = -1);TE <TE <TY...> TY V> pair<VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges = false,int path_le = -1);pair<VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO bool& many_edges = false,int path_le = -1);};TE <TY GRAPH,TY U,TY COMM_MONOID> AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty)-> AbstractDijkstra<inner_t<GRAPH>,GRAPH,U,COMM_MONOID>;TE <TY T,TY GRAPH>CL Dijkstra:PU AbstractDijkstra<T,GRAPH,ll,AdditiveMonoid<>>{PU:IN Dijkstra(GRAPH& G,CRL infty = 1e18);};TE <TY GRAPH,TY...ARGS> Dijkstra(GRAPH& G,CO ARGS&... args)-> Dijkstra<inner_t<GRAPH>,GRAPH>;
TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> IN AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(is_same_v<T,inner_t<GRAPH>>);}TE <TY T,TY GRAPH> IN Dijkstra<T,GRAPH>::Dijkstra(GRAPH& G,CRL infty):AbstractDijkstra<T,GRAPH,ll,AdditiveMonoid<>>(G,AdditiveMonoid<>(),infty){}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>U AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetDistance(CO T& t_start,CO T& t_final,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(,if(i == i_final){break;},);U AN{MO(weight[i_final])};RE AN;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>VE<U> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetDistance(CO T& t_start,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(,,);RE weight;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>VO AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::SetDistance(VE<U>& weight,VE<bool>& fixed,CO T& t_start,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();AS(int(weight.SZ())== SZ);AS(int(fixed.SZ())== SZ);DIJKSTRA_BODY(,,);RE;}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>pair<U,LI<T>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO T& t_start,CO T& t_final,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(VE<int> prev(SZ),if(i == i_final){break;},prev[j]= i);int i = i_final;LI<T> path{};path.push_back(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path.push_front(m_G.Enumeration(i));}}U AN{MO(weight[i_final])};RE{MO(AN),MO(path)};}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID> TE <TE <TY...> TY V>pair<VE<U>,VE<LI<T>>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(VE<int> prev(SZ),,prev[j]= i);CO int path_SZ = t_finals.SZ();VE<LI<T>> path;path.reserve(path_SZ);for(auto IT = t_finals.BE(),EN = t_finals.EN();IT != EN;IT++){LI<T> path_j{};CO T& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(weight),MO(path)};}TE <TY T,TY GRAPH,TY U,TY COMM_MONOID>pair<VE<U>,VE<LI<T>>> AbstractDijkstra<T,GRAPH,U,COMM_MONOID>::GetPath(CO T& t_start,CO bool& many_edges,int path_le){CRI SZ = m_G.SZ();VE<T> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals,many_edges,path_le);}
#endif

