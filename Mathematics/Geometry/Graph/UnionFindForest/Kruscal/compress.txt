// êÊÇ…../../../../Algebra/compress.txtÇì\ÇÈÅB

TE <TY U,TY GROUP>CL AbstractUnionFindForest{PU:GROUP m_M;int m_node_SZ;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;IN AbstractUnionFindForest(CRI SZ,GROUP M);CRI RootOfNode(CRI num);TE <TE <TY...> TY V> VO SetRoot(V<int>& a)CO;IN U Potential(CRI num0,CRI num1);IN CRI SZ(CO bool& node = true)CO NE;bool Graft(CRI num0,CRI num1,CO U& w = 0);};TE <TY GROUP> AbstractUnionFindForest(CRI SZ,GROUP M)-> AbstractUnionFindForest<inner_t<GROUP>,GROUP>;TE <TY U = int>CL UnionFindForest:PU AbstractUnionFindForest<U,AdditiveGroup<U>>{PU:IN UnionFindForest(CRI SZ);};
TE <TY U,TY GROUP> IN AbstractUnionFindForest<U,GROUP>::AbstractUnionFindForest(CRI SZ,GROUP M):m_M(MO(M)),m_node_SZ(SZ),m_root_SZ(m_node_SZ),m_pred(m_node_SZ),m_height(m_node_SZ,1),m_w(m_node_SZ,m_M.Zero()){for(int i = 0;i < m_node_SZ;i++){m_pred[i]= i;}}TE <TY U> IN UnionFindForest<U>::UnionFindForest(CRI SZ):AbstractUnionFindForest<U,AdditiveGroup<U>>(SZ,AdditiveGroup<U>()){}TE <TY U,TY GROUP>CRI AbstractUnionFindForest<U,GROUP>::RootOfNode(CRI num){int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));pred1 = pred2 = m_pred[pred2];}RE pred1;}TE <TY U,TY GROUP> TE <TE <TY...> TY V>VO AbstractUnionFindForest<U,GROUP>::SetRoot(V<int>& a)CO{a.clear();for(int i = 0;i < m_node_SZ;i++){if(i == m_pred[i]){a.push_back(i);}}RE;}TE <TY U,TY GROUP>U AbstractUnionFindForest<U,GROUP>::Potential(CRI num0,CRI num1){AS(num0 < m_node_SZ && num1 < m_node_SZ);CRI root0 = RootOfNode(num0);CRI root1 = RootOfNode(num1);AS(root0 == root1);RE m_M.Sum(m_w[num0],m_M.Inverse(m_w[num1]));}TE <TY U,TY GROUP> IN CRI AbstractUnionFindForest<U,GROUP>::SZ(CO bool& node)CO NE{RE node?m_node_SZ:m_root_SZ;}TE <TY U,TY GROUP>bool AbstractUnionFindForest<U,GROUP>::Graft(CRI num0,CRI num1,CO U& w){AS(num0 < m_node_SZ && num1 < m_node_SZ);CRI root0 = RootOfNode(num0);CRI root1 = RootOfNode(num1);if(root0 == root1){RE Potential(num0,num1)== w;}int& height0 = m_height[root0];CRI height1 = m_height[root1];CO int* p_reMOd_root;CO int* p_reMOd_node;CO int* p_kept_root;if(height0 < height1){p_reMOd_root = &root0;p_reMOd_node = &num0;p_kept_root = &root1;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}p_reMOd_root = &root1;p_reMOd_node = &num1;p_kept_root = &root0;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(*p_reMOd_node != *p_reMOd_root){m_w[*p_reMOd_node]= m_M.Sum(m_w[*p_reMOd_node],m_w[*p_reMOd_root]);}m_pred[*p_reMOd_node]= m_pred[*p_reMOd_root]= *p_kept_root;m_root_SZ--;RE true;}

TE <TY GRAPH>LI<tuple<int,int,int>> SortedEdge(GRAPH& G,CO VE<pair<int,int>>& E){US PATH = decldecay_t(declval<GRAPH>().edge()(0).back());US T = inner_t<GRAPH>;US U = decldecay_t(get<1>(declval<PATH>()));ST_AS(is_same_v<T,decldecay_t(get<0>(declval<PATH>()))> && is_same_v<int,decldecay_t(get<2>(declval<PATH>()))>);CRI V = G.SZ();LI<pair<U,int>> weight{};for(int i = 0;i < V;i++){auto&& t = G.Enumeration(i);auto&& edge_i = G.Edge(t);for(auto& edge_ij:edge_i){weight.push_back({get<1>(edge_ij),get<2>(edge_ij)});}}weight.sort();LI<tuple<int,int,int>> E_sorted{};for(auto& weight_n:weight){int& n = weight_n.second;auto&[i,j]= E[n];E_sorted.push_back({i,j,n});}RE E_sorted;}TE <TY On>pair<VE<int>,int> Kruscal(CRI V,CO VE<pair<int,int>>& E,CO LI<tuple<int,int,int>>& E_sorted,CO On& on,VE<int> AN ={}){ST_AS(is_invocable_r_v<bool,On,int>);UnionFindForest<> uff{V};for(auto& n:AN){auto&[i,j]= E[n];if(! on(n)|| uff.RootOfNode(i)== uff.RootOfNode(j)){RE{{},-1};}else{uff.Graft(i,j);}}AN.reserve(V - 1);for(auto&[i,j,n]:E_sorted){if(on(n)){if(uff.RootOfNode(i)!= uff.RootOfNode(j)){uff.Graft(i,j);AN.push_back(n);}}}RE{MO(AN),uff.SZ(false)};}TE <TY GRAPH> IN pair<VE<int>,int> Kruscal(GRAPH& G,CO VE<pair<int,int>>& E,VE<int> AN ={}){RE Kruscal(G.SZ(),E,SortedEdge(G,E),[&](CRI){RE true;},AN);}
