#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/UnionFindForest/a_Body.hpp"
#else
CL DiscreteEdge{PU:IN VE<int> OP()(CRI);};CL DiscreteGraph:PU Graph<DiscreteEdge>{PU:IN DiscreteGraph(CRI SZ);};
IN VE<int> DiscreteEdge::OP()(CRI){RE{};}IN DiscreteGraph::DiscreteGraph(CRI SZ):Graph<DiscreteEdge>(SZ,DiscreteEdge()){}

TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractUnionFindForest{PU:GRAPH& m_G;ABEL_GROUP m_M;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M);CO decltype((declval<GRAPH>().Enumeration(0)))RootOfNode(CO T&);TE <TE <TY...> TY V> VE<T> GetRoot()CO;IN U Potential(CO T& t0,CO T& t1);IN CRI SZ(CO bool& node = true)CO NE;bool Graft(CO T& t0,CO T& t1,CO U& w = U());TE <TY PATH> IN bool Graft(CO T& t0,CO PATH& t1);};TE <TY GRAPH,TY ABEL_GROUP> AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M)-> AbstractUnionFindForest<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY U = int>CL UnionFindForest:PU AbstractUnionFindForest<int,DiscreteGraph,U,AdditiveGroup<U>>{PU:IN UnionFindForest(CRI SZ);};
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)),m_root_SZ(m_G.SZ()),m_pred(m_root_SZ),m_height(m_root_SZ,1),m_w(m_root_SZ,m_M.Zero()){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_pred[i]= i;}for(int i = 0;i < SZ;i++){auto&& s = m_G.Enumeration(i);for(auto& t:m_G.Edge(s)){Graft(s,t);}}}TE <TY U> IN UnionFindForest<U>::UnionFindForest(CRI SZ):AbstractUnionFindForest<int,DiscreteGraph,U,AdditiveGroup<U>>(DiscreteGraph(SZ),AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CO decltype((declval<GRAPH>().Enumeration(0)))AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::RootOfNode(CO T& t){auto&& num = m_G.Enumeration_inv(t);int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));pred1 = pred2 = m_pred[pred2];}RE m_G.Enumeration(pred1);}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TE <TY...> TY V>VE<T> AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::GetRoot()CO{VE<T> AN{};AN.reserve(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){if(i == m_pred[i]){AN.push_back(m_G.Enumeration(i));}}RE AN;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>U AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Potential(CO T& t0,CO T& t1){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);AS(root0 == root1);RE m_M.Sum(m_w[m_G.Enumeration_inv(t0)],m_M.Inverse(m_w[m_G.Enumeration_inv(t1)]));}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN CRI AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::SZ(CO bool& node)CO NE{RE node?m_G.SZ():m_root_SZ;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO T& t1,CO U& w){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);if(root0 == root1){RE Potential(t0,t1)== w;}auto&& num0 = m_G.Enumeration_inv(t0);auto&& num1 = m_G.Enumeration_inv(t1);auto&& rnum0 = m_G.Enumeration_inv(root0);auto&& rnum1 = m_G.Enumeration_inv(root1);int& height0 = m_height[rnum0];CRI height1 = m_height[rnum1];CO int* p_reMOd_root;CO int* p_reMOd_node;CO int* p_kept_root;if(height0 < height1){p_reMOd_root = &rnum0;p_reMOd_node = &num0;p_kept_root = &rnum1;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}p_reMOd_root = &rnum1;p_reMOd_node = &num1;p_kept_root = &rnum0;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(*p_reMOd_node != *p_reMOd_root){m_w[*p_reMOd_node]= m_M.Sum(m_w[*p_reMOd_node],m_w[*p_reMOd_root]);}m_pred[*p_reMOd_node]= m_pred[*p_reMOd_root]= *p_kept_root;m_root_SZ--;RE true;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TY PATH> IN bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO PATH& t1){RE Graft(t0,get<0>(t1),get<1>(t1));}
#endif

