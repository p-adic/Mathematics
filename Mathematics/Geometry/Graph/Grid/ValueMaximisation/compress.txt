#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Grid/ValueMaximisation/a_Body.hpp"
#else
TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

TE <TY R,TY PT_MAGMA,TY U,TY R_SET>CL DualSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:PT_MAGMA m_L;R_SET m_X;VE<U> m_a;VE<R> m_b;TE <TY...Args> IN DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a ={},CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);TE <TY Arg> IN VO IntervalAct(CRI i_start,CRI i_final,CO Arg& r);IN U OP[](CRI i);IN U Get(CRI i);IN VO Update(CRI d);};TE <TY PT_MAGMA,TY R_SET,TY...Args> DualSqrtDecomposition(PT_MAGMA M,R_SET X,Args&&... args)-> DualSqrtDecomposition<inner_t<PT_MAGMA>,PT_MAGMA,inner_t<R_SET>,R_SET>;
TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::DualSqrtDecomposition(PT_MAGMA L,R_SET X,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_L(MO(L)),m_X(MO(X)),m_a(MO(a)),m_b(m_N_d,m_L.Point()){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<R_SET>>);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY...Args> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Initialise(Args&&... args){DualSqrtDecomposition<R,PT_MAGMA,U,R_SET> temp{m_L,m_X,forward<decay_t<Args>>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Set(CRI i,CO U& u){U& m_ai = m_a[i];if(m_ai != u){Update(i / m_N_sqrt);m_ai = u;}}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> TE <TY Arg> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::IntervalAct(CRI i_start,CRI i_final,CO Arg& r){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);CO R r_copy = m_L.Action(r,m_L.Point());if(d_0 > 0){Update(d_0 - 1);}for(int i = i_min;i < i_0;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}for(int d = d_0;d < d_1;d++){R& m_bd = m_b[d];m_bd = m_L.Action(r,MO(m_bd));}if(d_1 < m_N_d){Update(d_1);}for(int i = i_1;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r_copy,MO(m_ai));}RE;}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_X.Action(m_b[i / m_N_sqrt],m_a[i]);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Get(CRI i){RE OP[](i);}TE <TY R,TY PT_MAGMA,TY U,TY R_SET> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_SET>::Update(CRI d){R& m_bd = m_b[d];CO R& point = m_L.Point();if(m_bd != point){CO int j_min = d * m_N_sqrt;CO int j_ulim = min(j_min + m_N_sqrt,m_N);for(int j = j_min;j < j_ulim;j++){U& m_aj = m_a[j];m_aj = m_X.Action(m_bd,MO(m_aj));}m_bd = point;}RE;}

TE <TY INT = ll>CL CoordinateCompress{PU:set<INT> m_r;VE<INT*> m_l;IN CoordinateCompress();IN VO SetR(INT t);TE <TY U,TE <TY...> TY V > IN VO SetR(V<U> a);pair<VE<INT>,unordered_map<INT,int>> GetR();IN VO clearR();IN VO SetL(INT& t);TE <TY U,TE <TY...> TY V > IN VO SetL(V<U>& a);VE<INT> GetL();IN VO clearL();};
TE <TY INT> IN CoordinateCompress<INT>::CoordinateCompress():m_r(),m_l(){}TE <TY INT> IN VO CoordinateCompress<INT>::SetR(INT t){m_r.insert(MO(t));}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetR(V<U> a){for(auto& t:a){SetR(MO(t));}}TE <TY INT>pair<VE<INT>,unordered_map<INT,int>> CoordinateCompress<INT>::GetR(){pair<VE<INT>,unordered_map<INT,int>> AN{};AN.first.resize(m_r.SZ());int i = 0;for(auto t:m_r){AN.first[i]= t;AN.second[t]= i++;}RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearR(){m_r.clear();}TE <TY INT> IN VO CoordinateCompress<INT>::SetL(INT& t){m_l.push_back(&t);}TE <TY INT> TE <TY U,TE <TY...> TY V > IN VO CoordinateCompress<INT>::SetL(V<U>& a){for(auto& t:a){SetL(t);}}TE <TY INT>VE<INT> CoordinateCompress<INT>::GetL(){int i = -1;VE<INT> AN{};if(!m_l.empty()){auto comp =[](INT* CO& p0,INT* CO& p1){RE *p0 < *p1;};sort(m_l.BE(),m_l.EN(),comp);INT temp = *(m_l[0])- 1;for(auto p:m_l){*p = temp == *p?i:(AN.push_back(temp = *p),++i);}}RE AN;}TE <TY INT> IN VO CoordinateCompress<INT>::clearL(){m_l.clear();}

TE <TY INT,TY U,TY MONOID,TE <TY...> TY DATA_STR>U AbstractGridValueMaximisation_Body(MONOID M,CO INT& W,CO multiset<tuple<INT,INT,U>>& S,CO bool& skippable){CO U& one = M.One();DATA_STR a{RegularRSet{MaxSemilattice{one}},RegularRSet{MaxSemilattice{one}},VE(W,one)};if(skippable){for(auto&[i,j,w]:S){a.IntervalAct(-j,W - 1,M.Product(a[-j],w));}}else{for(auto&[i,j,w]:S){a.Set(-j,M.Product(a[-j],w));a.IntervalAct(-j,W - 1,a[-j]);}}RE a[W-1];}TE <TY INT,TY U,TY MONOID,TE <TY...> TY DATA_STR>U AbstractGridValueMaximisation(MONOID M,CO INT& W,CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = false){multiset<tuple<INT,INT,U>> S{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j && j < W){S.insert({i,-j,w});}}RE AbstractGridValueMaximisation<INT,U,MONOID,DATA_STR>(MO(M),W,S,skippable);}TE <TY INT,TY U> IN U GridValueMaximisation(CO INT& W,CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = false){RE AbstractGridValueMaximisation<INT,U,AdditiveMonoid<U>,DualSqrtDecomposition>(AdditiveMonoid<U>(),W,v,skippable);}TE <TY INT,TY U> IN U CompressedGridValueMaximisation(CO VE<tuple<INT,INT,U>>& v,CO bool& skippable = false){CoordinateCompress<INT> cc{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j){cc.SetR(j);}}auto[cc_result,cc_result_inv]= cc.GetR();multiset<tuple<INT,INT,U>> S{};for(auto&[i,j,w]:v){if(0 <= i && 0 <= j){S.insert({i,- cc_result_inv[j],w});}}RE AbstractGridValueMaximisation_Body<INT,U,AdditiveMonoid<U>,DualSqrtDecomposition>(AdditiveMonoid<U>(),INT(cc_result.SZ()),S,skippable);}
#endif

