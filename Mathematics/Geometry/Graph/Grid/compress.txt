#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Grid/a_Body.hpp"
#else
#define SET_GRID H_minus = H - 1;W_minus = W - 1;HW = H * W
#define SET_HW(h,w)H = h;W = w;SET_GRID
#define CIN_HW cin >> H >> W;SET_GRID
TE <TY E>CL GridGraph:PU EnumerationGraph<T2<int>,T2<int>(&)(CRI),int(&)(CO T2<int>&),E>{PU:IN GridGraph(E e);};int H,W,H_minus,W_minus,HW;VE<string> grid;char walkable = '.',unwalkable = '#';
IN T2<int> EnumHW(CRI v){RE{v / W,v % W};}IN int EnumHW_inv(CO T2<int>& ij){auto&[i,j]= ij;RE i * W + j;}TE <TY E> IN GridGraph<E>::GridGraph(E e):EnumerationGraph<T2<int>,T2<int>(&)(CRI),int(&)(CO T2<int>&),E>(HW,EnumHW,EnumHW_inv,MO(e)){AS(H * W == HW);}VE<T2<int>> EdgeOnGrid(CO T2<int>& v){VE<T2<int>> AN{};auto&[i,j]= v;if(i > 0 && grid[i-1][j]== walkable){AN.push_back({i-1,j});}if(i+1 < H && grid[i+1][j]== walkable){AN.push_back({i+1,j});}if(j > 0 && grid[i][j-1]== walkable){AN.push_back({i,j-1});}if(j+1 < W && grid[i][j+1]== walkable){AN.push_back({i,j+1});}RE AN;}VE<pair<T2<int>,ll>> WEdgeOnGrid(CO T2<int>& v){VE<pair<T2<int>,ll>> AN{};auto&[i,j]= v;if(i>0 && grid[i-1][j]== walkable){AN.push_back({{i-1,j},1});}if(i+1 < H && grid[i+1][j]== walkable){AN.push_back({{i+1,j},1});}if(j>0 && grid[i][j-1]== walkable){AN.push_back({{i,j-1},1});}if(j+1 < W && grid[i][j+1]== walkable){AN.push_back({{i,j+1},1});}RE AN;}IN VO SetWallStringOnGrid(CRI i,VE<string>& S){if(S.empty()){S.resize(H);}cin >> S[i];AS(int(S[i].SZ())== W):}CO string direction[4]={"U","R","D","L"};IN int DirectionNumberOnGrid(CRI i,CRI j,CRI k,CRI h){RE i < k?2:i > k?0:j < h?1:(AS(j > h),3);}IN int DirectionNumberOnGrid(CRI v,CRI w){auto[i,j]= EnumHW(v);auto[k,h]= EnumHW(w);RE DirectionNumberOnGrid(i,j,k,h);}IN int ReverseDirectionNumberOnGrid(CRI n){AS(0 <= n && n<4);RE n ^ 2;}
#endif

