// êÊÇ…../../Graph/compress.txtÇì\ÇÈÅB

#define DIJKSTRA_PREP(INITIALISE_PREV)CO U& one = m_M.One();AS(one < infty);auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);INITIALISE_PREV;
#define DIJKSTRA_BODY_1(SET_PREV)if(walk_LE == -1){walk_LE = SZ - 1;}weight[i_start]= one;int i = i_start;for(int num = 0;num < walk_LE;num++){CO U& weight_i = weight[i];found[i]= true;auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);if(!found[j]){CO U& edge_ij = get<1>(*IT);U temp = m_M.Product(weight_i,edge_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){SET_PREV;weight_j = MO(temp);}}}U temp = infty;for(int j = 0;j < SZ;j++){if(!found[j]){U& weight_j = weight[j];if(weight_j < temp){temp = weight_j;i = j;}}}}
#define DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV)AS(walk_LE == -1);set<pair<U,int>> vertex{};vertex.insert(pair<U,int>(weight[i_start]= one,i_start));WH(! vertex.empty()){auto BE = vertex.BE();auto[weight_i,i]= *BE;CHECK_FINAL;found[i]= true;vertex.erase(BE);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));LI<pair<U,int>> changed_vertex{};for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);if(!found[j]){CO U& edge_ij = get<1>(*IT);U temp = m_M.Product(weight_i,edge_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){if(weight_j != infty){vertex.erase(pair<U,int>(weight_j,j));}SET_PREV;changed_vertex.push_back(pair<U,int>(weight_j = MO(temp),j));}}}for(auto IT_changed = changed_vertex.BE(),EN_changed = changed_vertex.EN();IT_changed != EN_changed;IT_changed++){vertex.insert(*IT_changed);}}
#define DIJKSTRA_BODY(INITIALISE_PREV,CHECK_FINAL,SET_PREV)DIJKSTRA_PREP(INITIALISE_PREV);if(many_edges){DIJKSTRA_BODY_1(SET_PREV);}else{DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV);}
TE <TY GRAPH,TY COMM_MONOID,TY U>CL AbstractDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;COMM_MONOID m_M;IN AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty);U GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = true,int walk_LE = -1);VE<U> GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int walk_LE = -1);VO SetDistance(VE<U>& weight,VE<bool>& found,CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int walk_LE = -1);pair<U,LI<inner_t<GRAPH>>> GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = true,int walk_LE = -1);TE <TE <TY...> TY V> pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges = true,int walk_LE = -1);pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int walk_LE = -1);};TE <TY GRAPH>CL Dijkstra:PU AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>{PU:IN Dijkstra(GRAPH& G);};
TE <TY GRAPH,TY COMM_MONOID,TY U> IN AbstractDijkstra<GRAPH,COMM_MONOID,U>::AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(! is_same_v<U,int>);}TE <TY GRAPH> IN Dijkstra<GRAPH>::Dijkstra(GRAPH& G):AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY GRAPH,TY COMM_MONOID,TY U>U AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> found(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(,if(i == i_final){break;},);U AN{MO(weight[i_final])};RE AN;}TE <TY GRAPH,TY COMM_MONOID,TY U>VE<U> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> found(SZ);DIJKSTRA_BODY(,,);RE weight;}TE <TY GRAPH,TY COMM_MONOID,TY U>VO AbstractDijkstra<GRAPH,COMM_MONOID,U>::SetDistance(VE<U>& weight,VE<bool>& found,CO inner_t<GRAPH>& t_start,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();AS(int(weight.SZ())== SZ);AS(int(found.SZ())== SZ);DIJKSTRA_BODY(,,);RE;}TE <TY GRAPH,TY COMM_MONOID,TY U>pair<U,LI<inner_t<GRAPH>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> found(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(VE<int> prev(SZ),if(i == i_final){break;},prev[j]= i);int i = i_final;LI<inner_t<GRAPH>> path{};path.push_back(t_final);if(found[i]){WH(i != i_start){i = prev[i];path.push_front(m_G.Enumeration(i));}}U AN{MO(weight[i_final])};RE{MO(AN),MO(path)};}TE <TY GRAPH,TY COMM_MONOID,TY U> TE <TE <TY...> TY V>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> found(SZ);DIJKSTRA_BODY(VE<int> prev(SZ),,prev[j]= i);CO int path_SZ = t_finals.SZ();VE<LI<inner_t<GRAPH>>> path;path.reserve(path_SZ);for(auto IT = t_finals.BE(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(weight),MO(path)};}TE <TY GRAPH,TY COMM_MONOID,TY U>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int walk_LE){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals,many_edges,walk_LE);}

TE <TY T,TY PATH,TY ACYCLIC_GRAPH> IN VO TopologicalSort_Body(ACYCLIC_GRAPH& G,VE<T>& AN,CO PATH& e,VE<bool>& found,int& num);TE <TY T,TY ACYCLIC_GRAPH> IN VO TopologicalSort_Body(ACYCLIC_GRAPH& G,VE<T>& AN,CO T& t,VE<bool>& found,int& num);TE <TY T,TY ACYCLIC_GRAPH>VO TopologicalSort_Body(ACYCLIC_GRAPH& G,VE<T>& AN,CO T& t,CRI i,VE<bool>& found,int& num){if(!found[i]){found[i]= true;auto&& edge_i = G.Edge(t);for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){TopologicalSort_Body(G,AN,*IT,found,num);}AN[num--]= t;}RE;}TE <TY T,TY PATH,TY ACYCLIC_GRAPH> IN VO TopologicalSort_Body(ACYCLIC_GRAPH& G,VE<T>& AN,CO PATH& e,VE<bool>& found,int& num){TopologicalSort_Body(G,AN,get<0>(e),found,num);}TE <TY T,TY ACYCLIC_GRAPH> IN VO TopologicalSort_Body(ACYCLIC_GRAPH& G,VE<T>& AN,CO T& t,VE<bool>& found,int& num){TopologicalSort_Body(G,AN,t,G.Enumeration_inv(t),found,num);}TE <TY ACYCLIC_GRAPH>VE<inner_t<ACYCLIC_GRAPH>> TopologicalSort(ACYCLIC_GRAPH& G){CRI SZ = G.SZ();VE<inner_t<ACYCLIC_GRAPH>> AN(SZ);VE<bool> found(SZ);int num = SZ - 1;for(int i = 0;i < SZ;i++){TopologicalSort_Body(G,AN,G.Enumeration(i),i,found,num);}RE AN;}TE <TY ACYCLIC_GRAPH,TY MONOID> pair<inner_t<MONOID>,LI<inner_t<ACYCLIC_GRAPH>>> GetLongestWalk(ACYCLIC_GRAPH& G,MONOID M){US T = inner_t<ACYCLIC_GRAPH>;US U = inner_t<MONOID>;CRI SZ = G.SZ();CO U& one = M.One();if(SZ == 0){RE{one,LI<T>()};}VE<T> top_sort = TopologicalSort(G);VE<U> dp(SZ,one);VE<int> prev(SZ,-1);for(auto IT_vertex = top_sort.BE(),EN_vertex = top_sort.EN();IT_vertex != EN_vertex;IT_vertex++){auto&& edge_i = G.Edge(*IT_vertex);auto&& i = G.Enumeration_inv(*IT_vertex);CO U& dp_i = dp[i];for(auto IT_edge_i = edge_i.BE(),EN_edge_i = edge_i.EN();IT_edge_i != EN_edge_i;IT_edge_i++){auto&[t,u]= *IT_edge_i;auto&& j = G.Enumeration_inv(t);U& dp_j = dp[j];if(!(dp_i < dp_j)){dp_j = M.Product(dp_i,u);prev[j]= i;}}}U AN = one;int EN_num = -1;for(int i = 0;i < SZ;i++){CO U& dp_i = dp[i];if(EN_num == -1 || AN < dp_i){AN = dp_i;EN_num = i;}}LI<T> path{};WH(EN_num != -1){path.push_front(G.Enumeration(EN_num));EN_num = prev[EN_num];}RE{MO(AN),MO(path)};}

TE <TY T1,TY ACYCLIC_GRAPH,TY T2,TY U,TY GRAPH,TY VERTEX>CL AcyclicDoubleGraph{PU:ACYCLIC_GRAPH& m_G1;GRAPH& m_G2;VERTEX m_vertex;VE<T1> m_top_sort;IN AcyclicDoubleGraph(ACYCLIC_GRAPH& G1,GRAPH& G2,VERTEX& vertex);IN AcyclicDoubleGraph(ACYCLIC_GRAPH& G1,GRAPH& G2,VERTEX& vertex,VE<T1> top_sort);IN CO VE<T1>& GetTopologicalSort()CO NE;TE <TY COMM_MONOID> VE<U> GetDistance(CO VE<pair<T1,T2>>& t_starts,COMM_MONOID M,CO U& infty,CO bool& many_edges = true);};TE <TY ACYCLIC_GRAPH,TY GRAPH,TY VERTEX,TY...Args> AcyclicDoubleGraph(ACYCLIC_GRAPH& G1,GRAPH& G2,VERTEX& vertex,Args&&...)-> AcyclicDoubleGraph<inner_t<ACYCLIC_GRAPH>,ACYCLIC_GRAPH,decldecay_t(declval<inner_t<GRAPH>>().second),decldecay_t(declval<GRAPH>().Edge(declval<inner_t<GRAPH>>()).front().second),GRAPH,VERTEX>;
TE <TY T1,TY ACYCLIC_GRAPH,TY T2,TY U,TY GRAPH,TY VERTEX> IN AcyclicDoubleGraph<T1,ACYCLIC_GRAPH,T2,U,GRAPH,VERTEX>::AcyclicDoubleGraph(ACYCLIC_GRAPH& G1,GRAPH& G2,VERTEX& vertex):AcyclicDoubleGraph(G1,G2,vertex,TopologicalSort(G1)){}TE <TY T1,TY ACYCLIC_GRAPH,TY T2,TY U,TY GRAPH,TY VERTEX> IN AcyclicDoubleGraph<T1,ACYCLIC_GRAPH,T2,U,GRAPH,VERTEX>::AcyclicDoubleGraph(ACYCLIC_GRAPH& G1,GRAPH& G2,VERTEX& vertex,VE<T1> top_sort):m_G1(G1),m_G2(G2),m_vertex(vertex),m_top_sort(MO(top_sort)){ST_AS(is_same_v<T1,inner_t<ACYCLIC_GRAPH>> && is_same_v<pair<T1,T2>,inner_t<GRAPH>> && is_invocable_v<VERTEX,CO T1&>);}TE <TY T1,TY ACYCLIC_GRAPH,TY T2,TY U,TY GRAPH,TY VERTEX> IN CO VE<T1>& AcyclicDoubleGraph<T1,ACYCLIC_GRAPH,T2,U,GRAPH,VERTEX>::GetTopologicalSort()CO NE{RE m_top_sort;}TE <TY T1,TY ACYCLIC_GRAPH,TY T2,TY U,TY GRAPH,TY VERTEX> TE <TY COMM_MONOID> VE<U> AcyclicDoubleGraph<T1,ACYCLIC_GRAPH,T2,U,GRAPH,VERTEX>::GetDistance(CO VE<pair<T1,T2>>& t_starts,COMM_MONOID M,CO U& infty,CO bool& many_edges){VE<U> weight(m_G2.SZ(),infty);if(t_starts.empty()){RE weight;}for(auto& t:t_starts){auto&& i = m_G2.Enumeration_inv(t);weight[i]= M.One();}VE<bool> found(m_G2.SZ());CRI G1_SZ = m_G1.SZ();auto& t_start = t_starts[0];for(int num = 0;num < G1_SZ;num++){CO T1& t1 = m_top_sort[num];auto&& V_t1 = m_vertex(t1);US path_type = pair<pair<T1,T2>,U>;VE<path_type> inits{};for(auto& t2:V_t1){pair<T1,T2> t{t1,t2};auto&& j = m_G2.Enumeration_inv(t);if(weight[j]!= infty){inits.push_back({MO(t),weight[j]});found[j]= false;weight[j]= infty;}}auto edge =[&](CO pair<T1,T2>& t){RE t.first == t1?m_G2.Edge(t):t == t_start?inits:VE<path_type>();};auto graph = m_G2.GetGraph(MO(edge));AbstractDijkstra dijk{graph,M,infty};dijk.SetDistance(weight,found,t_start,many_edges,many_edges?int(V_t1.SZ()):-1);}RE weight;}

