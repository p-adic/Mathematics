#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Dijkstra/Potentialised/a_Body.hpp"
#else
#define BELLMAN_FORD_BODY(INITIALISE_PREV,SET_PREV)CO U& one = m_M.One();CO U& infty = TH->Infty();AS(one < infty);CRI SZ = m_G.SZ();auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);VE<U> weight(SZ,infty),weight_copy;weight[i_start]= one;VE<bool> found(SZ);found[i_start]= true;INITIALISE_PREV;if(path_LE == -1){path_LE = min(SZ - 1,int(m_edge.SZ()));}else{AS(many_edges);}for(int num = 0;num < path_LE;num++){for(auto&[i,j,w]:m_edge){if(found[i]){U temp = m_M.Product(weight[i],w);U& weight_j = weight[j];if(temp < weight_j){weight_j = MO(temp);found[j]= true;SET_PREV;}}}}VE<bool> valid(SZ,true);for(auto&[i,j,w]:m_edge){valid[i]= valid[i]&&(!found[i]|| !(m_M.Product(weight[i],w)< weight[j]));}VE<int> dfs{};for(int i = 0;i < SZ;i++){if(!valid[i]){dfs.push_back(i);}}WH(!dfs.empty()){CO int i = dfs.back();dfs.pop_back();auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto& edge_ij:edge_i){auto&& j = m_G.Enumeration_inv(edge_ij.first);if(valid[j]){valid[j]= false;dfs.push_back(j);}}}
TE <TY T,TY GRAPH,TY U,TY MONOID>CL AbstractBellmanFord:PU PointedSet<U>{PU:GRAPH& m_G;MONOID m_M;VE<tuple<int,int,U>> m_edge;AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty);tuple<VE<bool>,VE<U>> GetDistance(CO T& t_start,CO bool& many_edges = true,int path_LE = -1);TE <TE <TY...> TY V> tuple<VE<bool>,VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges = true,int path_LE = -1);tuple<VE<bool>,VE<U>,VE<LI<T>>> GetPath(CO T& t_start,CO bool& many_edges = true,int path_LE = -1);};TE <TY GRAPH,TY U,TY MONOID> AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty)-> AbstractBellmanFord<inner_t<GRAPH>,GRAPH,U,MONOID>;TE <TY T,TY GRAPH>CL BellmanFord:PU AbstractBellmanFord<T,GRAPH,ll,AdditiveMonoid<>>{PU:IN BellmanFord(GRAPH& G);};TE <TY GRAPH> BellmanFord(GRAPH& G)-> BellmanFord<inner_t<GRAPH>,GRAPH>;
TE <TY T,TY GRAPH,TY U,TY MONOID>AbstractBellmanFord<T,GRAPH,U,MONOID>::AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)),m_edge(){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<U,inner_t<MONOID>> && !is_same_v<U,int>);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto& edge_ij:edge_i){m_edge.push_back({i,m_G.Enumeration_inv(get<0>(edge_ij)),get<1>(edge_ij)});}}}TE <TY T,TY GRAPH> IN BellmanFord<T,GRAPH>::BellmanFord(GRAPH& G):AbstractBellmanFord<T,GRAPH,ll,AdditiveMonoid<>>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY T,TY GRAPH,TY U,TY MONOID>tuple<VE<bool>,VE<U>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetDistance(CO T& t_start,CO bool& many_edges,int path_LE){BELLMAN_FORD_BODY(,);RE{MO(valid),MO(weight)};}TE <TY T,TY GRAPH,TY U,TY MONOID> TE <TE <TY...> TY V>tuple<VE<bool>,VE<U>,VE<LI<T>>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetPath(CO T& t_start,CO V<T>& t_finals,CO bool& many_edges,int path_LE){BELLMAN_FORD_BODY(VE<int> prev(SZ),prev[j]= i);VE<LI<T>> path{};CO int path_SZ = t_finals.SZ();path.reserve(path_SZ);for(auto& t_final:t_finals){LI<T> path_j{};path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]&& valid[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(valid),MO(weight),MO(path)};}TE <TY T,TY GRAPH,TY U,TY MONOID>tuple<VE<bool>,VE<U>,VE<LI<T>>> AbstractBellmanFord<T,GRAPH,U,MONOID>::GetPath(CO T& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();VE<T> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals);}

#define DIJKSTRA_PREP(INITIALISE_PREV)CO U& one = m_M.One();AS(one < infty);auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);INITIALISE_PREV;
#define DIJKSTRA_BODY_1(SET_PREV)if(path_LE == -1){path_LE = SZ - 1;}weight[i_start]= one;int i = i_start;for(int num = 0;num < path_LE;num++){CO U& weight_i = weight[i];fixed[i]= true;auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);if(!fixed[j]){CO U& edge_ij = get<1>(*IT);U temp = m_M.Product(weight_i,edge_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){SET_PREV;weight_j = MO(temp);}}}U temp = infty;for(int j = 0;j < SZ;j++){if(!fixed[j]){U& weight_j = weight[j];if(weight_j < temp){temp = weight_j;i = j;}}}}
#define DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV)AS(path_LE == -1);set<pair<U,int>> vertex{};vertex.insert(pair<U,int>(weight[i_start]= one,i_start));WH(! vertex.empty()){auto BE = vertex.BE();auto[weight_i,i]= *BE;CHECK_FINAL;fixed[i]= true;vertex.erase(BE);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));LI<pair<U,int>> changed_vertex{};for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);if(!fixed[j]){CO U& edge_ij = get<1>(*IT);U temp = m_M.Product(weight_i,edge_ij);AS(temp < infty);U& weight_j = weight[j];if(temp < weight_j){if(weight_j != infty){vertex.erase(pair<U,int>(weight_j,j));}SET_PREV;changed_vertex.push_back(pair<U,int>(weight_j = MO(temp),j));}}}for(auto IT_changed = changed_vertex.BE(),EN_changed = changed_vertex.EN();IT_changed != EN_changed;IT_changed++){vertex.insert(*IT_changed);}}
#define DIJKSTRA_BODY(INITIALISE_PREV,CHECK_FINAL,SET_PREV)DIJKSTRA_PREP(INITIALISE_PREV);if(many_edges){DIJKSTRA_BODY_1(SET_PREV);}else{DIJKSTRA_BODY_2(CHECK_FINAL,SET_PREV);}
TE <TY GRAPH,TY COMM_MONOID,TY U>CL AbstractDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;COMM_MONOID m_M;IN AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty);U GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = true,int path_LE = -1);VE<U> GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int path_LE = -1);VO SetDistance(VE<U>& weight,VE<bool>& fixed,CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int path_LE = -1);pair<U,LI<inner_t<GRAPH>>> GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges = true,int path_LE = -1);TE <TE <TY...> TY V> pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges = true,int path_LE = -1);pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges = true,int path_LE = -1);};TE <TY GRAPH>CL Dijkstra:PU AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>{PU:IN Dijkstra(GRAPH& G);};
TE <TY GRAPH,TY COMM_MONOID,TY U> IN AbstractDijkstra<GRAPH,COMM_MONOID,U>::AbstractDijkstra(GRAPH& G,COMM_MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(! is_same_v<U,int>);}TE <TY GRAPH> IN Dijkstra<GRAPH>::Dijkstra(GRAPH& G):AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY GRAPH,TY COMM_MONOID,TY U>U AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(,if(i == i_final){break;},);U AN{MO(weight[i_final])};RE AN;}TE <TY GRAPH,TY COMM_MONOID,TY U>VE<U> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(,,);RE weight;}TE <TY GRAPH,TY COMM_MONOID,TY U>VO AbstractDijkstra<GRAPH,COMM_MONOID,U>::SetDistance(VE<U>& weight,VE<bool>& fixed,CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();AS(int(weight.SZ())== SZ);AS(int(fixed.SZ())== SZ);DIJKSTRA_BODY(,,);RE;}TE <TY GRAPH,TY COMM_MONOID,TY U>pair<U,LI<inner_t<GRAPH>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(VE<int> prev(SZ),if(i == i_final){break;},prev[j]= i);int i = i_final;LI<inner_t<GRAPH>> path{};path.push_back(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path.push_front(m_G.Enumeration(i));}}U AN{MO(weight[i_final])};RE{MO(AN),MO(path)};}TE <TY GRAPH,TY COMM_MONOID,TY U> TE <TE <TY...> TY V>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();CO U& infty = TH->Infty();VE weight(SZ,infty);VE<bool> fixed(SZ);DIJKSTRA_BODY(VE<int> prev(SZ),,prev[j]= i);CO int path_SZ = t_finals.SZ();VE<LI<inner_t<GRAPH>>> path;path.reserve(path_SZ);for(auto IT = t_finals.BE(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(weight[i]!= infty){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}RE{MO(weight),MO(path)};}TE <TY GRAPH,TY COMM_MONOID,TY U>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,COMM_MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO bool& many_edges,int path_LE){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals,many_edges,path_LE);}

#define POTENTIALISED_DIJKSTRA_BODY(GET,WEIGHT,...)CO U& infty = TH->Infty();if(m_valid){CO U& zero = m_M.Zero();auto edge =[&](CO T& t){CO U& potential_i = m_potential[m_G.Enumeration_inv(t)];AS(potential_i < infty);auto edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.BE(),EN = edge_i.end();IT != EN;IT++){auto& e = *IT;if(m_on(e)){CO auto& v_j = get<0>(e);U& w_j = get<1>(e);CO U& potential_j = m_potential[m_G.Enumeration_inv(v_j)];AS(w_j < infty && potential_j < infty);CO U potential_j_inv = m_M.Inverse(potential_j);w_j = m_M.Sum(m_M.Sum(w_j,potential_i),potential_j_inv);AS(!(w_j < zero)&& w_j < infty);AN.push_back({v_j,MO(w_j)});}}RE AN;};auto G = m_G.GetGraph(MO(edge));AbstractDijkstra d{G,m_M,infty};auto value = d.GET;CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){auto& weight_i = WEIGHT[i];if(weight_i != infty){weight_i = m_M.Sum(weight_i,m_potential[i]);}}RE{VE(SZ,m_valid),__VA_ARGS__};}auto edge =[&](CO T& t){auto&& edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.BE(),EN = edge_i.end();IT != EN;IT++){if(m_on(*IT)){AN.push_back({get<0>(*IT),get<1>(*IT)});}}RE AN;};auto G = m_G.GetGraph(MO(edge));AbstractBellmanFord d{G,m_M,infty};RE d.GET;
TE <TY T,TY GRAPH,TY GROUP,TY U,TY On>CL AbstractPotentialisedDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;GROUP m_M;T m_t_start;On m_on;bool m_valid;VE<U> m_potential;IN AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& negative = true);IN AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& valid,VE<U> potential);IN CO bool& Valid()CO NE;IN CO VE<U>& Potential()CO NE;IN VO SetPotential(CO bool& valid,VE<U> potential);TE <TY...Args> tuple<VE<bool>,VE<U>> GetDistance(Args&&... args);TE <TY...Args> tuple<VE<bool>,VE<U>,VE<LI<T>>> GetPath(Args&&... args);};TE <TY T,TY GRAPH,TY On>CL PotentialisedDijkstra:PU AbstractPotentialisedDijkstra<T,GRAPH,AdditiveGroup<>,ll,On>{PU:TE <TY...Args> IN PotentialisedDijkstra(GRAPH& G,CO T& t_start,On on,Args&&... args);};
TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& negative):AbstractPotentialisedDijkstra(G,MO(M),t_start,infty,MO(on),true,VE<U>()){if(negative){auto edge =[&](CRI t){auto&& edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.BE(),EN = edge_i.end();IT != EN;IT++){CO auto& e = *IT;AN.push_back({get<0>(e),get<1>(e)});}RE AN;};auto G_full = m_G.GetGraph(MO(edge));AbstractBellmanFord bf{G_full,m_M,infty};auto[valid,potential]= bf.GetDistance(m_t_start);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_valid &= valid[i];}m_potential = MO(potential);}else{m_potential = VE<U>(m_G.SZ(),m_M.Zero());}}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& valid,VE<U> potential):PointedSet<U>(infty),m_G(G),m_M(MO(M)),m_t_start(t_start),m_on(MO(on)),m_valid(valid),m_potential(potential){ST_AS(is_invocable_r_v<bool,On,decltype(declval<GRAPH>().Edge(declval<T>()).back())>);}TE <TY T,TY GRAPH,TY On> TE <TY...Args> IN PotentialisedDijkstra<T,GRAPH,On>::PotentialisedDijkstra(GRAPH& G,CO T& t_start,On on,Args&&... args):AbstractPotentialisedDijkstra<T,GRAPH,AdditiveGroup<>,ll,On>(G,AdditiveGroup<>(),t_start,4611686018427387904,MO(on),forward<decay_t<Args>>(args)...){}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN CO bool& AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::Valid()CO NE{RE m_valid;}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN CO VE<U>& AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::Potential()CO NE{RE m_potential;}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN VO AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::SetPotential(CO bool& valid,VE<U> potential){AS(int(potential.SZ())== m_G.SZ());m_valid = valid;m_potential = MO(potential);}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> TE <TY...Args> tuple<VE<bool>,VE<U>> AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::GetDistance(Args&&... args){POTENTIALISED_DIJKSTRA_BODY(GetDistance(m_t_start,forward<Args>(args)...),value,MO(value));}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> TE <TY...Args> tuple<VE<bool>,VE<U>,VE<LI<T>>> AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::GetPath(Args&&... args){POTENTIALISED_DIJKSTRA_BODY(GetPath(m_t_start,forward<Args>(args)...),get<0>(value),MO(get<0>(value)),MO(get<1>(value)));}
#endif
