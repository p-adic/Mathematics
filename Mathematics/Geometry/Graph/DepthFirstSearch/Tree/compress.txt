#define DC_OF_FIRST_SEARCH(BREADTH)TE <int V_max> CL BREADTH ## FirstSearch_Body{PU:int m_V;int m_init;LI<int> m_next;bool m_found[V_max];int m_prev[V_max];IN BREADTH ## FirstSearch_Body(CRI V);IN BREADTH ## FirstSearch_Body(CRI V,CRI init);IN VO Reset(CRI init);IN VO Shift(CRI init);IN CRI SZ()CO;IN CRI init()CO;IN bool& found(CRI i);IN CRI prev(CRI i)CO;int Next();virtual LI<int> e(CRI t)= 0;};TE <int V_max,LI<int> E(CRI)> CL BREADTH ## FirstSearch:PU BREADTH ## FirstSearch_Body<V_max>{PU:TE<TY... Args> IN BREADTH ## FirstSearch(CO Args&... args);IN LI<int> e(CRI t);};TE <int V_max,LI<int> E(CRI)> VO BREADTH ## FirstConnectedComponent(CRI V,int(&vertex)[V_max],int& count);
#define DF_OF_FIRST_SEARCH(BREADTH,PUSH)TE <int V_max> IN BREADTH ## FirstSearch_Body<V_max>::BREADTH ## FirstSearch_Body(CRI V):m_V(V),m_init(),m_next(),m_found(),m_prev(){assert(m_V <= V_max);for(int i = 0;i < m_V;i++){m_prev[i] = -1;}}TE <int V_max> IN BREADTH ## FirstSearch_Body<V_max>::BREADTH ## FirstSearch_Body(CRI V,CRI init):BREADTH ## FirstSearch_Body(V){m_init = init;m_next.push_back(m_init);m_found[m_init] = true;}TE <int V_max,LI<int> E(CRI)> TE <TY... Args> IN BREADTH ## FirstSearch<V_max,E>::BREADTH ## FirstSearch(CO Args&... args):BREADTH ## FirstSearch_Body<V_max>(args...){}TE <int V_max> IN VO BREADTH ## FirstSearch_Body<V_max>::Reset(CRI init){m_init = init;assert(m_init < m_V);m_next.clear();m_next.push_back(m_init);for(int i = 0;i < m_V;i++){m_found[i] = i == m_init;m_prev[i] = -1;}}TE <int V_max> IN VO BREADTH ## FirstSearch_Body<V_max>::Shift(CRI init){m_init = init;assert(m_init < m_V);m_next.clear();if(! m_found[m_init]){m_next.push_back(m_init);m_found[m_init] = true;}}TE <int V_max> IN CRI BREADTH ## FirstSearch_Body<V_max>::SZ()CO{RE m_V;}TE <int V_max> IN CRI BREADTH ## FirstSearch_Body<V_max>::init()CO{RE m_init;}TE <int V_max> IN bool& BREADTH ## FirstSearch_Body<V_max>::found(CRI i){assert(i < m_V);RE m_found[i];}TE <int V_max> IN CRI BREADTH ## FirstSearch_Body<V_max>::prev(CRI i)CO{assert(i < m_V);RE m_prev[i];}TE <int V_max> int BREADTH ## FirstSearch_Body<V_max>::Next(){if(m_next.empty()){RE -1;}CO int i_curr = m_next.front();m_next.pop_front();LI<int> edge = e(i_curr);WH(! edge.empty()){CRI i = edge.front();bool& found_i = found(i);if(! found_i){m_next.PUSH(i);m_prev[i] = i_curr;found_i = true;}edge.pop_front();}RE i_curr;}TE <int V_max,LI<int> E(CRI)> IN LI <int> BREADTH ## FirstSearch<V_max,E>::e(CRI t){RE E(t);}TE <int V_max,LI<int> E(CRI)> VO BREADTH ## FirstConnectedComponentSearch(CRI V,int(&vertex)[V_max],int& count){BREADTH ## FirstSearch<V_max,E> bfs{V};count = 0;for(int i = 0;i < V;i++){vertex[i] = -1;}for(int i = 0;i < V;i++){if(vertex[i] == -1){bfs.Shift(i);int j = bfs.Next();WH(j != -1?vertex[j] == 0:false){vertex[j] = count;j = bfs.Next();}count++;}}RE;}
DC_OF_FIRST_SEARCH(Depth);DF_OF_FIRST_SEARCH(Depth,push_front);
TE <int V_max,LI<int> E(CRI),int digit = 0>CL DepthFirstSearchOnTree:PU DepthFirstSearch<V_max,E>{PU:int m_reversed[V_max];VE<int> m_children[V_max];int m_children_num[V_max];bool m_set_children;int m_depth[V_max];int m_height[V_max];bool m_set_height;int m_weight[V_max];bool m_set_weight;int m_doubling[digit][V_max];bool m_set_doubling;IN DepthFirstSearchOnTree(CRI V,CRI root);IN VO Reset(CRI init)= delete;IN VO Shift(CRI init)= delete;IN CRI Root()CO;IN CRI Parent(CRI i)CO;IN CO VE<int>& Children(CRI i);IN CRI Depth(CRI i)CO;IN CRI Height(CRI i);IN CRI Weight(CRI i);IN CRI NodeNumber(CRI i,CO bool& reversed = false)CO;IN CRI ChildrenNumber(CRI i);int Ancestor(int i,int n);int LCA(int i,int j);int LCA(int i,int j,int& i_prev,int& j_prev);TE <TY T,T m_T(const T&,const T&)>T RootingDP(const T(&a)[V_max]);TE <TY T,T m_T(CO T&,CO T&),CO T& e_T(),T f(CO T&,CRI)> VO RerootingDP(T(&d)[V_max]);VO SetChildren();VO SetHeight();VO SetWeight();VO SetDoubling();};
TE <int V_max,LI<int> E(CRI),int digit> IN DepthFirstSearchOnTree<V_max,E,digit>::DepthFirstSearchOnTree(CRI V,CRI root):DepthFirstSearch<V_max,E>(V,root),m_reversed(),m_children(),m_set_children(),m_depth(),m_height(),m_set_height(),m_weight(),m_set_weight(),m_doubling(),m_set_doubling(){int n = DepthFirstSearch<V_max,E>::SZ();WH(--n >= 0){CRI i = m_reversed[n] = DepthFirstSearch<V_max,E>::Next();CRI j = Parent(i);if(j != -1){m_depth[i] = m_depth[j] + 1;}}}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::Root()CO{RE DepthFirstSearch<V_max,E>::init();}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::Parent(CRI i)CO{RE DepthFirstSearch<V_max,E>::prev(i);}TE <int V_max,LI<int> E(CRI),int digit> IN CO VE<int>& DepthFirstSearchOnTree<V_max,E,digit>::Children(CRI i){if(! m_set_children){SetChildren();}RE m_children[i];}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::Depth(CRI i)CO{RE m_depth[i];}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::Height(CRI i){if(! m_set_height){SetHeight();}RE m_height[i];}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::Weight(CRI i){if(! m_set_weight){SetWeight();}RE m_weight[i];}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::NodeNumber(CRI i,CO bool& reversed)CO{RE m_reversed[reversed?i:DepthFirstSearch<V_max,E>::SZ()- 1 - i];}TE <int V_max,LI<int> E(CRI),int digit> IN CRI DepthFirstSearchOnTree<V_max,E,digit>::ChildrenNumber(CRI i){if(! m_set_children){SetChildren();}RE m_children_num[i];}TE <int V_max,LI<int> E(CRI),int digit>int DepthFirstSearchOnTree<V_max,E,digit>::Ancestor(int i,int n){if(! m_set_doubling){SetDoubling();}assert((n >> digit)== 0);int d = 0;WH(n != 0){if((n & 1)== 1){assert((i = m_doubling[d][i])!= -1);}d++;n >>= 1;}RE i;}TE <int V_max,LI<int> E(CRI),int digit>int DepthFirstSearchOnTree<V_max,E,digit>::LCA(int i,int j){int diff = Depth(i)- Depth(j);if(diff < 0){swap(i,j);diff *= -1;}i = Ancestor(i,diff);if(i == j){RE i;}int d = digit;WH(--d >= 0){CO int(&doubling_d)[V_max] = m_doubling[d];CRI doubling_d_i = doubling_d[i];CRI doubling_d_j = doubling_d[j];if(doubling_d_i != doubling_d_j){i = doubling_d_i;j = doubling_d_j;assert(i != -1);assert(j != -1);}}RE Parent(i);}TE <int V_max,LI<int> E(CRI),int digit>int DepthFirstSearchOnTree<V_max,E,digit>::LCA(int i,int j,int& i_prev,int& j_prev){if(i == j){i_prev = j_prev = -1;RE i;}int diff = Depth(i)- Depth(j);if(diff < 0){RE LCA(j,i,j_prev,i_prev);}if(diff > 0){i_prev = Ancestor(i,diff - 1);i = Parent(i_prev);assert(i != -1);if(i == j){j_prev = -1;RE i;}}else if(! m_set_doubling){SetDoubling();}int d = digit;WH(--d >= 0){CO int(&doubling_d)[V_max] = m_doubling[d];CRI doubling_d_i = doubling_d[i];CRI doubling_d_j = doubling_d[j];if(doubling_d_i != doubling_d_j){i = doubling_d_i;j = doubling_d_j;assert(i != -1);assert(j != -1);}}i_prev = i;j_prev = j;RE Parent(i_prev);}TE <int V_max,LI<int> E(CRI),int digit>VO DepthFirstSearchOnTree<V_max,E,digit>::SetChildren(){assert(!m_set_children);m_set_children = true;CRI V = DepthFirstSearch<V_max,E>::SZ();for(int i = 0;i < V;i++){CRI j = Parent(i);if(j == -1){m_children_num[i] = -1;}else{VE<int>& m_children_j = m_children[j];m_children_num[i] = m_children_j.SZ();m_children_j.push_back(i);}}RE;}TE <int V_max,LI<int> E(CRI),int digit>VO DepthFirstSearchOnTree<V_max,E,digit>::SetHeight(){assert(!m_set_height);m_set_height = true;CRI V = DepthFirstSearch<V_max,E>::SZ();for(int i = 0;i < V;i++){CRI reversed_i = m_reversed[i];CRI parent_i = Parent(reversed_i);if(parent_i != -1){int& height_parent_i = m_height[parent_i];CRI height_i = m_height[reversed_i];height_parent_i > height_i?height_parent_i:height_parent_i = height_i + 1;}}RE;}TE <int V_max,LI<int> E(CRI),int digit>VO DepthFirstSearchOnTree<V_max,E,digit>::SetWeight(){assert(!m_set_weight);m_set_weight = true;CRI V = DepthFirstSearch<V_max,E>::SZ();for(int i = 0;i < V;i++){CRI reversed_i = m_reversed[i];CRI parent_i = Parent(reversed_i);if(parent_i != -1){m_weight[parent_i] += m_weight[reversed_i] + 1;}}RE;}TE <int V_max,LI<int> E(CRI),int digit>VO DepthFirstSearchOnTree<V_max,E,digit>::SetDoubling(){assert(!m_set_doubling);m_set_doubling = true;CRI V = DepthFirstSearch<V_max,E>::SZ();{int(&doubling_0)[V_max] = m_doubling[0];CRI r = Root();for(int i = 0;i < V;i++){doubling_0[i] = Parent(i);}}for(int d = 1;d < digit;d++){int(&doubling_d)[V_max] = m_doubling[d];int(&doubling_d_minus)[V_max] = m_doubling[d-1];for(int i = 0;i < V;i++){CRI doubling_d_minus_i = doubling_d_minus[i];doubling_d[i] = doubling_d_minus_i == -1?-1:doubling_d_minus[doubling_d_minus_i];}}RE;}TE <int V_max,LI<int> E(CRI),int digit> TE <TY T,T m_T(const T&,const T&)>T DepthFirstSearchOnTree<V_max,E,digit>::RootingDP(const T(&a)[V_max]){if(! m_set_children){SetChildren();}CRI V = DepthFirstSearch<V_max,E>::SZ();LI<T> children_value[V_max] = {};T temp;for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);LI<T>& children_value_i = children_value[i];temp = a[i];WH(!children_value_i.empty()){temp = m_T(temp,children_value_i.front());children_value_i.pop_front();}CRI j = Parent(i);if(j != -1){children_value[j].push_back(temp);}}RE temp;}TE <int V_max,LI<int> E(CRI),int digit> TE <TY T,T m_T(CO T&,CO T&),CO T& e_T(),T f(CO T&,CRI)>VO DepthFirstSearchOnTree<V_max,E,digit>::RerootingDP(T(&d)[V_max]){if(! m_set_children){SetChildren();}CRI V = DepthFirstSearch<V_max,E>::SZ();CO T& e = e_T();VE<T> children_value[V_max] ={};VE<T> left_sum[V_max] ={};VE<T> right_sum[V_max] ={};for(int i = 0;i < V;i++){children_value[i].resize(m_children[i].SZ());}for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);CO VE<T>& children_value_i = children_value[i];CO int SZ_i = children_value_i.SZ();T temp = e;VE<T>& left_sum_i = left_sum[i];left_sum_i.reserve(SZ_i + 1);left_sum_i.push_back(temp);for(int m = 0;m < SZ_i;m++){left_sum_i.push_back(temp = m_T(temp,children_value_i[m]));}CRI j = Parent(i);if(j != -1){children_value[j][m_children_num[i]] = f(temp,i);}temp = e;VE<T>& right_sum_i = right_sum[i];right_sum_i.resize(SZ_i);for(int m = 1;m <= SZ_i;m++){right_sum_i[ SZ_i - m ] = temp;temp = m_T(children_value_i[SZ_i - m],temp);}}for(int n = 1;n < V;n++){CRI i = NodeNumber(n);CRI j = Parent(i);CRI k = ChildrenNumber(i);VE<T>& left_sum_i = left_sum[i];VE<T>& right_sum_i = right_sum[i];CO int SZ_i = right_sum_i.SZ();CO T rest_i = f(m_T(left_sum[j][k],right_sum[j][k]),j);for(int m = 0;m <= SZ_i;m++){T& left_sum_im = left_sum_i[m];left_sum_im = m_T(rest_i,left_sum_im);}}for(int i = 0;i < V;i++){d[i] = f(left_sum[i].back(),i);}RE;}
