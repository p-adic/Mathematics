// êÊÇ…../../compress.txtÇì\ÇÈÅB

TE <TY GRAPH>CL VirtualBreadthFirstSearch:PU PointedSet<int>{PU:GRAPH& m_G;bool m_initialised;LI<int> m_next;VE<bool> m_found;VE<int> m_prev;IN VirtualBreadthFirstSearch(GRAPH& G);IN VirtualBreadthFirstSearch(GRAPH& G,CRI init);IN VO Initialise();IN VO Initialise(CRI init);IN VO Shift(CRI init);IN CRI SZ()CO NE;IN VE<bool>::reference found(CRI i);IN CRI prev(CRI i);IN int Next();VE<int> GetDistance();VO SetConnectedComponent(VE<int>& cc_num,int& count);VI VO Push(LI<int>& next,CRI i)= 0;};TE <TY GRAPH>CL BreadthFirstSearch:PU VirtualBreadthFirstSearch<GRAPH>{PU:TE <TY...Args> IN BreadthFirstSearch(GRAPH& G,CO Args&... args);IN VO Push(LI<int>& next,CRI i);};
TE <TY GRAPH> IN VirtualBreadthFirstSearch<GRAPH>::VirtualBreadthFirstSearch(GRAPH& G):m_G(G),m_initialised(false),m_next(),m_found(),m_prev(){ST_AS(is_same_v<inner_t<GRAPH>,int>&&is_same_v<decldecay_t(declval<GRAPH>().Edge(0)),int>));}TE <TY GRAPH> IN VirtualBreadthFirstSearch<GRAPH>::VirtualBreadthFirstSearch(GRAPH& G,CRI init):VirtualBreadthFirstSearch<GRAPH>(G){Initialise(init);}TE <TY GRAPH> TE <TY...Args> IN BreadthFirstSearch<GRAPH>::BreadthFirstSearch(GRAPH& G,CO Args&... args):VirtualBreadthFirstSearch<GRAPH>(G,args...){}TE <TY GRAPH> IN VO VirtualBreadthFirstSearch<GRAPH>::Initialise(){m_initialised = true;CRI V = SZ();m_next.clear();m_found = VE<bool>(V);m_prev = VE<int>(V,-1);}TE <TY GRAPH> IN VO VirtualBreadthFirstSearch<GRAPH>::Initialise(CRI init){AS((TH->init()= init)< SZ());Initialise();m_next.push_back(init);m_found[init]= true;}TE <TY GRAPH> IN VO VirtualBreadthFirstSearch<GRAPH>::Shift(CRI init){if(m_initialised){CRI V = SZ();AS((TH->init()= init)< V);m_next.clear();if(! m_found[init]){m_next.push_back(init);m_found[init]= true;}}else{Initialise(init);}}TE <TY GRAPH> IN CRI VirtualBreadthFirstSearch<GRAPH>::SZ()CO NE{RE m_G.SZ();}TE <TY GRAPH> IN VE<bool>::reference VirtualBreadthFirstSearch<GRAPH>::found(CRI i){AS(i < SZ());if(!m_initialised){Initialise();}RE m_found[i];}TE <TY GRAPH> IN CRI VirtualBreadthFirstSearch<GRAPH>::prev(CRI i){AS(i < SZ());if(!m_initialised){Initialise();}RE m_prev[i];}TE <TY GRAPH> IN int VirtualBreadthFirstSearch<GRAPH>::Next(){if(m_next.empty()){RE -1;}CO int i_curr = m_next.front();m_next.pop_front();auto&& edge = m_G.Edge(i_curr);WH(! edge.empty()){CRI i = edge.front();auto&& found_i = m_found[i];if(! found_i){Push(m_next,i);m_prev[i]= i_curr;found_i = true;}edge.pop_front();}RE i_curr;}TE <TY GRAPH>VE<int> VirtualBreadthFirstSearch<GRAPH>::GetDistance(){VE<int> depth{};depth = VE<int>(SZ(),-1);int i = Next();depth[i]= 0;WH((i = Next())!= -1){depth[i]= depth[prev(i)]+ 1;}RE depth;}TE <TY GRAPH>VO VirtualBreadthFirstSearch<GRAPH>::SetConnectedComponent(VE<int>& cc_num,int& count){CRI V = SZ();cc_num = VE<int>(V,-1);count = 0;for(int i = 0;i < V;i++){if(cc_num[i]== -1){Shift(i);int j = Next();if(j != -1){WH(j != -1){AS(cc_num[j]== -1);cc_num[j]= count;j = Next();}count++;}}}RE;}TE <TY GRAPH> IN VO BreadthFirstSearch<GRAPH>::Push(LI<int>& next,CRI i){next.push_back(i);}

TE <TY GRAPH>CL DepthFirstSearch:PU VirtualBreadthFirstSearch<GRAPH>{PU:TE <TY...Args> IN DepthFirstSearch(GRAPH& G,CO Args&... args);IN VO Push(LI<int>& next,CRI i);};
TE <TY GRAPH> TE <TY...Args> IN DepthFirstSearch<GRAPH>::DepthFirstSearch(GRAPH& G,CO Args&... args):VirtualBreadthFirstSearch<GRAPH>(G,args...){}TE <TY GRAPH> IN VO DepthFirstSearch<GRAPH>::Push(LI<int>& next,CRI i){next.push_front(i);}

TE <TY TREE>CL DepthFirstSearchOnTree:PU DepthFirstSearch<TREE>{PU:VE<int> m_reversed;VE<VE<int>> m_children;VE<int> m_children_num;bool m_set_children;VE<int> m_depth;bool m_set_depth;VE<int> m_height;bool m_set_height;VE<int> m_weight;bool m_set_weight;int m_digit;VE<VE<int>> m_doubling;bool m_set_doubling;IN DepthFirstSearchOnTree(TREE& T,CRI root = 0,CRI digit = 0);IN VO Initialise()= delete;IN VO Initialise(CRI init)= delete;IN VO Shift(CRI init)= delete;IN CRI Root()CO;IN CRI Parent(CRI i);IN CO VE<int>& Children(CRI i);IN CRI Depth(CRI i);IN CRI Height(CRI i);IN CRI Weight(CRI i);IN CRI NodeNumber(CRI i,CO bool& reversed = false)CO;IN CRI ChildrenNumber(CRI i);int Ancestor(int i,int n);int LCA(int i,int j);int LCA(int i,int j,int& i_prev,int& j_prev);TE <TY F> ret_t<F> RootingDP(F& f);TE <TY MONOID,TY F,TY G> VO RerootingDP(MONOID M,F& f,G& g,VE<inner_t<MONOID>>& d);VO SetChildren();VO SetDepth();VO SetHeight();VO SetWeight();VO SetDoubling();};
TE <TY TREE> IN DepthFirstSearchOnTree<TREE>::DepthFirstSearchOnTree(TREE& T,CRI root,CRI digit):DepthFirstSearch<TREE>(T,root),m_reversed(TH->SZ()),m_children(),m_set_children(),m_depth(),m_set_depth(),m_height(),m_set_height(),m_weight(),m_set_weight(),m_digit(digit),m_doubling(m_digit),m_set_doubling(){int n = TH->SZ();WH(--n >= 0){m_reversed[n]= TH->Next();}}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::Root()CO{RE TH->init();}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::Parent(CRI i){RE TH->prev(i);}TE <TY TREE> IN CO VE<int>& DepthFirstSearchOnTree<TREE>::Children(CRI i){if(! m_set_children){SetChildren();}RE m_children[i];}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::Depth(CRI i){if(! m_set_depth){SetDepth();}RE m_depth[i];}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::Height(CRI i){if(! m_set_height){SetHeight();}RE m_height[i];}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::Weight(CRI i){if(! m_set_weight){SetWeight();}RE m_weight[i];}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::NodeNumber(CRI i,CO bool& reversed)CO{RE m_reversed[reversed?i:TH->SZ()- 1 - i];}TE <TY TREE> IN CRI DepthFirstSearchOnTree<TREE>::ChildrenNumber(CRI i){if(! m_set_children){SetChildren();}RE m_children_num[i];}TE <TY TREE>int DepthFirstSearchOnTree<TREE>::Ancestor(int i,int n){if(! m_set_doubling){SetDoubling();}AS((n >> m_digit)== 0);int d = 0;WH(n != 0){if((n & 1)== 1){AS((i = m_doubling[d][i])!= -1);}d++;n >>= 1;}RE i;}TE <TY TREE>int DepthFirstSearchOnTree<TREE>::LCA(int i,int j){int diff = Depth(i)- Depth(j);if(diff < 0){swap(i,j);diff *= -1;}i = Ancestor(i,diff);if(i == j){RE i;}int d = m_digit;WH(--d >= 0){CO VE<int>& doubling_d = m_doubling[d];CRI doubling_d_i = doubling_d[i];CRI doubling_d_j = doubling_d[j];if(doubling_d_i != doubling_d_j){i = doubling_d_i;j = doubling_d_j;AS(i != -1);AS(j != -1);}}RE Parent(i);}TE <TY TREE>int DepthFirstSearchOnTree<TREE>::LCA(int i,int j,int& i_prev,int& j_prev){if(i == j){i_prev = j_prev = -1;RE i;}int diff = Depth(i)- Depth(j);if(diff < 0){RE LCA(j,i,j_prev,i_prev);}if(diff > 0){i_prev = Ancestor(i,diff - 1);i = Parent(i_prev);AS(i != -1);if(i == j){j_prev = -1;RE i;}}else if(! m_set_doubling){SetDoubling();}int d = m_digit;WH(--d >= 0){CO VE<int>& doubling_d = m_doubling[d];CRI doubling_d_i = doubling_d[i];CRI doubling_d_j = doubling_d[j];if(doubling_d_i != doubling_d_j){i = doubling_d_i;j = doubling_d_j;AS(i != -1);AS(j != -1);}}i_prev = i;j_prev = j;RE Parent(i_prev);}TE <TY TREE>VO DepthFirstSearchOnTree<TREE>::SetChildren(){AS(!m_set_children);m_set_children = true;CRI V = TH->SZ();m_children.reSZ(V);m_children_num.reSZ(V);for(int i = 0;i < V;i++){CRI j = Parent(i);if(j == -1){m_children_num[i]= -1;}else{VE<int>& m_children_j = m_children[j];m_children_num[i]= m_children_j.SZ();m_children_j.push_back(i);}}RE;}TE <TY TREE>VO DepthFirstSearchOnTree<TREE>::SetDepth(){AS(!m_set_depth);m_set_depth = true;CRI V = TH->SZ();m_depth.reSZ(V);for(int i = 0;i < V;i++){CRI reversed_i = m_reversed[i];CRI parent_i = Parent(reversed_i);if(parent_i != -1){m_depth[i]+= m_depth[parent_i]+ 1;}}RE;}TE <TY TREE>VO DepthFirstSearchOnTree<TREE>::SetHeight(){AS(!m_set_height);m_set_height = true;CRI V = TH->SZ();m_height.reSZ(V);for(int i = 0;i < V;i++){CRI reversed_i = m_reversed[i];CRI parent_i = Parent(reversed_i);if(parent_i != -1){int& height_parent_i = m_height[parent_i];CRI height_i = m_height[reversed_i];height_parent_i > height_i?height_parent_i:height_parent_i = height_i + 1;}}RE;}TE <TY TREE>VO DepthFirstSearchOnTree<TREE>::SetWeight(){AS(!m_set_weight);m_set_weight = true;CRI V = TH->SZ();m_weight.reSZ(V);for(int i = 0;i < V;i++){CRI reversed_i = m_reversed[i];CRI parent_i = Parent(reversed_i);if(parent_i != -1){m_weight[parent_i]+= m_weight[reversed_i]+ 1;}}RE;}TE <TY TREE>VO DepthFirstSearchOnTree<TREE>::SetDoubling(){AS(!m_set_doubling);m_set_doubling = true;CRI V = TH->SZ();{VE<int>& doubling_0 = m_doubling[0];doubling_0.reserve(V);CRI r = Root();for(int i = 0;i < V;i++){doubling_0.push_back(Parent(i));}}for(int d = 1;d < m_digit;d++){VE<int>& doubling_d = m_doubling[d];VE<int>& doubling_d_minus = m_doubling[d-1];doubling_d.reserve(V);for(int i = 0;i < V;i++){CRI doubling_d_minus_i = doubling_d_minus[i];doubling_d.push_back(doubling_d_minus_i == -1?-1:doubling_d_minus[doubling_d_minus_i]);}}RE;}TE <TY TREE> TE <TY F>ret_t<F> DepthFirstSearchOnTree<TREE>::RootingDP(F& f){US U = ret_t<F>;ST_AS(is_invocable_r_v<U,F,LI<U>,int>);if(! m_set_children){SetChildren();}CRI V = TH->SZ();VE<LI<U>> children_value(V);U temp;for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);CRI j = Parent(i);temp = f(children_value[i],i);if(j != -1){children_value[j].push_back(temp);}}RE temp;}TE <TY TREE> TE <TY MONOID,TY F,TY G>VO DepthFirstSearchOnTree<TREE>::RerootingDP(MONOID M,F& f,G& g,VE<inner_t<MONOID>>& d){US U = inner_t<MONOID>;ST_AS(is_invocable_r_v<U,F,U,int> && is_invocable_r_v<U,G,U,bool,int,int>);if(! m_set_children){SetChildren();}CRI V = TH->SZ();CO U& e = M.Unit();d.reSZ(V);VE<VE<U>> children_value(V);VE<VE<U>> left_sum(V);VE<VE<U>> right_sum(V);for(int i = 0;i < V;i++){children_value[i].reSZ(m_children[i].SZ());}for(int n = 0;n < V;n++){CRI i = NodeNumber(n,true);CO VE<U>& children_value_i = children_value[i];CO int SZ_i = children_value_i.SZ();U temp = e;VE<U>& left_sum_i = left_sum[i];left_sum_i.reserve(SZ_i + 1);left_sum_i.push_back(temp);for(int m = 0;m < SZ_i;m++){left_sum_i.push_back(temp = M.Product(temp,g(children_value_i[m],true,i,m_children[i][m])));}CRI j = Parent(i);if(j != -1){children_value[j][m_children_num[i]]= f(temp,i);}temp = e;VE<U>& right_sum_i = right_sum[i];right_sum_i.reSZ(SZ_i);for(int m = 1;m <= SZ_i;m++){right_sum_i[SZ_i - m]= temp;temp = M.Product(g(children_value_i[SZ_i - m],true,i,m_children[i][SZ_i - m]),temp);}}for(int n = 1;n < V;n++){CRI i = NodeNumber(n);CRI j = Parent(i);CRI k = ChildrenNumber(i);VE<U>& left_sum_i = left_sum[i];VE<U>& right_sum_i = right_sum[i];CO int SZ_i = right_sum_i.SZ();CO U rest_i = g(f(M.Product(left_sum[j][k],right_sum[j][k]),j),false,i,j);for(int m = 0;m <= SZ_i;m++){U& left_sum_im = left_sum_i[m];left_sum_im = M.Product(rest_i,left_sum_im);}}for(int i = 0;i < V;i++){d[i]= f(left_sum[i].back(),i);}RE;}
