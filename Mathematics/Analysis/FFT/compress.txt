// FFTを使わない版は../../Polynomial/Mod/compress.txtへ。

// PW_CEはPower_constexpr最新版（羃を前計算）ではなく
// PowerPower_constexpr簡易版（2羃羃を前計算）を使用。（更新時に注意）

// 非常によくバグるので、更新したら必ずverifyすること！
// verify:
// https://yukicoder.me/submissions/892588
// https://yukicoder.me/submissions/916072

CEXPR(uint,P,998244353);TE <uint M,TY INT> CE INT& RS(INT& n)NE{RE n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n %= M;}TE <uint M> CE uint& RS(uint& n)NE{RE n %= M;}TE <uint M> CE ull& RS(ull& n)NE{RE n %= M;}TE <TY INT> CE INT& RSP(INT& n)NE{CE CO uint trunc = (1 << 23)- 1;INT n_u = n >> 23;n &= trunc;INT n_uq = (n_u / 7)/ 17;n_u -= n_uq * 119;n += n_u << 23;RE n < n_uq?n += P - n_uq:n -= n_uq;}TE <> CE ull& RS<P,ull>(ull& n)NE{CE CO ull Pull = P;CE CO ull Pull2 = (Pull - 1)* (Pull - 1);RE RSP(n > Pull2?n -= Pull2:n);}TE <uint M,TY INT> CE INT RS(INT&& n)NE{RE MO(RS<M>(n));}TE <uint M,TY INT> CE INT RS(CO INT& n)NE{RE RS<M>(INT(n));}

#define SFINAE_FOR_MOD(DEFAULT)TY T,enable_if_t<is_constructible<uint,decay_t<T> >::value>* DEFAULT
#define DC_OF_CM_FOR_MOD(FUNC)CE bool OP FUNC(CO Mod<M>& n)CO NE
#define DC_OF_AR_FOR_MOD(FUNC)CE Mod<M> OP FUNC(CO Mod<M>& n)CO NE;TE <SFINAE_FOR_MOD(= nullptr)> CE Mod<M> OP FUNC(T&& n)CO NE;
#define DF_OF_CM_FOR_MOD(FUNC)TE <uint M> CE bool Mod<M>::OP FUNC(CO Mod<M>& n)CO NE{RE m_n FUNC n.m_n;}
#define DF_OF_AR_FOR_MOD(FUNC,FORMULA)TE <uint M> CE Mod<M> Mod<M>::OP FUNC(CO Mod<M>& n)CO NE{RE MO(Mod<M>(*TH)FUNC ## = n);}TE <uint M> TE <SFINAE_FOR_MOD()> CE Mod<M> Mod<M>::OP FUNC(T&& n)CO NE{RE FORMULA;}TE <uint M,SFINAE_FOR_MOD(= nullptr)> CE Mod<M> OP FUNC(T&& n0,CO Mod<M>& n1)NE{RE MO(Mod<M>(forward<T>(n0))FUNC ## = n1);}

TE <uint M>CL Mod{PU:uint m_n;CE Mod()NE;CE Mod(CO Mod<M>& n)NE;CE Mod(Mod<M>& n)NE;CE Mod(Mod<M>&& n)NE;TE <SFINAE_FOR_MOD(= nullptr)> CE Mod(CO T& n)NE;TE <SFINAE_FOR_MOD(= nullptr)> CE Mod(T& n)NE;TE <SFINAE_FOR_MOD(= nullptr)> CE Mod(T&& n)NE;CE Mod<M>& OP=(CO Mod<M>& n)NE;CE Mod<M>& OP=(Mod<M>&& n)NE;CE Mod<M>& OP+=(CO Mod<M>& n)NE;CE Mod<M>& OP-=(CO Mod<M>& n)NE;CE Mod<M>& OP*=(CO Mod<M>& n)NE;IN Mod<M>& OP/=(CO Mod<M>& n);CE Mod<M>& OP<<=(int n)NE;CE Mod<M>& OP>>=(int n)NE;CE Mod<M>& OP++()NE;CE Mod<M> OP++(int)NE;CE Mod<M>& OP--()NE;CE Mod<M> OP--(int)NE;DC_OF_CM_FOR_MOD(==);DC_OF_CM_FOR_MOD(!=);DC_OF_CM_FOR_MOD(<);DC_OF_CM_FOR_MOD(<=);DC_OF_CM_FOR_MOD(>);DC_OF_CM_FOR_MOD(>=);DC_OF_AR_FOR_MOD(+);DC_OF_AR_FOR_MOD(-);DC_OF_AR_FOR_MOD(*);DC_OF_AR_FOR_MOD(/);CE Mod<M> OP<<(int n)CO NE;CE Mod<M> OP>>(int n)CO NE;CE Mod<M> OP-()CO NE;CE Mod<M>& SignInvert()NE;CE Mod<M>& Double()NE;CE Mod<M>& Halve()NE;IN Mod<M>& Invert();TE <TY T> CE Mod<M>& PositivePW(T&& EX)NE;TE <TY T> CE Mod<M>& NonNegativePW(T&& EX)NE;TE <TY T> CE Mod<M>& PW(T&& EX);CE VO swap(Mod<M>& n)NE;CE CRUI RP()CO NE;ST CE Mod<M> DeRP(CRUI n)NE;ST CE uint& Normalise(uint& n)NE;ST IN CO Mod<M>& Inverse(CRUI n)NE;ST IN CO Mod<M>& Factorial(CRUI n)NE;ST IN CO Mod<M>& FactorialInverse(CRUI n)NE;ST IN Mod<M> Combination(CRUI n,CRUI i)NE;ST IN CO Mod<M>& zero()NE;ST IN CO Mod<M>& one()NE;TE <TY T> CE Mod<M>& Ref(T&& n)NE;};

#define SFINAE_FOR_MN(DEFAULT)TY T,enable_if_t<is_constructible<Mod<M>,decay_t<T> >::value>* DEFAULT
#define DC_OF_AR_FOR_MN(FUNC)IN MN<M> OP FUNC(CO MN<M>& n)CO NE;TE <SFINAE_FOR_MOD(= nullptr)> IN MN<M> OP FUNC(T&& n)CO NE;
#define DF_OF_CM_FOR_MN(FUNC)TE <uint M> IN bool MN<M>::OP FUNC(CO MN<M>& n)CO NE{RE m_n FUNC n.m_n;}
#define DF_OF_AR_FOR_MN(FUNC,FORMULA)TE <uint M> IN MN<M> MN<M>::OP FUNC(CO MN<M>& n)CO NE{RE MO(MN<M>(*TH)FUNC ## = n);}TE <uint M> TE <SFINAE_FOR_MOD()> IN MN<M> MN<M>::OP FUNC(T&& n)CO NE{RE FORMULA;}TE <uint M,SFINAE_FOR_MOD(= nullptr)> IN MN<M> OP FUNC(T&& n0,CO MN<M>& n1)NE{RE MO(MN<M>(forward<T>(n0))FUNC ## = n1);}

TE <uint M>CL MN:PU Mod<M>{PU:CE MN()NE;CE MN(CO MN<M>& n)NE;CE MN(MN<M>& n)NE;CE MN(MN<M>&& n)NE;TE <SFINAE_FOR_MN(= nullptr)> CE MN(CO T& n)NE;TE <SFINAE_FOR_MN(= nullptr)> CE MN(T&& n)NE;CE MN<M>& OP=(CO MN<M>& n)NE;CE MN<M>& OP=(MN<M>&& n)NE;CE MN<M>& OP+=(CO MN<M>& n)NE;CE MN<M>& OP-=(CO MN<M>& n)NE;CE MN<M>& OP*=(CO MN<M>& n)NE;IN MN<M>& OP/=(CO MN<M>& n);CE MN<M>& OP<<=(int n)NE;CE MN<M>& OP>>=(int n)NE;CE MN<M>& OP++()NE;CE MN<M> OP++(int)NE;CE MN<M>& OP--()NE;CE MN<M> OP--(int)NE;DC_OF_AR_FOR_MN(+);DC_OF_AR_FOR_MN(-);DC_OF_AR_FOR_MN(*);DC_OF_AR_FOR_MN(/);CE MN<M> OP<<(int n)CO NE;CE MN<M> OP>>(int n)CO NE;CE MN<M> OP-()CO NE;CE MN<M>& SignInvert()NE;CE MN<M>& Double()NE;CE MN<M>& Halve()NE;CE MN<M>& Invert();TE <TY T> CE MN<M>& PositivePW(T&& EX)NE;TE <TY T> CE MN<M>& NonNegativePW(T&& EX)NE;TE <TY T> CE MN<M>& PW(T&& EX);CE uint RP()CO NE;CE Mod<M> Reduce()CO NE;ST CE MN<M> DeRP(CRUI n)NE;ST IN CO MN<M>& Formise(CRUI n)NE;ST IN CO MN<M>& Inverse(CRUI n)NE;ST IN CO MN<M>& Factorial(CRUI n)NE;ST IN CO MN<M>& FactorialInverse(CRUI n)NE;ST IN MN<M> Combination(CRUI n,CRUI i)NE;ST IN CO MN<M>& zero()NE;ST IN CO MN<M>& one()NE;ST CE uint Form(CRUI n)NE;ST CE ull& Reduction(ull& n)NE;ST CE ull& ReducedMU(ull& n,CRUI m)NE;ST CE uint MU(CRUI n0,CRUI n1)NE;ST CE uint BaseSquareTruncation(uint& n)NE;TE <TY T> CE MN<M>& Ref(T&& n)NE;};TE <uint M> CE MN<M> Twice(CO MN<M>& n)NE;TE <uint M> CE MN<M> Half(CO MN<M>& n)NE;TE <uint M> CE MN<M> Inverse(CO MN<M>& n);TE <uint M,TY T> CE MN<M> PW(MN<M> n,T EX);TE <TY T> CE MN<2> PW(CO MN<2>& n,CO T& p);TE <TY T> CE T Square(CO T& t);TE <> CE MN<2> Square<MN<2> >(CO MN<2>& t);TE <uint M> CE VO swap(MN<M>& n0,MN<M>& n1)NE;TE <uint M> IN string to_string(CO MN<M>& n)NE;TE<uint M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO MN<M>& n);

TE <uint M>CL COantsForMod{PU:COantsForMod()= delete;ST CE CO bool g_even = ((M & 1)== 0);ST CE CO uint g_memory_bound = 1000000;ST CE CO uint g_memory_LE = M < g_memory_bound?M:g_memory_bound;ST CE ull MNBasePW(ull&& EX)NE;ST CE uint g_M_minus = M - 1;ST CE uint g_M_minus_2 = M - 2;ST CE uint g_M_minus_2_neg = 2 - M;ST CE CO int g_MN_digit = 32;ST CE CO ull g_MN_base = ull(1)<< g_MN_digit;ST CE CO uint g_MN_base_minus = uint(g_MN_base - 1);ST CE CO uint g_MN_digit_half = (g_MN_digit + 1)>> 1;ST CE CO uint g_MN_base_sqrt_minus = (1 << g_MN_digit_half)- 1;ST CE CO uint g_MN_M_neg_inverse = uint((g_MN_base - MNBasePW((ull(1)<< (g_MN_digit - 1))- 1))& g_MN_base_minus);ST CE CO uint g_MN_base_mod = uint(g_MN_base % M);ST CE CO uint g_MN_base_square_mod = uint(((g_MN_base % M)* (g_MN_base % M))% M);};TE <uint M> CE ull COantsForMod<M>::MNBasePW(ull&& EX)NE{ull prod = 1;ull PW = M;WH(EX != 0){(EX & 1)== 1?(prod *= PW)&= g_MN_base_minus:prod;EX >>= 1;(PW *= PW)&= g_MN_base_minus;}RE prod;}

US MP = Mod<P>;US MNP = MN<P>;TE <uint M> CE uint MN<M>::Form(CRUI n)NE{ull n_copy = n;RE uint(MO(Reduction(n_copy *= COantsForMod<M>::g_MN_base_square_mod)));}TE <uint M> CE ull& MN<M>::Reduction(ull& n)NE{ull n_sub = n & COantsForMod<M>::g_MN_base_minus;RE ((n += ((n_sub *= COantsForMod<M>::g_MN_M_neg_inverse)&= COantsForMod<M>::g_MN_base_minus)*= M)>>= COantsForMod<M>::g_MN_digit)< M?n:n -= M;}TE <uint M> CE ull& MN<M>::ReducedMU(ull& n,CRUI m)NE{RE Reduction(n *= m);}TE <uint M> CE uint MN<M>::MU(CRUI n0,CRUI n1)NE{ull n0_copy = n0;RE uint(MO(ReducedMU(ReducedMU(n0_copy,n1),COantsForMod<M>::g_MN_base_square_mod)));}TE <uint M> CE uint MN<M>::BaseSquareTruncation(uint& n)NE{CO uint n_u = n >> COantsForMod<M>::g_MN_digit_half;n &= COantsForMod<M>::g_MN_base_sqrt_minus;RE n_u;}TE <uint M> CE MN<M>::MN()NE:Mod<M>(){static_assert(! COantsForMod<M>::g_even);}TE <uint M> CE MN<M>::MN(CO MN<M>& n)NE:Mod<M>(n){}TE <uint M> CE MN<M>::MN(MN<M>& n)NE:Mod<M>(n){}TE <uint M> CE MN<M>::MN(MN<M>&& n)NE:Mod<M>(MO(n)){}TE <uint M> TE <SFINAE_FOR_MN()> CE MN<M>::MN(CO T& n)NE:Mod<M>(n){static_assert(! COantsForMod<M>::g_even);Mod<M>::m_n = Form(Mod<M>::m_n);}TE <uint M> TE <SFINAE_FOR_MN()> CE MN<M>::MN(T&& n)NE:Mod<M>(forward<T>(n)){static_assert(! COantsForMod<M>::g_even);Mod<M>::m_n = Form(Mod<M>::m_n);}TE <uint M> CE MN<M>& MN<M>::OP=(CO MN<M>& n)NE{RE Ref(Mod<M>::OP=(n));}TE <uint M> CE MN<M>& MN<M>::OP=(MN<M>&& n)NE{RE Ref(Mod<M>::OP=(MO(n)));}TE <uint M> CE MN<M>& MN<M>::OP+=(CO MN<M>& n)NE{RE Ref(Mod<M>::OP+=(n));}TE <uint M> CE MN<M>& MN<M>::OP-=(CO MN<M>& n)NE{RE Ref(Mod<M>::OP-=(n));}TE <uint M> CE MN<M>& MN<M>::OP*=(CO MN<M>& n)NE{ull m_n_copy = Mod<M>::m_n;RE Ref(Mod<M>::m_n = MO(ReducedMU(m_n_copy,n.m_n)));}TE <uint M> IN MN<M>& MN<M>::OP/=(CO MN<M>& n){RE OP*=(MN<M>(n).Invert());}TE <uint M> CE MN<M>& MN<M>::OP<<=(int n)NE{RE Ref(Mod<M>::OP<<=(n));}TE <uint M> CE MN<M>& MN<M>::OP>>=(int n)NE{RE Ref(Mod<M>::OP>>=(n));}TE <uint M> CE MN<M>& MN<M>::OP++()NE{RE Ref(Mod<M>::Normalise(Mod<M>::m_n += COantsForMod<M>::g_MN_base_mod));}TE <uint M> CE MN<M> MN<M>::OP++(int)NE{MN<M> n{*TH};OP++();RE n;}TE <uint M> CE MN<M>& MN<M>::OP--()NE{RE Ref(Mod<M>::m_n < COantsForMod<M>::g_MN_base_mod?((Mod<M>::m_n += M)-= COantsForMod<M>::g_MN_base_mod):Mod<M>::m_n -= COantsForMod<M>::g_MN_base_mod);}TE <uint M> CE MN<M> MN<M>::OP--(int)NE{MN<M> n{*TH};OP--();RE n;}DF_OF_AR_FOR_MN(+,MN<M>(forward<T>(n))+= *TH);DF_OF_AR_FOR_MN(-,MN<M>(forward<T>(n)).SignInvert()+= *TH);DF_OF_AR_FOR_MN(*,MN<M>(forward<T>(n))*= *TH);DF_OF_AR_FOR_MN(/,MN<M>(forward<T>(n)).Invert()*= *TH);TE <uint M> CE MN<M> MN<M>::OP<<(int n)CO NE{RE MO(MN<M>(*TH)<<= n);}TE <uint M> CE MN<M> MN<M>::OP>>(int n)CO NE{RE MO(MN<M>(*TH)>>= n);}TE <uint M> CE MN<M> MN<M>::OP-()CO NE{RE MO(MN<M>(*TH).SignInvert());}TE <uint M> CE MN<M>& MN<M>::SignInvert()NE{RE Ref(Mod<M>::m_n > 0?Mod<M>::m_n = M - Mod<M>::m_n:Mod<M>::m_n);}TE <uint M> CE MN<M>& MN<M>::Double()NE{RE Ref(Mod<M>::Double());}TE <uint M> CE MN<M>& MN<M>::Halve()NE{RE Ref(Mod<M>::Halve());}TE <uint M> CE MN<M>& MN<M>::Invert(){assert(Mod<M>::m_n > 0);RE PositivePW(uint(COantsForMod<M>::g_M_minus_2));}TE <uint M> TE <TY T> CE MN<M>& MN<M>::PositivePW(T&& EX)NE{MN<M> PW{*TH};(--EX)%= COantsForMod<M>::g_M_minus_2;WH(EX != 0){(EX & 1)== 1?OP*=(PW):*TH;EX >>= 1;PW *= PW;}RE *TH;}TE <uint M> TE <TY T> CE MN<M>& MN<M>::NonNegativePW(T&& EX)NE{RE EX == 0?Ref(Mod<M>::m_n = COantsForMod<M>::g_MN_base_mod):PositivePW(forward<T>(EX));}TE <uint M> TE <TY T> CE MN<M>& MN<M>::PW(T&& EX){bool neg = EX < 0;assert(!(neg && Mod<M>::m_n == 0));RE neg?PositivePW(forward<T>(EX *= COantsForMod<M>::g_M_minus_2_neg)):NonNegativePW(forward<T>(EX));}TE <uint M> CE uint MN<M>::RP()CO NE{ull m_n_copy = Mod<M>::m_n;RE MO(Reduction(m_n_copy));}TE <uint M> CE Mod<M> MN<M>::Reduce()CO NE{ull m_n_copy = Mod<M>::m_n;RE Mod<M>::DeRP(MO(Reduction(m_n_copy)));}TE <uint M> CE MN<M> MN<M>::DeRP(CRUI n)NE{RE MN<M>(Mod<M>::DeRP(n));}TE <uint M> IN CO MN<M>& MN<M>::Formise(CRUI n)NE{ST MN<M> memory[COantsForMod<M>::g_memory_LE] ={zero(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr] = DeRP(LE_curr);LE_curr++;}RE memory[n];}TE <uint M> IN CO MN<M>& MN<M>::Inverse(CRUI n)NE{ST MN<M> memory[COantsForMod<M>::g_memory_LE] ={zero(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr] = MN<M>(Mod<M>::Inverse(LE_curr));LE_curr++;}RE memory[n];}TE <uint M> IN CO MN<M>& MN<M>::Factorial(CRUI n)NE{ST MN<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;ST MN<M> val_curr{one()};ST MN<M> val_last{one()};WH(LE_curr <= n){memory[LE_curr++] = val_curr *= ++val_last;}RE memory[n];}TE <uint M> IN CO MN<M>& MN<M>::FactorialInverse(CRUI n)NE{ST MN<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;ST MN<M> val_curr{one()};ST MN<M> val_last{one()};WH(LE_curr <= n){memory[LE_curr] = val_curr *= Inverse(LE_curr);LE_curr++;}RE memory[n];}TE <uint M> IN MN<M> MN<M>::Combination(CRUI n,CRUI i)NE{RE i <= n?Factorial(n)*FactorialInverse(i)*FactorialInverse(n - i):zero();}TE <uint M> IN CO MN<M>& MN<M>::zero()NE{ST CE CO MN<M> z{};RE z;}TE <uint M> IN CO MN<M>& MN<M>::one()NE{ST CE CO MN<M> o{DeRP(1)};RE o;}TE <uint M> TE <TY T> CE MN<M>& MN<M>::Ref(T&& n)NE{RE *TH;}TE <uint M> CE MN<M> Twice(CO MN<M>& n)NE{RE MO(MN<M>(n).Double());}TE <uint M> CE MN<M> Half(CO MN<M>& n)NE{RE MO(MN<M>(n).Halve());}TE <uint M> CE MN<M> Inverse(CO MN<M>& n){RE MO(MN<M>(n).Invert());}TE <uint M,TY T> CE MN<M> PW(MN<M> n,T EX){RE MO(n.PW(EX));}TE <uint M> CE VO swap(MN<M>& n0,MN<M>& n1)NE{n0.swap(n1);}TE <uint M> IN string to_string(CO MN<M>& n)NE{RE to_string(n.RP())+ " + MZ";}TE<uint M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO MN<M>& n){RE os << n.RP();}

TE <uint M> CE Mod<M>::Mod()NE:m_n(){}TE <uint M> CE Mod<M>::Mod(CO Mod<M>& n)NE:m_n(n.m_n){}TE <uint M> CE Mod<M>::Mod(Mod<M>& n)NE:m_n(n.m_n){}TE <uint M> CE Mod<M>::Mod(Mod<M>&& n)NE:m_n(MO(n.m_n)){}TE <uint M> TE <SFINAE_FOR_MOD()> CE Mod<M>::Mod(CO T& n)NE:m_n(RS<M>(n)){}TE <uint M> TE <SFINAE_FOR_MOD()> CE Mod<M>::Mod(T& n)NE:m_n(RS<M>(decay_t<T>(n))){}TE <uint M> TE <SFINAE_FOR_MOD()> CE Mod<M>::Mod(T&& n)NE:m_n(RS<M>(forward<T>(n))){}TE <uint M> CE Mod<M>& Mod<M>::OP=(CO Mod<M>& n)NE{RE Ref(m_n = n.m_n);}TE <uint M> CE Mod<M>& Mod<M>::OP=(Mod<M>&& n)NE{RE Ref(m_n = MO(n.m_n));}TE <uint M> CE Mod<M>& Mod<M>::OP+=(CO Mod<M>& n)NE{RE Ref(Normalise(m_n += n.m_n));}TE <uint M> CE Mod<M>& Mod<M>::OP-=(CO Mod<M>& n)NE{RE Ref(m_n < n.m_n?(m_n += M)-= n.m_n:m_n -= n.m_n);}TE <uint M> CE Mod<M>& Mod<M>::OP*=(CO Mod<M>& n)NE{RE Ref(m_n = COantsForMod<M>::g_even?RS<M>(ull(m_n)* n.m_n):MN<M>::MU(m_n,n.m_n));}TE <> CE MP& MP::OP*=(CO MP& n)NE{ull m_n_copy = m_n;RE Ref(m_n = MO((m_n_copy *= n.m_n)< P?m_n_copy:RSP(m_n_copy)));}TE <uint M> IN Mod<M>& Mod<M>::OP/=(CO Mod<M>& n){RE OP*=(Mod<M>(n).Invert());}TE <uint M> CE Mod<M>& Mod<M>::OP<<=(int n)NE{WH(n-- > 0){Normalise(m_n <<= 1);}RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::OP>>=(int n)NE{WH(n-- > 0){((m_n & 1)== 0?m_n:m_n += M)>>= 1;}RE *TH;}TE <uint M> CE Mod<M>& Mod<M>::OP++()NE{RE Ref(m_n < COantsForMod<M>::g_M_minus?++m_n:m_n = 0);}TE <uint M> CE Mod<M> Mod<M>::OP++(int)NE{Mod<M> n{*TH};OP++();RE n;}TE <uint M> CE Mod<M>& Mod<M>::OP--()NE{RE Ref(m_n == 0?m_n = COantsForMod<M>::g_M_minus:--m_n);}TE <uint M> CE Mod<M> Mod<M>::OP--(int)NE{Mod<M> n{*TH};OP--();RE n;}DF_OF_CM_FOR_MOD(==);DF_OF_CM_FOR_MOD(!=);DF_OF_CM_FOR_MOD(>);DF_OF_CM_FOR_MOD(>=);DF_OF_CM_FOR_MOD(<);DF_OF_CM_FOR_MOD(<=);DF_OF_AR_FOR_MOD(+,Mod<M>(forward<T>(n))+= *TH);DF_OF_AR_FOR_MOD(-,Mod<M>(forward<T>(n)).SignInvert()+= *TH);DF_OF_AR_FOR_MOD(*,Mod<M>(forward<T>(n))*= *TH);DF_OF_AR_FOR_MOD(/,Mod<M>(forward<T>(n)).Invert()*= *TH);TE <uint M> CE Mod<M> Mod<M>::OP<<(int n)CO NE{RE MO(Mod<M>(*TH)<<= n);}TE <uint M> CE Mod<M> Mod<M>::OP>>(int n)CO NE{RE MO(Mod<M>(*TH)>>= n);}TE <uint M> CE Mod<M> Mod<M>::OP-()CO NE{RE MO(Mod<M>(*TH).SignInvert());}TE <uint M> CE Mod<M>& Mod<M>::SignInvert()NE{RE Ref(m_n > 0?m_n = M - m_n:m_n);}TE <uint M> CE Mod<M>& Mod<M>::Double()NE{RE Ref(Normalise(m_n <<= 1));}TE <uint M> CE Mod<M>& Mod<M>::Halve()NE{RE Ref(((m_n & 1)== 0?m_n:m_n += M)>>= 1);}TE <uint M> IN Mod<M>& Mod<M>::Invert(){assert(m_n > 0);uint m_n_neg;RE m_n < COantsForMod<M>::g_memory_LE?Ref(m_n = Inverse(m_n).m_n):(m_n_neg = M - m_n < COantsForMod<M>::g_memory_LE)?Ref(m_n = M - Inverse(m_n_neg).m_n):PositivePW(uint(COantsForMod<M>::g_M_minus_2));}TE <> IN Mod<2>& Mod<2>::Invert(){assert(m_n > 0);RE *TH;}TE <uint M> TE <TY T> CE Mod<M>& Mod<M>::PositivePW(T&& EX)NE{Mod<M> PW{*TH};EX--;WH(EX != 0){(EX & 1)== 1?OP*=(PW):*TH;EX >>= 1;PW *= PW;}RE *TH;}TE <> TE <TY T> CE Mod<2>& Mod<2>::PositivePW(T&& EX)NE{RE *TH;}TE <uint M> TE <TY T> CE Mod<M>& Mod<M>::NonNegativePW(T&& EX)NE{RE EX == 0?Ref(m_n = 1):Ref(PositivePW(forward<T>(EX)));}TE <uint M> TE <TY T> CE Mod<M>& Mod<M>::PW(T&& EX){bool neg = EX < 0;assert(!(neg && m_n == 0));neg?EX *= COantsForMod<M>::g_M_minus_2_neg:EX;RE m_n == 0?*TH:(EX %= COantsForMod<M>::g_M_minus)== 0?Ref(m_n = 1):PositivePW(forward<T>(EX));}TE <uint M> IN CO Mod<M>& Mod<M>::Inverse(CRUI n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={zero(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr].m_n = M - MN<M>::MU(memory[M % LE_curr].m_n,M / LE_curr);LE_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::Factorial(CRUI n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr] = MN<M>::Factorial(LE_curr).Reduce();LE_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::FactorialInverse(CRUI n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr] = MN<M>::FactorialInverse(LE_curr).Reduce();LE_curr++;}RE memory[n];}TE <uint M> IN Mod<M> Mod<M>::Combination(CRUI n,CRUI i)NE{RE MN<M>::Combination(n,i).Reduce();}TE <uint M> CE VO Mod<M>::swap(Mod<M>& n)NE{std::swap(m_n,n.m_n);}TE <uint M> CE CRUI Mod<M>::RP()CO NE{RE m_n;}TE <uint M> CE Mod<M> Mod<M>::DeRP(CRUI n)NE{Mod<M> n_copy{};n_copy.m_n = n;RE n_copy;}TE <uint M> CE uint& Mod<M>::Normalise(uint& n)NE{RE n < M?n:n -= M;}TE <uint M> IN CO Mod<M>& Mod<M>::zero()NE{ST CE CO Mod<M> z{};RE z;}TE <uint M> IN CO Mod<M>& Mod<M>::one()NE{ST CE CO Mod<M> o{DeRP(1)};RE o;}TE <uint M> TE <TY T> CE Mod<M>& Mod<M>::Ref(T&& n)NE{RE *TH;}TE <uint M> CE Mod<M> Twice(CO Mod<M>& n)NE{RE MO(Mod<M>(n).Double());}TE <uint M> CE Mod<M> Half(CO Mod<M>& n)NE{RE MO(Mod<M>(n).Halve());}TE <uint M> IN Mod<M> Inverse(CO Mod<M>& n){RE MO(Mod<M>(n).Invert());}TE <uint M> CE Mod<M> Inverse_COrexpr(CRUI n)NE{RE MO(Mod<M>::DeRP(RS<M>(n)).NonNegativePW(M - 2));}TE <uint M,TY T> CE Mod<M> PW(Mod<M> n,T EX){RE MO(n.PW(EX));}TE <TY T>CE Mod<2> PW(Mod<2> n,const T& p){RE p == 0?Mod<2>::one():move(n);}TE <uint M> CE VO swap(Mod<M>& n0,Mod<M>& n1)NE{n0.swap(n1);}TE <uint M> IN string to_string(CO Mod<M>& n)NE{RE to_string(n.RP())+ " + MZ";}TE<uint M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n){RE os << n.RP();}

TE <TY T,uint EX_lim>CL PW_CE{PU:T m_val[EX_lim];IN CE PW_CE(CO T& t);};TE <TY T,uint EX_lim> CE PW_CE<T,EX_lim>::PW_CE(CO T& t):m_val() {T PW{t};for( uint EX = EX_lim - 1;EX < EX_lim;EX--){m_val[EX] = PW;PW *= PW;}}
#define PS_FOR_FFT(MOD,LE,BORDER,PR,IPR) static_assert((Mod<MOD>::DeRP(PR) *= Mod<MOD>::DeRP(IPR))==Mod<MOD>::DeRP(1));TE <> CE CO uint LimitOfPWForFFT<Mod<MOD> > = LE;TE <> CE CO uint LimitOfPWForFFT<MN<MOD> > = LimitOfPWForFFT<Mod<MOD> >;TE <> CE CO uint BorderForFFT<Mod<MOD> > = BORDER;TE <> CE CO uint BorderForFFT<MN<MOD> > = BorderForFFT<Mod<MOD> >;TE <> IN CO Mod<MOD> (&PrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<Mod<MOD> >]{ST CE PW_CE<Mod<MOD>,LimitOfPWForFFT<Mod<MOD> > > PRT{PR};static_assert(PRT.m_val[1]==Mod<MOD>::DeRP(MOD-1));RE PRT.m_val;}TE <> IN CO Mod<MOD> (&InversePrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<Mod<MOD> >]{ST CE PW_CE<Mod<MOD>,LimitOfPWForFFT<Mod<MOD> > > IPRT{IPR};RE IPRT.m_val;}TE <> IN CO MN<MOD> (&PrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<MN<MOD> >]{ST CE PW_CE<MN<MOD> ,LimitOfPWForFFT<MN<MOD> > > PRT{PR};RE PRT.m_val;}TE <> IN CO MN<MOD> (&InversePrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<MN<MOD> >]{ST CE PW_CE<MN<MOD>,LimitOfPWForFFT<MN<MOD> > > IPRT{IPR};RE IPRT.m_val;}
TE <TY T> CE CO uint LimitOfPWForFFT{};TE <TY T> CE CO uint BorderForFFT{};TE <TY T> IN CO T (&PrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<T>];TE <TY T> IN CO T (&InversePrimitiveRootOfTwoForFFT()NE)[LimitOfPWForFFT<T>];
PS_FOR_FFT(998244353,24,4,31,128805723);PS_FOR_FFT(167772161,26,4,17,29606852);PS_FOR_FFT(469762049,27,4,30,15658735);PS_FOR_FFT(754974721,25,4,362,415027540);
TE <TY T>VO CooleyTukey(VE<T>& f,CRUI N_input_start,CRUI N_input_lim,CRUI N_output_start,CRUI N_output_lim,CRUI two_PW,CRUI EX,CO T (&PRT)[LimitOfPWForFFT<T>]){CO uint LE = two_PW + N_input_start;f.reserve(LE);WH(f.SZ() < LE){f.push_back(0);}ST VE<uint> bit_reverse[32] ={VE<uint>(1)};ST uint e_next = 1;ST uint two_PW_next = 1;ST uint two_PW_next2 = 2;ST VE<uint>* p_bit_reverse_prev = bit_reverse;ST VE<uint>* p_bit_reverse_curr = p_bit_reverse_prev + 1;WH(e_next <= EX){*p_bit_reverse_curr = VE<uint>(two_PW_next2);uint* p_bit_reverse_curr_i = &((*p_bit_reverse_curr)[0]);uint* p_bit_reverse_curr_i_plus = p_bit_reverse_curr_i + two_PW_next;uint* p_bit_reverse_prev_i = &((*p_bit_reverse_prev)[0]);for(uint i = 0;i < two_PW_next;i++){(*(p_bit_reverse_curr_i_plus++) = *(p_bit_reverse_curr_i++) = *(p_bit_reverse_prev_i++) * 2) += 1;}e_next++;swap(two_PW_next,two_PW_next2);two_PW_next2 *= 4;p_bit_reverse_prev++;p_bit_reverse_curr++;}CO VE<uint>& bit_reverse_EX = bit_reverse[EX];uint bit_num = 0;CO uint* p_bit_num_reverse = &(bit_reverse_EX[bit_num]);WH(bit_num < two_PW){if(*p_bit_num_reverse < bit_num){swap(f[*p_bit_num_reverse + N_input_start],f[bit_num + N_input_start]);}bit_num++;p_bit_num_reverse++;}uint two_PW_curr = 1;uint two_PW_curr_2 = 2;CO T& zeta_0 = PRT[0];T zeta,diff;CO T* p_zeta_i;uint bit_num_copy,i,j,j_butterfly,j_lim;WH(two_PW_curr < two_PW){bit_num = 0;i = 0;WH(i < two_PW){zeta = zeta_0;p_zeta_i = &zeta_0 + 2;bit_num_copy = bit_num;WH(bit_num_copy != 0){if(bit_num_copy % 2 == 1){zeta *= *p_zeta_i;}bit_num_copy /= 2;p_zeta_i++;}j = i;j_lim = i + two_PW_curr;WH(j < j_lim){j_butterfly = j + two_PW_curr;T& f_j = f[j + N_input_start];T& f_j_butterfly = f[j_butterfly + N_input_start];diff = f_j - f_j_butterfly;f_j += f_j_butterfly;f_j_butterfly = zeta * diff;j++;}bit_num++;i += two_PW_curr_2;}swap(two_PW_curr,two_PW_curr_2);two_PW_curr_2 *= 4;}CO uint LE_fixed = N_output_lim + N_input_start;WH(f.SZ() > LE_fixed){f.pop_back();}RE;}TE <TY T> IN VO FFT(VE<T>& f,CRUI N_input_start,CRUI N_input_lim,CRUI two_PW,CRUI EX){CooleyTukey<T>(f,N_input_start,N_input_lim,0,two_PW,two_PW,EX,PrimitiveRootOfTwoForFFT<T>());}TE <TY T> IN VO FFT(VE<T>& f,CRUI N_input_start,CRUI N_input_lim,CRUI N_output_start,CRUI N_output_lim,CRUI two_PW,CRUI EX){CooleyTukey<T>(f,N_input_start,N_input_lim,N_output_start,N_output_lim,two_PW,EX,PrimitiveRootOfTwoForFFT<T>());}TE <TY T> IN VO IFFT(VE<T>& f,CRUI N_input_start,CRUI N_input_lim,CRUI two_PW,CO T& two_PW_inv,CRUI EX){CooleyTukey<T>(f,N_input_start,N_input_lim,0,two_PW,two_PW,EX,InversePrimitiveRootOfTwoForFFT<T>());CO uint SZ = two_PW + N_input_start;for(uint i = N_input_start;i < SZ;i++){f[i] *= two_PW_inv;}}TE <TY T> IN VO IFFT(VE<T>& f,CRUI N_input_start,CRUI N_input_lim,CRUI N_output_start,CRUI N_output_lim,CRUI two_PW,CO T& two_PW_inv,CRUI EX){CooleyTukey<T>(f,N_input_start,N_input_lim,N_output_start,N_output_lim,two_PW,EX,InversePrimitiveRootOfTwoForFFT<T>());CO uint SZ = N_output_lim + N_input_start;for(uint i = N_output_start + N_input_start;i < SZ;i++){f[i] *= two_PW_inv;}}

#define SFINAE_FOR_PO(DEFAULT) TY Arg,enable_if_t<is_constructible<T,decay_t<Arg> >::value>* DEFAULT
#define DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(TYPE,ARG,RHS) TE <> PO<TYPE>& PO<TYPE>::OP*=(ARG f){if(m_SZ != 0){VE<TYPE> v{};v.swap(m_f);TRPO<TYPE> TH_copy{m_SZ + f.m_SZ - 1,MO(v)};TH_copy *= RHS;m_f = MO(TH_copy.PO<TYPE>::m_f);m_SZ = m_f.SZ();}RE *TH;}

TE <TY T>CL PO{PU:VE<T> m_f;uint m_SZ;PU:IN PO();IN PO(CO T& t);IN PO(T&& t);TE <SFINAE_FOR_PO(= nullptr)> IN PO(CO Arg& n);IN PO(CO PO<T>& f);IN PO(PO<T>&& f);IN PO(CRUI i,CO T& t);IN PO(CRUI i,T&& t);TE <SFINAE_FOR_PO(= nullptr)> IN PO(CRUI i,CO Arg& n);IN PO(CO VE<T>& f);IN PO(VE<T>&& f);IN PO<T>& OP=(CO T& t);IN PO<T>& OP=(T&& t);TE <SFINAE_FOR_PO(= nullptr)> IN PO<T>& OP=(CO Arg& n);IN PO<T>& OP=(CO PO<T>& f);IN PO<T>& OP=(PO<T>&& f);IN PO<T>& OP=(CO VE<T>& f);IN PO<T>& OP=(VE<T>&& f);IN CO T& OP[](CRUI i) CO;IN T& OP[](CRUI i);IN T OP()(CO T& t) CO;PO<T>& OP+=(CO PO<T>& f);PO<T>& OP-=(CO PO<T>& f);PO<T>& OP*=(CO PO<T>& f);PO<T>& OP*=(PO<T>&& f);PO<T>& OP/=(CO T& t);IN PO<T>& OP/=(CO PO<T>& f);PO<T>& OP%=(CO T& t);PO<T>& OP%=(CO PO<T>& f);IN PO<T> OP-() CO;PO<T>& OP<<=(CO T& t);IN CO VE<T>& GetCoefficient() CO NE;IN CRUI SZ() CO NE;IN VO swap(PO<T>& f);IN VO swap(VE<T>& f);VO ReMORedundantZero();IN string Display() CO NE;ST PO<T> Quotient(CO PO<T>& f0,CO PO<T>& f1);ST PO<T> TransposeQuotient(CO PO<T>& f0,CRUI f0_transpose_SZ,CO PO<T>& f1_transpose_inverse,CRUI f1_SZ);ST PO<T> Transpose(CO PO<T>& f,CRUI f_transpose_SZ);ST IN CO PO<T>& zero();ST IN CO T& CO_zero();ST IN CO T& CO_one();ST IN CO T& CO_minus_one();};

#define RE_ZERO_FOR_MU_FOR_TR_PO_IF(CONDITION) if(CONDITION){RE OP=(zero);}
#define RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(CONDITION) if(CONDITION){RE TRPO<T>(m_N);}
#define RE_ZERO_FOR__FOR_TR_PO_IF(MU,CONDITION) RE_ZERO_FOR_ ## MU ## _FOR_TR_PO_IF(CONDITION)
#define SET_VE_FOR_AN_OF_MU_FOR_TR_PO(N_OUTPUT_LIM) if(PO<T>::m_SZ < N_OUTPUT_LIM){for(uint i = PO<T>::m_SZ;i < N_OUTPUT_LIM;i++){PO<T>::m_f.push_back(0);}PO<T>::m_SZ = N_OUTPUT_LIM;}
#define SET_VE_FOR_AN_OF_TR_MU_CO_FOR_TR_PO(N_OUTPUT_LIM) VE<T> AN(N_OUTPUT_LIM)
#define SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_OUTPUT_LIM) SET_VE_FOR_AN_OF_ ## MU ## _FOR_TR_PO(N_OUTPUT_LIM)
#define SET_SUM_OF_MU_FOR_TR_PO PO<T>::m_f[i] = sum
#define SET_SUM_OF_TR_MU_CO_FOR_TR_PO AN[i] = sum
#define SET_SUM_OF__FOR_TR_PO(MU) SET_SUM_OF_ ## MU ## _FOR_TR_PO
#define SET_N_INPUT_START_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_START_NUM) uint N_INPUT_START_NUM{};for(uint i = 0;i < SZ && searching;i++){if(F[i] != zero){N_INPUT_START_NUM = i;searching = false;}}
#define SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(F,SZ,N_INPUT_MAX_NUM) uint N_INPUT_MAX_NUM{};searching = true;for(uint i = (SZ) - 1;searching;i--){if(F[i] != zero){N_INPUT_MAX_NUM = i;searching = false;}}
#define CN_FOR_MU_FOR_TR_PO(J_MIN) CO uint j_max = i < N_input_max_0_start_1?i - N_input_start_1:N_input_max_0;T sum{zero};for(uint j = J_MIN;j <= j_max;j++){sum += PO<T>::m_f[j] * f.PO<T>::m_f[i - j];}PO<T>::m_f[i] = sum;
#define CN_FOR_TR_MU_CO_FOR_TR_PO(J_MIN) CO uint j_max = i < N_input_max_0_start_1?i - N_input_start_1:N_input_max_0;T& m_fi = AN[i];for(uint j = J_MIN;j <= j_max;j++){m_fi += PO<T>::m_f[j] * f.PO<T>::m_f[i - j];}
#define CN_FOR__FOR_TR_PO(MU,J_MIN) CN_FOR_ ## MU ## _FOR_TR_PO(J_MIN)
#define ZEROIFICATION_FOR_MU_FOR_TR_PO for(uint i = 0;i < N_input_start_0_start_1;i++){PO<T>::m_f[i] = 0;}
#define ZEROIFICATION_FOR_TR_MU_CO_FOR_TR_PO CRUI N_output_start_fixed = N_output_start < N_input_start_0_start_1?N_output_start:N_input_start_0_start_1;for(uint i = 0;i < N_output_start_fixed;i++){AN[i] = 0;}
#define ZEROIFICATION_FOR__FOR_TR_PO(MU) ZEROIFICATION_FOR_ ## MU ## _FOR_TR_PO
#define DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY,N_OUTPUT_START) RE_ZERO_FOR__FOR_TR_PO_IF(MU,PO<T>::m_SZ == 0);uint N_output_max = PO<T>::m_SZ + f.PO<T>::m_SZ - 2;if(N_output_max >= m_N){N_output_max = m_N - 1;}CO uint N_output_lim = N_output_max + 1;SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_output_lim);for(uint i = N_output_max;searching;i--){T sum{zero};for(uint j = 0;j <= i;j++){sum += ACCESS_ENTRY * f.PO<T>::OP[](i - j);}SET_SUM_OF__FOR_TR_PO(MU);searching = i > N_OUTPUT_START;}
#define DF_1_OF__FOR_TR_PO(MU) SET_N_INPUT_START_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_start_0);RE_ZERO_FOR__FOR_TR_PO_IF(MU,searching);searching = true;SET_N_INPUT_START_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ,N_input_start_1);
#define SET_N_INPUT_RANGE SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(PO<T>::m_f,PO<T>::m_SZ,N_input_max_0);SET_N_INPUT_MAX_FOR_MU_FOR_TR_PO(f,f.PO<T>::m_SZ < m_N?f.PO<T>::m_SZ:m_N,N_input_max_1);CO uint N_input_max_0_max_1 = N_input_max_0 + N_input_max_1;CO uint N_input_start_0_start_1 = N_input_start_0 + N_input_start_1;uint N_output_lim_fixed = N_input_max_0_max_1 < m_N?N_input_max_0_max_1 + 1:m_N;
#define DF_3_OF__FOR_TR_PO(MU) CO uint N_input_start_0_max_1 = N_input_start_0 + N_input_max_1;CO uint N_input_max_0_start_1 = N_input_max_0 + N_input_start_1;CO uint N_output_max_fixed = N_output_lim_fixed - 1;SET_VE_FOR_AN_OF__FOR_TR_PO(MU,N_output_lim_fixed);for(uint i = N_output_max_fixed;i > N_input_start_0_max_1;i--){CN_FOR__FOR_TR_PO(MU,i - N_input_max_1);}searching = true;for(uint i = N_input_start_0_max_1 < N_output_max_fixed?N_input_start_0_max_1:N_output_max_fixed;searching;i--){CN_FOR__FOR_TR_PO(MU,N_input_start_0);searching = i > N_input_start_0_start_1;}ZEROIFICATION_FOR__FOR_TR_PO(MU);
#define SET_SHIFTED_VE_FOR_MU(V,F,I_START,I_MAX,I_SHIFT) VE<T> V(product_LE);for(uint i = I_START;i <= I_MAX;i++){V[I_SHIFT + i] = F[i];}
#define DF_OF_MU_FOR_TR_PO(RE_LINE_0,RE_LINE_1,RE_LINE_2,RE_LINE_3,RE_LINE_4,MU,ACCESS_ENTRY,N_OUTPUT_START,FIX_N_OUTPUT_LIM) CE CRUI border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){RE_LINE_0;DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY,N_OUTPUT_START);RE_LINE_1;}DF_1_OF__FOR_TR_PO(MU);RE_LINE_2;SET_N_INPUT_RANGE;FIX_N_OUTPUT_LIM;RE_LINE_3;DF_3_OF__FOR_TR_PO(MU);RE_LINE_4;
#define DF_OF_FFT_MU_FOR_TR_PO(RE_LINE_0,RE_LINE_1,RE_LINE_2,RE_LINE_3,RE_LINE_4,RE_LINE_5,MU,ACCESS_ENTRY,N_OUTPUT_START,N_OUTPUT_START_SHIFTED,FIX_N_OUTPUT_LIM,DC_OF_F0,N_INPUT_START_0,N_INPUT_LIM_0,DC_OF_F1,N_INPUT_START_1,N_INPUT_LIM_1,VE_FOR_IFFT,RESZ_VE_FOR_IFFT,I_START,MU_FORMULA,SET_AN) CE CRUI border_0 = FFT_MU_border_0<T>;CO T& zero = PO<T>::CO_zero();bool searching = true;if(PO<T>::m_SZ < border_0 && f.PO<T>::m_SZ < border_0){RE_LINE_0;DF_0_OF__FOR_TR_PO(MU,ACCESS_ENTRY,N_OUTPUT_START);RE_LINE_1;}DF_1_OF__FOR_TR_PO(MU);RE_LINE_2;SET_N_INPUT_RANGE;FIX_N_OUTPUT_LIM;RE_LINE_3;CO uint N_input_TR_deg_0_deg_1 = N_input_max_0 - N_input_start_0 + N_input_max_1 - N_input_start_1;CE CRUI border_1 = FFT_MU_border_1<T>;if(N_input_TR_deg_0_deg_1 < border_1){DF_3_OF__FOR_TR_PO(MU);RE_LINE_4;}uint two_PW = FFT_MU_border_1_2<T>;uint EX = FFT_MU_border_1_2_EX<T>;T two_PW_inv{FFT_MU_border_1_2_inv<T>};WH(N_input_TR_deg_0_deg_1 >= two_PW){two_PW *= 2;two_PW_inv /= 2;EX++;}CO uint product_LE = N_input_start_0_start_1 + two_PW;DC_OF_F0;FFT<T>(f0,N_INPUT_START_0,N_INPUT_LIM_0,two_PW,EX);DC_OF_F1;FFT<T>(f1,N_INPUT_START_1,N_INPUT_LIM_1,two_PW,EX);RESZ_VE_FOR_IFFT;for(uint i = I_START + two_PW - 1;true;i--){MU_FORMULA;if(i == I_START){break;}}CO uint N_output_start_shifted = N_OUTPUT_START_SHIFTED;CO uint N_output_lim_shifted = N_output_lim_fixed - N_input_start_0_start_1;IFFT<T>(VE_FOR_IFFT,N_input_start_0_start_1,product_LE,N_output_start_shifted,N_output_lim_shifted,two_PW,two_PW_inv,EX);SET_AN;RE_LINE_5;
#define DF_OF_INVERSE_FOR_TR_PO(TYPE,RECURSION) CRUI N = f.GetTruncation();uint PW;uint PW_2 = 1;TRPO< TYPE > f_inv{PW_2,PO< TYPE >::CO_one() / f[0]};WH(PW_2 < N){PW = PW_2;PW_2 *= 2;f_inv.SetTruncation(PW_2);RECURSION;}f_inv.SetTruncation(N);RE f_inv
#define DF_OF_EXP_FOR_TR_PO(TYPE,RECURSION) CRUI N = f.GetTruncation();uint PW;uint PW_2 = 1;TRPO< TYPE > f_exp{PW_2,PO< TYPE >::CO_one()};WH(PW_2 < N){PW = PW_2;PW_2 *= 2;f_exp.SetTruncation(PW_2);RECURSION;}f_exp.SetTruncation(N);RE f_exp
#define DF_OF_PS_OF_MU_OF_TR_PO(TYPE,BORDER_0,BORDER_1,BORDER_1_2,BORDER_1_2_EX,BORDER_1_2_INV) TE <> CE CO uint FFT_MU_border_0< TYPE > = BORDER_0;TE <> CE CO uint FFT_MU_border_1< TYPE > = BORDER_1;TE <> CE CO uint FFT_MU_border_1_2< TYPE > = BORDER_1_2;TE <> CE CO uint FFT_MU_border_1_2_EX< TYPE > = BORDER_1_2_EX;TE <> CE CO uint FFT_MU_border_1_2_inv< TYPE > = BORDER_1_2_INV;TE <> IN TRPO< TYPE >& TRPO< TYPE >::OP*=(CO PO< TYPE >& f){RE TRPO< TYPE >::FFT_MU(f);}TE <> IN TRPO< TYPE >& TRPO< TYPE >::OP*=(PO< TYPE >&& f){RE TRPO< TYPE >::FFT_MU(MO(f));}TE <> TRPO< TYPE > Inverse(CO TRPO< TYPE >& f){DF_OF_INVERSE_FOR_TR_PO(TYPE,f_inv.TRMinus(f_inv.FFT_TRMU_CO(f,PW,PW_2).FFT_TRMU(f_inv,PW,PW_2),PW,PW_2));}TE <> TRPO< TYPE > Exp(CO TRPO< TYPE >& f){DF_OF_EXP_FOR_TR_PO(TYPE,f_exp.TRMinus((TRIntegral(Differential(f_exp).FFT_TRMU_CO(Inverse(f_exp),PW - 1,PW_2),PW).TRMinus(f,PW,PW_2)).FFT_TRMU(f_exp,PW,PW_2),PW,PW_2));}
#define DF_OF_PS_OF_MU_OF_PO_PROTH_MOD( MOD , BORDER_1_2_INV ) static_assert((Mod<MOD>(1024)*=Mod<MOD>(BORDER_1_2_INV))==Mod<MOD>::DeRP(1));DF_OF_PS_OF_MU_OF_TR_PO(Mod<MOD>,17,512,1024,10,BORDER_1_2_INV);DF_OF_PS_OF_MU_OF_TR_PO(MN<MOD>,17,512,1024,10,BORDER_1_2_INV);DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(Mod<MOD>,CO PO<Mod<MOD> >&,TH == &f?TH_copy:f);DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(Mod<MOD>,PO<Mod<MOD> >&&,MO(f));DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(MN<MOD>,CO PO<MN<MOD> >&,TH == &f?TH_copy:f);DF_BODY_OF_PS_OF_MU_OF_PO_PROTH_MOD(MN<MOD>,PO<MN<MOD> >&&,MO(f));

TE <TY T>CL TRPO :PU PO<T>{PU:uint m_N;PU:IN TRPO(CRUI N = 0);IN TRPO(CO TRPO<T>& f);IN TRPO(TRPO<T>&& f);IN TRPO(CRUI N,CO T& t);IN TRPO(CRUI N,CO PO<T>& f);IN TRPO(CRUI N,PO<T>&& f);IN TRPO(CRUI N,CRUI i,CO T& t);IN TRPO(CRUI N,CRUI i,T&& t);TE <SFINAE_FOR_PO(= nullptr)> IN TRPO(CRUI N,CRUI i,CO Arg& t);IN TRPO(CRUI N,VE<T>&& f);IN TRPO<T>& OP=(CO TRPO<T>& f);IN TRPO<T>& OP=(TRPO<T>&& f);IN TRPO<T>& OP=(CO T& t);IN TRPO<T>& OP=(T&& t);TE <SFINAE_FOR_PO(= nullptr)> IN TRPO<T>& OP=(CO Arg& n);IN TRPO<T>& OP=(CO PO<T>& f);IN TRPO<T>& OP=(PO<T>&& f);IN TRPO<T>& OP+=(CO T& t);IN TRPO<T>& OP+=(CO PO<T>& f);IN TRPO<T>& OP+=(CO TRPO<T>& f);TRPO<T>& TRPlus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_limit);IN TRPO<T>& OP-=(CO T& t);IN TRPO<T>& OP-=(CO PO<T>& f);IN TRPO<T>& OP-=(CO TRPO<T>& f);TRPO<T>& TRMinus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_limit);IN TRPO<T>& OP*=(CO T& t);TRPO<T>& OP*=(CO PO<T>& f);IN TRPO<T>& OP*=(PO<T>&& f);TRPO<T>& FFT_MU(CO PO<T>& f);TRPO<T>& FFT_MU(PO<T>&& f);TRPO<T>& TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim);TRPO<T>& FFT_TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim);TRPO<T>& FFT_TRMU(PO<T>&& f,CRUI N_output_start,CRUI N_output_lim);TRPO<T> TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim) CO;TRPO<T> FFT_TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim) CO;TRPO<T> FFT_TRMU_CO(PO<T>&& f,CRUI N_output_start,CRUI N_output_lim) CO;IN TRPO<T>& OP/=(CO T& t);IN TRPO<T>& OP/=(CO TRPO<T>& t);IN TRPO<T>& OP%=(CO T& t);IN TRPO<T> OP-() CO;IN VO SetTruncation(CRUI N)NE;IN CRUI GetTruncation() CO NE;IN TRPO<T>& TruncateInitial(CRUI N)NE;IN TRPO<T>& TruncateFinal(CRUI N)NE;};TE <TY T> CE CO uint FFT_MU_border_0 = 17;TE <TY T> CE CO uint FFT_MU_border_1{};TE <TY T> CE CO uint FFT_MU_border_1_2{};TE <TY T> CE CO uint FFT_MU_border_1_2_EX{};TE <TY T> CE CO uint FFT_MU_border_1_2_inv{};

TE <TY T> IN TRPO<T>::TRPO(CRUI N):PO<T>(),m_N(N){PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(CO TRPO<T>& f):PO<T>(f),m_N(f.m_N){PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(TRPO<T>&& f):PO<T>(MO(f)),m_N(MO(f.m_N)){PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CO T& t):PO<T>(t),m_N(N){PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CO PO<T>& f):PO<T>(),m_N(N){PO<T>::m_SZ = f.PO<T>::m_SZ < m_N?f.PO<T>::m_SZ:m_N;PO<T>::m_f = VE<T>(PO<T>::m_SZ);for(uint i = 0;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] = f.PO<T>::m_f[i];}PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(CRUI N,PO<T>&& f):PO<T>(),m_N(N){if(f.PO<T>::m_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f.PO<T>::m_SZ < m_N){PO<T>::m_f.reserve(m_N);}else{TruncateFinal(m_N);}}else{PO<T>::m_f = VE<T>(m_N);for(uint i = 0;i < m_N;i++){PO<T>::m_f[i] = MO(f.PO<T>::m_f[i]);}PO<T>::m_SZ = m_N;}}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CRUI i,CO T& t):PO<T>(),m_N(N){if(i < m_N?t != PO<T>::CO_zero():false){PO<T>::OP[](i) = t;}PO<T>::m_f.reserve(m_N);}TE <TY T> IN TRPO<T>::TRPO(CRUI N,CRUI i,T&& t):PO<T>(),m_N(N){if(i < m_N?t != PO<T>::CO_zero():false){PO<T>::OP[](i) = MO(t);}PO<T>::m_f.reserve(m_N);}TE <TY T> TE <SFINAE_FOR_PO()> IN TRPO<T>::TRPO(CRUI N,CRUI i,CO Arg& n):TRPO(N,i,T(n)){}TE <TY T> IN TRPO<T>::TRPO(CRUI N,VE<T>&& f):PO<T>(),m_N(N){CO uint f_SZ = f.SZ();if(f_SZ < m_N * 2){PO<T>::OP=(MO(f));if(f_SZ < m_N){PO<T>::m_f.reserve(m_N);}else{TruncateFinal(m_N);}}else{PO<T>::m_f = VE<T>(m_N);for(uint i = 0;i < m_N;i++){PO<T>::m_f[i] = MO(f[i]);}PO<T>::m_f.reserve(m_N);}}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO TRPO<T>& f){PO<T>::OP=(f);m_N = f.m_N;PO<T>::m_f.reserve(m_N);RE *TH;}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(TRPO<T>&& f){PO<T>::OP=(MO(f));m_N = MO(f.m_N);PO<T>::m_f.reserve(m_N);RE *TH;}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO T& t){PO<T>::OP=(t);RE *TH;}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(T&& t){PO<T>::OP=(MO(t));RE *TH;}
TE <TY T> TE <SFINAE_FOR_PO()> IN TRPO<T>& TRPO<T>::OP=(CO Arg& n){PO<T>::OP=(T(n));RE *TH;}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(CO PO<T>& f){RE OP=(TRPO<T>(m_N,f));}
TE <TY T> IN TRPO<T>& TRPO<T>::OP=(PO<T>&& f){RE OP=(TRPO<T>(m_N,MO(f)));}
TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO T& t){PO<T>::OP+=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO PO<T>& f){RE TRPO<T>::TRPlus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP+=(CO TRPO<T>& f){RE m_N == 0?OP=(f):TRPO<T>::TRPlus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRPlus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_lim){CRUI SZ = N_input_lim < m_N?N_input_lim < f.PO<T>::m_SZ?N_input_lim:f.PO<T>::m_SZ:m_N < f.PO<T>::m_SZ?m_N:f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(uint i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] += f.PO<T>::m_f[i];}for(uint i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;}else{for(uint i = N_input_start;i < SZ;i++){PO<T>::m_f[i] += f.PO<T>::m_f[i];}}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO T& t){PO<T>::OP-=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO PO<T>& f){RE TRPO<T>::TRMinus(f,0,f.m_SZ);}TE <TY T> IN TRPO<T>& TRPO<T>::OP-=(CO TRPO<T>& f){RE m_N == 0?OP=(-f):TRPO<T>::TRMinus(f,0,f.PO<T>::m_SZ);}TE <TY T>TRPO<T>& TRPO<T>::TRMinus(CO PO<T>& f,CRUI N_input_start,CRUI N_input_lim){CRUI SZ = N_input_lim < m_N?N_input_lim < f.PO<T>::m_SZ?N_input_lim:f.PO<T>::m_SZ:m_N < f.PO<T>::m_SZ?m_N:f.PO<T>::m_SZ;if(PO<T>::m_SZ < SZ){PO<T>::m_f.reserve(SZ);for(uint i = N_input_start;i < PO<T>::m_SZ;i++){PO<T>::m_f[i] -= f.PO<T>::m_f[i];}for(uint i = PO<T>::m_SZ;i < SZ;i++){PO<T>::m_f.push_back(- f.PO<T>::m_f[i]);}PO<T>::m_SZ = SZ;}else{for(uint i = N_input_start;i < SZ;i++){PO<T>::m_f[i] -= f.PO<T>::m_f[i];}}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP*=(CO T& t){PO<T>::OP*=(t);RE *TH;}TE <TY T>TRPO<T>& TRPO<T>::OP*=(CO PO<T>& f){DF_OF_MU_FOR_TR_PO(RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0),,RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching),RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= m_N),RE *TH,MU,PO<T>::m_f[j],0,);}TE <TY T> IN TRPO<T>& TRPO<T>::OP*=(PO<T>&& f){RE OP*=(f);}TE <TY T>TRPO<T>& TRPO<T>::FFT_MU(CO PO<T>& f){DF_OF_FFT_MU_FOR_TR_PO(RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0),RE *TH,RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching),RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,RE *TH,MU,PO<T>::m_f[j],0,0,,VE<T>& f0 = PO<T>::m_f,N_input_start_0,N_input_max_0 + 1,SET_SHIFTED_VE_FOR_MU(f1,f.PO<T>::m_f,N_input_start_1,N_input_max_1,N_input_start_0),N_input_start_0_start_1,N_input_start_0 + N_input_max_1 + 1,f1,,N_input_start_0,f1[N_input_start_1 + i] *= f0[i],OP=(TRPO<T>(m_N,MO(f1))));}TE <TY T>TRPO<T>& TRPO<T>::FFT_MU(PO<T>&& f){DF_OF_FFT_MU_FOR_TR_PO(RE_ZERO_FOR_MU_FOR_TR_PO_IF(f.PO<T>::m_SZ == 0),RE *TH,RE_ZERO_FOR_MU_FOR_TR_PO_IF(searching),RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,RE *TH,MU,PO<T>::m_f[j],0,0,,VE<T>& f0 = PO<T>::m_f,N_input_start_0,N_input_max_0 + 1,VE<T>&& f1 = MO(f.PO<T>::m_f),N_input_start_1,N_input_max_1 + 1,f0,f0.resize(product_LE),0,f0[N_input_start_0_start_1 + i] = f0[N_input_start_0 + i] * f1[N_input_start_1 + i],for(uint i = N_input_start_0;i < N_input_start_0_start_1;i++){f0[i] = 0;}PO<T>::m_SZ = f0.SZ();SetTruncation(m_N););}TE <TY T>TRPO<T>& TRPO<T>::TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim){DF_OF_MU_FOR_TR_PO(,RE *TH,,RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,MU,PO<T>::m_f[j],N_output_start,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;});}TE <TY T>TRPO<T>& TRPO<T>::FFT_TRMU(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim){DF_OF_FFT_MU_FOR_TR_PO(,RE *TH,,RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,RE *TH,MU,PO<T>::m_f[j],N_output_start,N_output_start < N_input_start_0_start_1?0:N_output_start - N_input_start_0_start_1,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;},VE<T>& f0 = PO<T>::m_f,N_input_start_0,N_input_max_0 + 1,SET_SHIFTED_VE_FOR_MU(f1,f.PO<T>::m_f,N_input_start_0,N_input_max_1,N_input_start_1),N_input_start_0_start_1,N_input_start_0 + N_input_max_1 + 1,f1,,N_input_start_0,f1[N_input_start_1 + i] *= f0[i],OP=(TRPO<T>(m_N,MO(f1))));}TE <TY T>TRPO<T>& TRPO<T>::FFT_TRMU(PO<T>&& f,CRUI N_output_start,CRUI N_output_lim){DF_OF_FFT_MU_FOR_TR_PO(,RE *TH,,RE_ZERO_FOR_MU_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE *TH,RE *TH,MU,PO<T>::m_f[j],N_output_start,N_output_start < N_input_start_0_start_1?0:N_output_start - N_input_start_0_start_1,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;},VE<T>& f0 = PO<T>::m_f,N_input_start_0,N_input_max_0 + 1,VE<T>&& f1 = MO(f.PO<T>::m_f),N_input_start_1,N_input_max_1 + 1,f0,f0.reserve(product_LE),0,f1[N_input_start_0_start_1 + i] = f0[N_input_start_0 + i] * f1[N_input_start_1 + i],for(uint i = N_input_start_0;i < N_input_start_0_start_1;i++){f0[i] = 0;}PO<T>::m_SZ = f0.SZ();SetTruncation(m_N););}TE <TY T>TRPO<T> TRPO<T>::TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim) CO{DF_OF_MU_FOR_TR_PO(,RE TRPO<T>(m_N,MO(AN)),,RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE TRPO<T>(m_N,MO(AN)),TR_MU_CO,PO<T>::OP[](j),N_output_start,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;});}TE <TY T>TRPO<T> TRPO<T>::FFT_TRMU_CO(CO PO<T>& f,CRUI N_output_start,CRUI N_output_lim) CO{DF_OF_FFT_MU_FOR_TR_PO(,RE TRPO<T>(m_N,MO(AN)),,RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE TRPO<T>(m_N,MO(AN)),RE TRPO<T>(m_N,MO(f0)),TR_MU_CO,PO<T>::OP[](j),N_output_start,N_output_start < N_input_start_0_start_1?0:N_output_start - N_input_start_0_start_1,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;},SET_SHIFTED_VE_FOR_MU(f0,PO<T>::m_f,N_input_start_0,N_input_max_0,N_input_start_1),N_input_start_0_start_1,N_input_start_1 + N_input_max_0 + 1,VE<T> f1 = f.PO<T>::m_f,N_input_start_1,N_input_max_1 + 1,f0,,N_input_start_1,f0[N_input_start_0 + i] *= f1[i],);}TE <TY T>TRPO<T> TRPO<T>::FFT_TRMU_CO(PO<T>&& f,CRUI N_output_start,CRUI N_output_lim) CO{DF_OF_FFT_MU_FOR_TR_PO(,RE TRPO<T>(m_N,MO(AN)),,RE_ZERO_FOR_TR_MU_CO_FOR_TR_PO_IF(N_input_start_0_start_1 >= N_output_lim_fixed),RE TRPO<T>(m_N,MO(AN)),RE TRPO<T>(m_N,MO(f0)),TR_MU_CO,PO<T>::OP[](j),N_output_start,N_output_start < N_input_start_0_start_1?0:N_output_start - N_input_start_0_start_1,if(N_output_lim_fixed > N_output_lim){N_output_lim_fixed = N_output_lim;},SET_SHIFTED_VE_FOR_MU(f0,PO<T>::m_f,N_input_start_0,N_input_max_0,N_input_start_1),N_input_start_0_start_1,N_input_start_1 + N_input_max_0 + 1,VE<T>&& f1 = MO(f.PO<T>::m_f),N_input_start_1,N_input_max_1 + 1,f0,,N_input_start_1,f0[N_input_start_0 + i] *= f1[i],);}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO T& t){PO<T>::OP/=(t);RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::OP/=(CO TRPO<T>& f){RE OP*=(Inverse(m_N > f.m_N?f:TRPO<T>(m_N,f)));}TE <TY T> IN TRPO<T>& TRPO<T>::OP%=(CO T& t){PO<T>::OP%=(t);RE *TH;}TE <TY T> IN TRPO<T> TRPO<T>::OP-() CO{RE MO(TRPO<T>(m_N) -= *TH);}TE <TY T> IN VO TRPO<T>::SetTruncation(CRUI N)NE{if(N < m_N){TruncateFinal(m_N);}else{PO<T>::m_f.reserve(N);}m_N = N;}TE <TY T> IN CRUI TRPO<T>::GetTruncation() CO NE{RE m_N;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateInitial(CRUI N)NE{CRUI SZ = N < PO<T>::m_SZ?N:PO<T>::m_SZ;for(uint i = 0;i < SZ;i++){PO<T>::m_f[i] = 0;}RE *TH;}TE <TY T> IN TRPO<T>& TRPO<T>::TruncateFinal(CRUI N)NE{WH(PO<T>::m_SZ > N){PO<T>::m_f.pop_back();PO<T>::m_SZ--;}RE *TH;}TE <TY T,TY P> IN TRPO<T> OP+(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0) += f1);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f){RE MO(TRPO<T>(f.GetTurncation()) -= f);}TE <TY T,TY P> IN TRPO<T> OP-(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0) -= f1);}TE <TY T,TY P> IN TRPO<T> OP*(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0) *= f1);}TE <TY T,TY P> IN TRPO<T> OP/(CO TRPO<T>& f0,CO P& f1){RE MO(TRPO<T>(f0) /= f1);}TE <TY T> IN TRPO<T> OP%(CO TRPO<T>& f0,CO T& t1){RE MO(TRPO<T>(f0) %= t1);}TE <TY T>TRPO<T> Differential(CRUI n,CO TRPO<T>& f){if(f.PO<T>::m_SZ < n){RE TRPO<T>(f.m_N - n,PO<T>::zero());}VE<T> df(f.PO<T>::m_SZ - n);T coef = T::Factorial(n);uint i = n;WH(i < f.PO<T>::m_SZ){df[i - n] = f[i] * coef;i++;(coef *= i) /= (i - n);}RE TRPO<T>(f.m_N - n,MO(df));}TE <TY T>TRPO<T> TRDifferential(CO TRPO<T>& f,CRUI N_output_start_plus_one){assert(f.m_N > 0);TRPO<T> f_dif{f.m_N - 1};if(N_output_start_plus_one < f.PO<T>::m_SZ){CO uint SZ = f.PO<T>::m_SZ - 1;f_dif.PO<T>::m_f = VE<T>(SZ);for(uint i = N_output_start_plus_one;i < f.PO<T>::m_SZ;i++){f_dif.PO<T>::m_f[i-1] = f.PO<T>::m_f[i] * i;}f_dif.PO<T>::m_SZ = SZ;}RE f_dif;}TE <TY T> IN TRPO<T> Differential(CO TRPO<T>& f){RE TRDifferential<T>(f,1);}TE <TY T>TRPO<T> TRIntegral(CO TRPO<T>& f,CRUI N_output_start){TRPO<T> f_int{f.m_N + 1};if(N_output_start <= f.PO<T>::m_SZ){CO uint SZ = f.PO<T>::m_SZ + 1;f_int.PO<T>::m_f = VE<T>(SZ);for(uint i = N_output_start;i <= f.PO<T>::m_SZ;i++){f_int.PO<T>::m_f[i] = f.PO<T>::m_f[i - 1] / T(i);}f_int.PO<T>::m_SZ = SZ;}RE f_int;}TE <TY T> IN TRPO<T> Integral(CO TRPO<T>& f){RE TRIntegral<T>(f,1);}TE <TY T>TRPO<T> Inverse(CO TRPO<T>& f){DF_OF_INVERSE_FOR_TR_PO(T,f_inv.TRMinus(f_inv.TRMU_CO(f,PW,PW_2).TRMU(f_inv,PW,PW_2),PW,PW_2));}TE <TY T>TRPO<T> Exp(CO TRPO<T>& f){DF_OF_EXP_FOR_TR_PO(T,f_exp.TRMinus((TRIntegral(Differential(f_exp).TRMU_CO(Inverse(f_exp),PW - 1,PW_2),PW).TRMinus(f,PW,PW_2)).TRMU(f_exp,PW),PW,PW_2));}TE <TY T> IN TRPO<T> Log(CO TRPO<T>& f){RE Integral<T>(Differential<T>(f) /= f);}TE <TY T> IN TRPO<T> PW(CO TRPO<T>& f,CO T& t){RE Exp(Log(f) *= t);}
DF_OF_PS_OF_MU_OF_PO_PROTH_MOD(P,997269505);

// ファイル容量が厳しい場合は以下を削除する。（プロス素数以外を法とする畳み込み）
DF_OF_PS_OF_MU_OF_PO_PROTH_MOD(167772161,167608321);DF_OF_PS_OF_MU_OF_PO_PROTH_MOD(469762049,469303297);DF_OF_PS_OF_MU_OF_PO_PROTH_MOD(754974721,754237441);
#define DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(TYPE,ARG) TE <>PO<TYPE>& PO<TYPE>::OP*=(ARG f){if(m_SZ != 0){if(f.m_SZ == 0){m_f.clear();m_SZ = 0;} else {CEXPR(uint,P0,167772161);CEXPR(uint,P1,469762049);CEXPR(uint,P2,754974721);US M0 = MN<P0>;US M1 = MN<P1>;US M2 = MN<P2>;VE<M0> v0{};VE<M1> v1{};VE<M2> v2{};v0.reserve(m_SZ);v1.reserve(m_SZ);v2.reserve(m_SZ);for(uint d = 0;d < m_SZ;d++){CRUI f_d = m_f[d].RP();v0.push_back(f_d);v1.push_back(f_d);v2.push_back(f_d);}VE<M0> w0{};VE<M1> w1{};VE<M2> w2{};w0.reserve(f.m_SZ);w1.reserve(f.m_SZ);w2.reserve(f.m_SZ);for(uint d = 0;d < f.m_SZ;d++){CRUI f_d = f.m_f[d].RP();w0.push_back(f_d);w1.push_back(f_d);w2.push_back(f_d);}m_SZ += f.m_SZ - 1;TRPO<M0> TH_copy0{m_SZ,MO(v0)};TRPO<M1> TH_copy1{m_SZ,MO(v1)};TRPO<M2> TH_copy2{m_SZ,MO(v2)};TRPO<M0> f_copy0{f.m_SZ,MO(w0)};TRPO<M1> f_copy1{f.m_SZ,MO(w1)};TRPO<M2> f_copy2{f.m_SZ,MO(w2)};TH_copy0 *= f_copy0;TH_copy1 *= f_copy1;TH_copy2 *= f_copy2;m_f.clear();m_f.reserve(m_SZ);CE TYPE P0_mod_M = TYPE(P0);CE TYPE P01_mod_M = TYPE(P1) *= P0_mod_M;CE M1 P0_mod_P1_inv = M1::DeRP(104391568);CE M2 P0_mod_P2 = M2::DeRP(P0);CE M2 P01_mod_P2_inv = M2::DeRP(190329765);static_assert((M1::DeRP(P0) *= P0_mod_P1_inv)==M1::DeRP(1));static_assert(((M2::DeRP(P1) *= P0_mod_P2) *= P01_mod_P2_inv) == M2::DeRP(1));for(uint d = 0;d < m_SZ;d++){CRUI c0 = TH_copy0[d].RP();CRUI c1 = ((TH_copy1[d] -= c0) *= P0_mod_P1_inv).RP();CRUI c2 = ((TH_copy2[d] -= P0_mod_P2 * c1 + c0) *= P01_mod_P2_inv).RP();m_f.push_back(P01_mod_M * c2 + P0_mod_M * c1 + c0);}ReMORedundantZero();}}RE *TH;}
#define DF_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MOD) DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(Mod<MOD>,CO PO<Mod<MOD> >&);DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(Mod<MOD>,PO<Mod<MOD> >&&);DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MN<MOD>,CO PO<MN<MOD> >&);DF_BODY_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD(MN<MOD>,PO<MN<MOD> >&&);
DF_OF_PS_OF_MU_OF_PO_ARBITRARY_MOD( 1000000007 );
// ここまで。

TE <TY T> IN PO<T>::PO():m_f(),m_SZ(0){}TE <TY T> IN PO<T>::PO(CO T& t):PO(){if(t != CO_zero()){OP[](0) = t;}}TE <TY T> IN PO<T>::PO(T&& t):PO(){if(t != CO_zero()){OP[](0) = MO(t);}}TE <TY T> TE <SFINAE_FOR_PO()> IN PO<T>::PO(CO Arg& n):PO(T(n)){}TE <TY T> IN PO<T>::PO(CO PO<T>& f):m_f(f.m_f),m_SZ(f.m_SZ){}TE <TY T> IN PO<T>::PO(PO<T>&& f):m_f(MO(f.m_f)),m_SZ(MO(f.m_SZ)){}TE <TY T> IN PO<T>::PO(CRUI i,CO T& t):PO(){if(t != CO_zero()){OP[](i) = t;}}TE <TY T> IN PO<T>::PO(CRUI i,T&& t):PO(){if(t != CO_zero()){OP[](i) = MO(t);}}TE <TY T> TE <SFINAE_FOR_PO()> IN PO<T>::PO(CRUI i,CO Arg& n):PO(i,T(n)){}TE <TY T> IN PO<T>::PO(CO VE<T>& f):m_f(f),m_SZ(m_f.SZ()){}TE <TY T> IN PO<T>::PO(VE<T>&& f):m_f(MO(f)),m_SZ(m_f.SZ()){}TE <TY T> IN PO<T>& PO<T>::OP=(CO T& t){m_f.clear();m_SZ = 0;OP[](0) = t;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(T&& t){m_f.clear();m_SZ = 0;OP[](0) = MO(t);RE *TH;}TE <TY T> TE <SFINAE_FOR_PO()> IN PO<T>& PO<T>::OP=(CO Arg& n){RE OP=(T(n));}TE <TY T> IN PO<T>& PO<T>::OP=(CO PO<T>& f){m_f = f.m_f;m_SZ = f.m_SZ;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(PO<T>&& f){m_f = MO(f.m_f);m_SZ = MO(f.m_SZ);RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(CO VE<T>& f){m_f = f;m_SZ = f.m_SZ;RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP=(VE<T>&& f){m_f = MO(f);m_SZ = m_f.SZ();RE *TH;}TE <TY T>CO T& PO<T>::OP[](CRUI i) CO{if(m_SZ <= i){RE CO_zero();}RE m_f[i];}TE <TY T> IN T& PO<T>::OP[](CRUI i){if(m_SZ <= i){CO T& z = CO_zero();WH(m_SZ <= i){m_f.push_back(z);m_SZ++;}}RE m_f[i];}TE <TY T> IN T PO<T>::OP()(CO T& t) CO{RE MO((*TH % (PO<T>(1,CO_one()) - t))[0]);}TE <TY T>PO<T>& PO<T>::OP+=(CO PO<T>& f){for(uint i = 0;i < f.m_SZ;i++){OP[](i) += f.m_f[i];}RE *TH;}TE <TY T>PO<T>& PO<T>::OP-=(CO PO<T>& f){for(uint i = 0;i < f.m_SZ;i++){OP[](i) -= f.m_f[i];}RE *TH;}TE <TY T>PO<T>& PO<T>::OP*=(CO PO<T>& f){if(m_SZ == 0){RE *TH;}if(f.m_SZ == 0){m_f.clear();m_SZ = 0;RE *TH;}CO uint SZ = m_SZ + f.m_SZ - 1;PO<T> product{};for(uint i = 0;i < SZ;i++){T& product_i = product[i];CO uint j_min = m_SZ <= i?i - m_SZ + 1:0;CO uint j_lim = i < f.m_SZ?i + 1:f.m_SZ;for(uint j = j_min;j < j_lim;j++){product_i += m_f[i - j] * f.m_f[j];}}RE OP=(MO(product));}TE <TY T> IN PO<T>& PO<T>::OP*=(PO<T>&& f){RE OP*=(f);};TE <TY T>PO<T>& PO<T>::OP/=(CO T& t){if(t == CO_one()){RE *TH;}CO T t_inv{CO_one() / t};for(uint i = 0;i < m_SZ;i++){OP[](i) *= t_inv;}RE *TH;}TE <TY T> IN PO<T>& PO<T>::OP/=(CO PO<T>& f){RE m_SZ < f.m_SZ?*TH:OP=(Quotient(*TH,f));}TE <TY T>PO<T> PO<T>::Quotient(CO PO<T>& f0,CO PO<T>& f1){if(f0.m_SZ < f1.m_SZ){RE f0;}assert(f1.m_SZ > 0);CO uint f0_transpose_SZ = f0.m_SZ - f1.m_SZ + 1;CO uint f1_transpose_SZ = f0_transpose_SZ < f1.m_SZ?f0_transpose_SZ:f1.m_SZ;RE TransposeQuotient(f0,f0_transpose_SZ,Inverse(TRPO<T>(f0_transpose_SZ,Transpose(f1,f1_transpose_SZ))),f1.m_SZ);}TE <TY T>PO<T> PO<T>::TransposeQuotient(CO PO<T>& f0,CRUI f0_transpose_SZ,CO PO<T>& f1_transpose_inverse,CRUI f1_SZ){TRPO<T> f0_transpose{f0_transpose_SZ,Transpose(f0,f0_transpose_SZ)};f0_transpose *= f1_transpose_inverse;for(uint d0 = (f0_transpose_SZ + 1) / 2;d0 < f0_transpose_SZ;d0++){::swap(f0_transpose.PO<T>::m_f[d0],f0_transpose.PO<T>::m_f[ f0_transpose_SZ - 1 - d0 ]);}RE f0_transpose;}TE <TY T>PO<T> PO<T>::Transpose(CO PO<T>& f,CRUI f_transpose_SZ){VE<T> f_transpose(f_transpose_SZ);for(uint d = 0;d < f_transpose_SZ;d++){f_transpose[d] = f.m_f[f.m_SZ - 1 - d];}RE PO<T>(MO(f_transpose));}TE <TY T>PO<T>& PO<T>::OP%=(CO T& t){if(t == CO_one()){RE OP=(zero());}for(uint i = 0;i < m_SZ;i++){m_f[i] %= t;}RE *TH;}TE <TY T>PO<T>& PO<T>::OP%=(CO PO<T>& f){if(m_SZ >= f.m_SZ){OP-=((*TH / f) * f);ReMORedundantZero();}RE *TH;}TE <TY T> IN PO<T> PO<T>::OP-() CO{RE MO(PO<T>() -= *TH);}TE <TY T >PO<T>& PO<T>::OP<<=(CO T& t){if(m_SZ > 0){for(uint d = 0;d < m_SZ;d++){m_f[d] *= T::Factorial(d);}TRPO<T> exp_t_transpose{m_SZ * 2};T PW_t = CO_one();for(uint d = 0;d < m_SZ;d++){exp_t_transpose[m_SZ - 1 - d] = PW_t * T::FactorialInverse(d);PW_t *= t;}exp_t_transpose *= *TH;for(uint d = 0;d < m_SZ;d++){m_f[d] = exp_t_transpose.PO<T>::m_f[d + m_SZ - 1] * T::FactorialInverse(d);}}RE *TH;}TE <TY T> IN CO VE<T>& PO<T>::GetCoefficient() CO NE{RE m_f;}TE <TY T> IN CRUI PO<T>::SZ() CO NE{RE m_SZ;}TE <TY T> IN VO PO<T>::swap(PO<T>& f){m_f.swap(f.m_f);swap(m_SZ,f.m_SZ);}TE <TY T> IN VO PO<T>::swap(VE<T>& f){m_f.swap(f);m_SZ = m_f.SZ();}TE <TY T>VO PO<T>::ReMORedundantZero(){CO T& z = CO_zero();WH(m_SZ > 0?m_f[m_SZ - 1] == z:false){m_f.pop_back();m_SZ--;}RE;}TE <TY T>string PO<T>::Display() CO NE{string s = "(";if(m_SZ > 0){s += to_string(m_f[0]);for(uint i = 1;i < m_SZ;i++){s += "," + to_string(m_f[i]);}}s += ")";RE s;}TE <TY T> IN CO PO<T>& PO<T>::zero(){ST CO PO<T> z{};RE z;}TE <TY T> IN CO T& PO<T>::CO_zero(){ST CO T z{0};RE z;}TE <TY T> IN CO T& PO<T>::CO_one(){ST CO T o{1};RE o;}TE <TY T> IN CO T& PO<T>::CO_minus_one(){ST CO T m{-1};RE m;}TE <TY T>bool OP==(CO PO<T>& f0,CO T& t1){CRUI SZ = f0.SZ();CO T& zero = PO<T>::CO_zero();for(uint i = 1;i < SZ;i++){if(f0[i] != zero){RE false;}}RE f0[0] == t1;}TE <TY T>bool OP==(CO PO<T>& f0,CO PO<T>& f1){CRUI SZ0 = f0.SZ();CRUI SZ1 = f1.SZ();CRUI SZ = SZ0 < SZ1?SZ1:SZ0;for(uint i = 0;i < SZ;i++){if(f0[i] != f1[i]){RE false;}}RE true;}TE <TY T,TY P> IN bool OP!=(CO PO<T>& f0,CO P& f1){RE !(f0 == f1);}TE <TY T,TY P> IN PO<T> OP+(CO PO<T>& f0,CO P& f1){RE MO(PO<T>(f0) += f1);}TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f){RE PO<T>::zero() - f;}TE <TY T,TY P> IN PO<T> OP-(CO PO<T>& f0,CO P& f1){RE MO(PO<T>(f0) -= f1);}TE <TY T,TY P> IN PO<T> OP*(CO PO<T>& f0,CO P& f1){RE MO(PO<T>(f0) *= f1);}TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO T& t1){RE MO(PO<T>(f0) /= t1);}TE <TY T> IN PO<T> OP/(CO PO<T>& f0,CO PO<T>& f1){RE PO<T>::Quotient(f0,f1);}TE <TY T,TY P> IN PO<T> OP%(CO PO<T>& f0,CO P& f1){RE MO(PO<T>(f0) %= f1);}TE <TY T> PO<T> OP<<(CO PO<T>& f,CO T& t){RE MO(PO<T>(f) <<= t);};TE <TY T,TE <TY...> TY V>T& Prod(V<T>& f){if(f.empty()){f.push_back(T(1));}if(f.SZ() == 1){RE f.front();}auto IT = f.BE(),EN = f.EN();WH(IT != EN){T& t = *IT;IT++;if(IT != EN){t *= *IT;IT = f.erase(IT);}}RE Prod(f);}
