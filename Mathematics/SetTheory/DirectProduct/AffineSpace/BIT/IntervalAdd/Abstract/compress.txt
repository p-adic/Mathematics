// ../../../../../../Algebra/compress.txtÇêÊÇ…ì\ÇÈÅB

TE <TY R,TY U>CL VirtualModule:VI PU VirtualGroup<U>{PU:VI IN U Act(CO R& r,CO U& u)= 0;};TE <TY R,TY U,TY O_U,TY M_U,TY I_U>CL AbstractModule:VI PU VirtualModule<R,U>,PU AbstractGroup<U,M_U,I_U>{PU:O_U& m_o_U;IN AbstractModule(CO R& dummy,O_U& o_U,M_U& m_U,CO U& e_U,I_U& i_U);IN U Act(CO R& r,CO U& u);};TE <TY R,TY U>CL Module:VI PU VirtualModule<R,U>,PU AdditiveGroup<U>{PU:IN U Act(CO R& r,CO U& u);};
TE <TY R,TY U,TY O_U,TY M_U,TY I_U> IN AbstractModule<R,U,O_U,M_U,I_U>::AbstractModule(CO R& dummy,O_U& o_U,M_U& m_U,CO U& e_U,I_U& i_U):AbstractGroup<U,M_U,I_U>(m_U,e_U,i_U),m_o_U(o_U){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY M_U,TY I_U> IN U AbstractModule<R,U,O_U,M_U,I_U>::Act(CO R& r,CO U& u){RE m_o_U.Act(r,u);}TE <TY R,TY U> IN U Module<R,U>::Act(CO R& r,CO U& u){RE r * u;}

TE <TY U,TY ABELIAN_GROUP>CL AbstractBIT{PU:int m_SZ;ABELIAN_GROUP m_M;VE<U> m_fenwick;int m_PW;IN AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a = VE<U>());IN VO Set(CRI i,CO U& u);IN VO Set(CO VE<U>& a);IN AbstractBIT<U,ABELIAN_GROUP>& OP+=(CO VE<U>& a);VO Add(CRI i,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i)CO;IN U Get(CRI i)CO;IN CO U& LSBSegmentSum(CRI j)CO;U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);int BinarySearch(CO U& u);IN int BinarySearch(CRI i_start,CO U& u);};TE <TY ABELIAN_GROUP> AbstractBIT(ABELIAN_GROUP M)-> AbstractBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a):m_SZ(a.SZ()),m_M(MO(M)),m_fenwick(m_SZ + 1),m_PW(1){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);for(int j = 1;j <= m_SZ;j++){U& fenwick_j = m_fenwick[j];int i = j - 1;fenwick_j = a[i];int i_lim = j -(j & -j);WH(i > i_lim){fenwick_j = m_M.Sum(fenwick_j,m_fenwick[i]);i -=(i & -i);}}WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CO VE<U>& a){*TH = AbstractBIT<U,ABELIAN_GROUP>(MO(m_M),a);}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>& AbstractBIT<U,ABELIAN_GROUP>::OP+=(CO VE<U>& a){AbstractBIT<U,ABELIAN_GROUP> a_copy{m_M,a};AS(m_SZ == a_copy.m_SZ);for(int j = 1;j <= m_SZ;j++){m_fenwick[j]= m_M.Sum(m_fenwick[j],a.m_fenwick[j]);}RE *TH;}TE <TY U,TY ABELIAN_GROUP>VO AbstractBIT<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){int j = i + 1;WH(j <= m_SZ){U& m_fenwick_j = m_fenwick[j];m_fenwick_j = m_M.Sum(m_fenwick_j,u);j +=(j & -j);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractBIT<U,ABELIAN_GROUP>::SZ()CO NE{RE m_SZ;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::OP[](CRI i)CO{AS(i < m_SZ);RE IntervalSum(i,i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractBIT<U,ABELIAN_GROUP>::LSBSegmentSum(CRI j)CO{AS(0 < j && j <= m_SZ);RE m_fenwick[j];}TE <TY U,TY ABELIAN_GROUP>U AbstractBIT<U,ABELIAN_GROUP>::InitialSegmentSum(CRI i_final){U sum = m_M.Zero();int j = min(i_final + 1,m_SZ);WH(j > 0){sum = m_M.Sum(sum,m_fenwick[j]);j -= j & -j;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}TE <TY U,TY ABELIAN_GROUP>int AbstractBIT<U,ABELIAN_GROUP>::BinarySearch(CO U& u){int j = 0;int PW = m_PW;U sum = m_M.Zero();U sum_next = sum;WH(PW > 0){int j_next = j | PW;if(j_next < m_SZ){sum_next = m_M.Sum(sum_next,m_fenwick[j_next]);if(sum_next < u){sum = sum_next;j = j_next;}else{sum_next = sum;}}PW >>= 1;}RE j;}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::BinarySearch(CRI i_start,CO U& u){RE max(i_start,m_M.Sum(BinarySearch(InitialSegmentSum(i_start - 1),u)));}

TE <TY U,TY Z_MODULE>CL AbstractIntervalAddBIT{PU:int m_SZ;Z_MODULE m_M;AbstractBIT<U,Z_MODULE> m_bit_0;AbstractBIT<U,Z_MODULE> m_bit_1;AbstractIntervalAddBIT(Z_MODULE M,CO VE<U>& a = VE<U>());IN VO Set(CRI i,CO U& u);IN VO Set(CO VE<U>& a);IN AbstractIntervalAddBIT<U,Z_MODULE>& OP+=(CO VE<U>& a);IN VO Add(CRI i,CO U& u);IN VO IntervalAdd(CRI i_start,CRI i_final,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i);IN U Get(CRI i);IN U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);};TE <TY Z_MODULE> AbstractIntervalAddBIT(Z_MODULE M)-> AbstractIntervalAddBIT<inner_t<Z_MODULE>,Z_MODULE>;
TE <TY U,TY Z_MODULE> AbstractIntervalAddBIT<U,Z_MODULE>::AbstractIntervalAddBIT(Z_MODULE M,CO VE<U>& a):m_M(MO(M)),m_bit_0(m_M),m_bit_1(m_M){CO int SZ = a.SZ();VE<U> diff(SZ,m_M.Zero());diff[0]= a[0];for(int i = 1;i < SZ;i++){diff[i]= m_M.Sum(a[i],m_M.Inverse(a[i-1]));}m_bit_0.Set(diff);for(int i = 1;i < SZ;i++){U& diff_i = diff[i];diff_i = m_M.Inverse(m_M.Sum(m_M.Act(i - i,diff_i),a[i]));}m_bit_1.Set(diff);}TE <TY U,TY Z_MODULE> IN VO AbstractIntervalAddBIT<U,Z_MODULE>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY Z_MODULE> IN VO AbstractIntervalAddBIT<U,Z_MODULE>::Set(CO VE<U>& a){*TH = AbstractIntervalAddBIT<U,Z_MODULE>(MO(m_M),a);}TE <TY U,TY Z_MODULE> IN AbstractIntervalAddBIT<U,Z_MODULE>& AbstractIntervalAddBIT<U,Z_MODULE>::OP+=(CO VE<U>& a){AbstractIntervalAddBIT<U,Z_MODULE> a_copy{m_M,a};m_bit_0 += a_copy.m_bit_0;m_bit_1 += a_copy.m_bit_1;RE *TH;}TE <TY U,TY Z_MODULE> IN VO AbstractIntervalAddBIT<U,Z_MODULE>::Add(CRI i,CO U& u){AS(0 <= i && i < SZ());IntervalAdd(i,i,u);}TE <TY U,TY Z_MODULE> IN VO AbstractIntervalAddBIT<U,Z_MODULE>::IntervalAdd(CRI i_start,CRI i_final,CO U& u){m_bit_0.Add(i_start,m_M.Act((i_start - 1),m_M.Inverse(u)));m_bit_0.Add(i_final + 1,m_M.Act(i_final,u));m_bit_1.Add(i_start,u);m_bit_1.Add(i_final + 1,m_M.Inverse(u));}TE <TY U,TY Z_MODULE> IN CRI AbstractIntervalAddBIT<U,Z_MODULE>::SZ()CO NE{RE m_bit_0.SZ();}TE <TY U,TY Z_MODULE> IN U AbstractIntervalAddBIT<U,Z_MODULE>::OP[](CRI i){AS(0 <= i && i < SZ());RE IntervalSum(i,i);}TE <TY U,TY Z_MODULE> IN U AbstractIntervalAddBIT<U,Z_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY Z_MODULE> IN U AbstractIntervalAddBIT<U,Z_MODULE>::InitialSegmentSum(CRI i_final){RE m_M.Sum(m_bit_0.InitialSegmentSum(i_final),m_M.Act(i_final,m_bit_1.InitialSegmentSum(i_final)));}TE <TY U,TY Z_MODULE> IN U AbstractIntervalAddBIT<U,Z_MODULE>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}
