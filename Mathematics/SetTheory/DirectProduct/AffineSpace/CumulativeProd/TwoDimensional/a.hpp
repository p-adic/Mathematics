// c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/Tree/CumulativeProd/TwoDimensional/a.hpp

#pragma once

// ２次元配列上の累積和。
// 入力の範囲内で要件
// (1) (T,m_T:T^2->T,e_T:1->T,i_T:T->T)が可換群である。
// が成り立つ場合のみサポート。

// 配列による初期化O(size_X*size_Y)

// 始矩形和O(1)
// 矩形和O(1)
template <typename T , T m_T(const T&,const T&) , const T& e_T() , T i_T(const T&)>
class TwoDimensionalCumulativeSum
{

private:
  int m_size_X;
  int m_size_Y;
  vector<vector<T> > m_a;
  
public:
  TwoDimensionalCumulativeSum( const vector<vector<T> >& a );
  template <int size_X_max , int size_Y_max> TwoDimensionalCumulativeSum( const T ( &a )[size_X_max][size_Y_max] , const int& size_X , const int& size_Y );

  // 条件
  // (1) -1 <= i_final_x < m_size_X
  // (2) -1 <= i_final_y < m_size_Y
  // を満たす場合のみサポート。
  // a[0][i_start_y]...a[i_final_x][i_start_y]...
  // a[0][i_final_y]...a[i_final_x][i_final_y]
  // をm_Tに関して計算する。
  inline const T& InitialRectangleSum( const int& i_x , const int& i_y ) const;

  // 条件
  // (1) 0 <= i_start_xかつi_start_x-1 <= i_final_x < m_size_X
  // (2) 0 <= i_start_yかつi_start_y-1 <= i_final_y < m_size_Y
  // を満たす場合のみサポート。
  // a[i_start_x][i_start_y]...a[i_final_x][i_start_y]...
  // a[i_start_x][i_final_y]...a[i_final_x][i_final_y]
  // をm_Tに関して計算する。
  inline T RectangleSum( const int& i_start_x , const int& i_start_y , const int& i_final_x , const int& i_final_y ) const;

};
