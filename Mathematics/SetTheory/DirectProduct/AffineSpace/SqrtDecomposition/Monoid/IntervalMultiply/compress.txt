// ../../../../../../Algebra/compress.txtÇêÊÇ…ì\ÇÈÅB

TE <TY R,TY U>CL VirtualModule{PU:VI U Action(CO R& r,CO U& u)= 0;IN U PW(CO U& u,CO R& r);IN U ScalarProduct(CO R& r,CO U& u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:VI PU VirtualModule<R,U>,PU GROUP{PU:O_U m_o_U;IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);IN U Action(CO R& r,CO U& u);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualModule<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,CO U& u);};
TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):GROUP(MO(M)),m_o_U(MO(o_U)){ST_AS(is_same_v<U,inner_t<GROUP>> && is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN U AbstractModule<R,U,O_U,GROUP>::Action(CO R& r,CO U& u){RE m_o_U(r,u);}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,CO U& u){RE r * u;}TE <TY R,TY U> IN U VirtualModule<R,U>::PW(CO U& u,CO R& r){RE Action(r,u);}TE <TY R,TY U> IN U VirtualModule<R,U>::ScalarProduct(CO R& r,CO U& u){RE Action(r,u);}

IN CE int Sqrt(CRI N)NE{if(N <= 1){RE 1;}int left = 0;int right = N;WH(left + 1 < right){int m =(left + right)/ 2;(m <=(N - 1)/ m?left:right)= m;}RE right;}

TE <TY U,TY COMM_MONOID>CL MonoidSqrtDecomposition{PU:COMM_MONOID m_M;int m_N;int m_N_sqrt;int m_N_d;int m_N_m;VE<U> m_a;VE<U> m_b;IN MonoidSqrtDecomposition(COMM_MONOID M,CRI N);IN MonoidSqrtDecomposition(COMM_MONOID M,CRI N,CRI N_sqrt);IN MonoidSqrtDecomposition(COMM_MONOID M,VE<U> a);IN MonoidSqrtDecomposition(COMM_MONOID M,VE<U> a,CRI N_sqrt);TE <TY...Args> IN VO Reset(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO Multiply(CRI i,CO U& u);IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN U IntervalProduct(CRI i_start,CRI i_final);IN int Search(CRI i_start,CO U& u);int Search_Body(CRI i_start,CO U& u,U sum_temp);};TE <TY COMM_MONOID,TY...Args> MonoidSqrtDecomposition(COMM_MONOID M,Args&&...args)-> MonoidSqrtDecomposition<inner_t<COMM_MONOID>,COMM_MONOID>;
TE <TY U,TY COMM_MONOID> IN MonoidSqrtDecomposition<U,COMM_MONOID>::MonoidSqrtDecomposition(COMM_MONOID M,CRI N):MonoidSqrtDecomposition(MO(M),N,Sqrt(N)){}TE <TY U,TY COMM_MONOID> IN MonoidSqrtDecomposition<U,COMM_MONOID>::MonoidSqrtDecomposition(COMM_MONOID M,CRI N,CRI N_sqrt):m_M(MO(M)),m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt),m_a(m_N_m,m_M.Zero()),m_b(m_N_d,m_M.Zero()){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<COMM_MONOID>>);}TE <TY U,TY COMM_MONOID> IN MonoidSqrtDecomposition<U,COMM_MONOID>::MonoidSqrtDecomposition(COMM_MONOID M,VE<U> a):MonoidSqrtDecomposition(MO(M),MO(a),Sqrt(a.SZ())){}TE <TY U,TY COMM_MONOID> IN MonoidSqrtDecomposition<U,COMM_MONOID>::MonoidSqrtDecomposition(COMM_MONOID M,VE<U> a,CRI N_sqrt):m_M(MO(M)),m_N(a.SZ()),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt),m_a(MO(a)),m_b(m_N_d,m_M.Zero()){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<COMM_MONOID>>);m_a.reSZ(m_N_m,m_M.One());int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(m_bd,m_a[i]);}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY U,TY COMM_MONOID> TE <TY...Args> IN VO MonoidSqrtDecomposition<U,COMM_MONOID>::Reset(Args&&... args){*TH = MonoidSqrtDecomposition<U,COMM_MONOID>(MO(m_M),forward<Args>(args)...);}TE <TY U,TY COMM_MONOID> IN VO MonoidSqrtDecomposition<U,COMM_MONOID>::Set(CRI i,CO U& u){CO int d = i / m_N_sqrt;CO int i_min = m_N_sqrt * d;CO int i_ulim = i_min + m_N_sqrt;m_a[i]= u;U& m_bd = m_b[d]= m_M.Zero();for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(m_bd,m_a[i]);}RE;}TE <TY U,TY COMM_MONOID> IN VO MonoidSqrtDecomposition<U,COMM_MONOID>::Multiply(CRI i,CO U& u){U& m_ai = m_a[i];U& m_bd = m_b[i / m_N_sqrt];m_bd = m_M.Product(m_bd,u);m_ai = m_M.Product(m_ai,u);}TE <TY U,TY COMM_MONOID> IN CO U& MonoidSqrtDecomposition<U,COMM_MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_N);RE m_a[i];}TE <TY U,TY COMM_MONOID> IN CO U& MonoidSqrtDecomposition<U,COMM_MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY COMM_MONOID> IN U MonoidSqrtDecomposition<U,COMM_MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();for(int i = i_min;i < i_0;i++){AN = m_M.Product(AN,m_a[i]);}for(int d = d_0;d < d_1;d++){AN = m_M.Product(AN,m_b[d]);}for(int i = i_1;i < i_ulim;i++){AN = m_M.Product(AN,m_a[i]);}RE AN;}TE <TY U,TY COMM_MONOID> IN int MonoidSqrtDecomposition<U,COMM_MONOID>::Search(CRI i_start,CO U& u){RE Search(i_start,u,m_M.Zero());}TE <TY U,TY COMM_MONOID> int MonoidSqrtDecomposition<U,COMM_MONOID>::Search_Body(CRI i_start,CO U& u,U sum_temp){CO int i_min = max(i_start,0);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int i_0 = min(d_0 * m_N_sqrt,m_N);for(int i = i_min;i < i_0;i++){sum_temp = m_M.Product(sum_temp,m_a[i]);if(!(sum_temp < u)){RE i;}}for(int d = d_0;d < m_N_d;d++){U sum_next = m_M.Product(sum_temp,m_b[d]);if(sum_next < u){sum_temp = MO(sum_next);}else{RE Search_Body(d * m_N_sqrt,u,sum_temp);}}RE -1;}

TE <TY U,TY N_MODULE>CL IntervalMultiplySqrtDecomposition:PU MonoidSqrtDecomposition<U,N_MODULE>{PU:VE<U> m_lazy_MU;TE <TY...Args> IN IntervalMultiplySqrtDecomposition(N_MODULE M,Args&&... args);TE <TY...Args> IN VO Reset(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalProduct(CRI i_start,CRI i_final);IN int Search(CRI i_start,CO U& u)= delete;};TE <TY N_MODULE,TY...Args> IntervalMultiplySqrtDecomposition(N_MODULE M,Args&&... args)-> IntervalMultiplySqrtDecomposition<inner_t<N_MODULE>,N_MODULE>;
TE <TY U,TY N_MODULE> TE <TY...Args> IN IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalMultiplySqrtDecomposition(N_MODULE M,Args&&... args):MonoidSqrtDecomposition<U,N_MODULE>(MO(M),forward<Args>(args)...),m_lazy_MU(TH->m_N_d,TH->m_M.One()){}TE <TY U,TY N_MODULE> TE <TY...Args> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::Reset(Args&&... args){*TH = IntervalMultiplySqrtDecomposition<U,N_MODULE>(MO(TH->m_M),forward<Args>(args)...);}TE <TY U,TY N_MODULE> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::Set(CRI i,CO U& u){CO int d = i / TH->m_N_sqrt;CO int j_min = TH->m_N_sqrt * d;CO int j_ulim = j_min + TH->m_N_sqrt;CO U& one = TH->m_M.One();U& m_lazy_MU_d = m_lazy_MU[d];if(m_lazy_MU_d != one){for(int j = j_min;j < j_ulim;j++){U& m_aj = TH->m_a[j];m_aj = TH->m_M.Product(m_lazy_MU_d,m_aj);}m_lazy_MU_d = one;}TH->m_a[i]= u;U& m_bd = TH->m_b[d]= one;for(int j = j_min;j < j_ulim;j++){m_bd = TH->m_M.Product(m_bd,TH->m_a[j]);}RE;}TE <TY U,TY N_MODULE> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){if(u != TH->m_M.One()){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,TH->m_N);CO int d_0 =(i_min + TH->m_N_sqrt - 1)/ TH->m_N_sqrt;CO int d_1 = max(d_0,i_ulim / TH->m_N_sqrt);CO int i_0 = min(d_0 * TH->m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * TH->m_N_sqrt);for(int i = i_min;i < i_0;i++){TH->Multiply(i,u);}for(int d = d_0;d < d_1;d++){U& m_lazy_MU_d = m_lazy_MU[d];m_lazy_MU_d = TH->m_M.Product(m_lazy_MU_d,u);}for(int i = i_1;i < i_ulim;i++){TH->Multiply(i,u);}}RE;}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::OP[](CRI i){AS(0 <= i && i < TH->m_N);RE TH->m_M.Product(MonoidSqrtDecomposition<U,N_MODULE>::OP[](i),m_lazy_MU[i / TH->m_N_sqrt]);}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,TH->m_N);CO int d_0 =(i_min + TH->m_N_sqrt - 1)/ TH->m_N_sqrt;CO int d_1 = max(d_0,i_ulim / TH->m_N_sqrt);CO int i_0 = min(d_0 * TH->m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * TH->m_N_sqrt);U AN = TH->m_M.One();for(int d = d_0;d < d_1;d++){AN = TH->m_M.Product(AN,m_lazy_MU[d]);}AN = TH->m_M.PW(AN,d_1 - d_0);if(d_0 > 0){AN = TH->m_M.Product(AN,TH->m_M.PW(m_lazy_MU[d_0 - 1],i_0 - i_min));}if(d_1 < TH->m_N_d){AN = TH->m_M.Product(AN,TH->m_M.PW(m_lazy_MU[d_1],i_ulim - i_1));}AN = TH->m_M.Product(AN,MonoidSqrtDecomposition<U,N_MODULE>::IntervalProduct(i_start,i_final));RE AN;}

