#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Monoid/Commutative/IntervalMultiply/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

#define SFINAE_FOR_SD_S enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY N_MODULE>CL IntervalMultiplySqrtDecomposition:PU SqrtDecompositionCoordinate{PU:N_MODULE m_M;VE<U> m_a;VE<U> m_b;VE<U> m_lazy_MU;TE <TY...Args> IN IntervalMultiplySqrtDecomposition(N_MODULE M,CRI N = 0,CO Args&... args);TE <TY...Args> IN IntervalMultiplySqrtDecomposition(N_MODULE M,VE<U> a,CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO Multiply(CRI i,CO U& u);IN VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalProduct(CRI i_start,CRI i_final);IN U IntervalProduct_Body(CRI i_start,CRI i_final);};TE <TY N_MODULE,TY...Args> IntervalMultiplySqrtDecomposition(N_MODULE M,Args&&... args)-> IntervalMultiplySqrtDecomposition<inner_t<N_MODULE>,N_MODULE>;
TE <TY U,TY N_MODULE> TE <TY...Args> IN IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalMultiplySqrtDecomposition(N_MODULE M,CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_M(MO(M)),m_a(m_N_m,m_M.Zero()),m_b(m_N_d,m_M.Zero()),m_lazy_MU(m_N_d,m_M.One()){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<N_MODULE>>);}TE <TY U,TY N_MODULE> TE <TY...Args> IN IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalMultiplySqrtDecomposition(N_MODULE M,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.Zero()),m_lazy_MU(m_N_d,m_M.One()){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<N_MODULE>>);m_a.resize(m_N_m,m_M.One());int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(MO(m_bd),m_a[i]);}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY U,TY N_MODULE> TE <TY...Args> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::Initialise(Args&&... args){IntervalMultiplySqrtDecomposition<U,N_MODULE> temp{m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);m_lazy_MU = VE(m_N_d,m_M.One());}TE <TY U,TY N_MODULE> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::Set(CRI i,CO U& u){CO int d = i / m_N_sqrt;CO int j_min = m_N_sqrt * d;CO int j_ulim = j_min + m_N_sqrt;CO U& one = m_M.One();U& m_lazy_MU_d = m_lazy_MU[d];if(m_lazy_MU_d != one){for(int j = j_min;j < j_ulim;j++){U& m_aj = m_a[j];m_aj = m_M.Product(MO(m_aj),m_lazy_MU_d);}m_lazy_MU_d = one;}m_a[i]= u;U& m_bd = m_b[d]= one;for(int j = j_min;j < j_ulim;j++){m_bd = m_M.Product(MO(m_bd),m_a[j]);}RE;}TE <TY U,TY N_MODULE> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::Multiply(CRI i,CO U& u){U& m_ai = m_a[i];U& m_bd = m_b[i / m_N_sqrt];m_bd = m_M.Product(MO(m_bd),u);m_ai = m_M.Product(MO(m_ai),u);}TE <TY U,TY N_MODULE> IN VO IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){if(u != m_M.One()){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);for(int i = i_min;i < i_0;i++){Multiply(i,u);}for(int d = d_0;d < d_1;d++){U& m_lazy_MU_d = m_lazy_MU[d];m_lazy_MU_d = m_M.Product(MO(m_lazy_MU_d),u);}for(int i = i_1;i < i_ulim;i++){Multiply(i,u);}}RE;}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_M.Product(m_a[i],m_lazy_MU[i / m_N_sqrt]);}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();for(int d = d_0;d < d_1;d++){AN = m_M.Product(MO(AN),m_lazy_MU[d]);}AN = m_M.PW(AN,d_1 - d_0);if(d_0 > 0){AN = m_M.Product(MO(AN),m_M.PW(m_lazy_MU[d_0 - 1],i_0 - i_min));}if(d_1 < m_N_d){AN = m_M.Product(MO(AN),m_M.PW(m_lazy_MU[d_1],i_ulim - i_1));}AN = m_M.Product(MO(AN),IntervalProduct_Body(i_start,i_final));RE AN;}TE <TY U,TY N_MODULE> IN U IntervalMultiplySqrtDecomposition<U,N_MODULE>::IntervalProduct_Body(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();for(int i = i_min;i < i_0;i++){AN = m_M.Product(MO(AN),m_a[i]);}for(int d = d_0;d < d_1;d++){AN = m_M.Product(MO(AN),m_b[d]);}for(int i = i_1;i < i_ulim;i++){AN = m_M.Product(MO(AN),m_a[i]);}RE AN;}
#endif

