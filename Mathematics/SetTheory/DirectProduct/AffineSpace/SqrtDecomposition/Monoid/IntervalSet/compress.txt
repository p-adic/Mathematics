#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Monoid/IntervalSet/a_Body.hpp"
#else
CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

#define SFINAE_FOR_SD_S enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY NON_COMM_N_MODULE>CL IntervalSetSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:NON_COMM_N_MODULE m_M;VE<U> m_a;VE<U> m_b;VE<U> m_lazy_substitution;VE<bool> m_suspENed;TE <TY...Args> IN IntervalSetSqrtDecomposition(NON_COMM_N_MODULE M,CRI N = 0,CO Args&... args);TE <TY...Args> IN IntervalSetSqrtDecomposition(NON_COMM_N_MODULE M,VE<U> a,CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO IntervalSet(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_SD_S = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CRI i_start,CO U& u);IN VO IntervalSet_Body(CRI i_min,CRI i_ulim,CO U& u);IN U IntervalProduct_Body(CRI i_min,CRI i_ulim);TE <TY F> int Search_Body(CRI i_start,CO F& f,U sum_temp);};TE <TY NON_COMM_N_MODULE,TY...Args> IntervalSetSqrtDecomposition(NON_COMM_N_MODULE M,Args&&... args)-> IntervalSetSqrtDecomposition<inner_t<NON_COMM_N_MODULE>,NON_COMM_N_MODULE>;
TE <TY U,TY NON_COMM_N_MODULE> TE <TY...Args> IN IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalSetSqrtDecomposition(NON_COMM_N_MODULE M,CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_M(MO(M)),m_a(m_N_m,m_M.One()),m_b(m_N_d,m_M.One()),m_lazy_substitution(m_N_d,m_M.One()),m_suspENed(m_N_d){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<NON_COMM_N_MODULE>>);}TE <TY U,TY NON_COMM_N_MODULE> IN IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalSetSqrtDecomposition(NON_COMM_N_MODULE M,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.One()),m_lazy_substitution(m_N_d,m_M.One()),m_suspENed(m_N_d){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<NON_COMM_N_MODULE>>);m_a.resize(m_N_m,m_M.One());int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(MO(m_bd),m_a[i]);}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY U,TY NON_COMM_N_MODULE> TE <TY...Args> IN VO IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Initialise(Args&&... args){IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE> temp{m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);m_lazy_substitution = VE(m_N_d,m_M.One());m_suspENed = VE(m_N_d,false);}TE <TY U,TY NON_COMM_N_MODULE> IN VO IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Set(CRI i,CO U& u){IntervalSet(i,i,u);}TE <TY U,TY NON_COMM_N_MODULE> IN VO IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalSet(CRI i_start,CRI i_final,CO U& u){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int d_0_N_sqrt = d_0 * m_N_sqrt;CO int d_1_N_sqrt = d_1 * m_N_sqrt;CO int i_0 = min(d_0_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1_N_sqrt);if(i_min < i_0){CO int d_0_minus = d_0 - 1;CO int d_0_N_sqrt_minus = d_0_N_sqrt - m_N_sqrt;U& m_bd = m_b[d_0_minus];VE<bool>::reference m_suspENed_d = m_suspENed[d_0_minus];if(m_suspENed_d){U& m_lazy_substitution_d = m_lazy_substitution[d_0_minus];IntervalSet_Body(d_0_N_sqrt_minus,i_min,m_lazy_substitution_d);IntervalSet_Body(i_min,i_0,u);IntervalSet_Body(i_0,d_0_N_sqrt,m_lazy_substitution_d);m_suspENed_d = false;m_bd = m_M.Product(m_M.PW(m_lazy_substitution_d,m_N_sqrt -(i_0 - i_min)),m_M.PW(u,i_0 - i_min));}else{IntervalSet_Body(i_min,i_0,u);m_bd = m_M.Product(m_M.Product(IntervalProduct_Body(d_0_N_sqrt_minus,i_min),m_M.PW(u,i_0 - i_min)),IntervalProduct_Body(i_0,d_0_N_sqrt));}}CO U PW = m_M.PW(u,m_N_sqrt);for(int d = d_0;d < d_1;d++){m_b[d]= PW;m_lazy_substitution[d]= u;m_suspENed[d]= true;}if(i_1 < i_ulim){CO int d_1_N_sqrt_plus = d_1_N_sqrt + m_N_sqrt;U& m_bd = m_b[d_1];VE<bool>::reference m_suspENed_d = m_suspENed[d_1];if(m_suspENed_d){U& m_lazy_substitution_d = m_lazy_substitution[d_1];IntervalSet_Body(d_1_N_sqrt,i_1,m_lazy_substitution_d);IntervalSet_Body(i_1,i_ulim,u);IntervalSet_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_substitution_d);m_suspENed_d = false;m_bd = m_M.Product(m_M.Product(m_M.PW(m_lazy_substitution_d,i_1 - d_1_N_sqrt),m_M.PW(u,i_ulim - i_1)),m_M.PW(m_lazy_substitution_d,d_1_N_sqrt_plus - i_ulim));}else{IntervalSet_Body(i_1,i_ulim,u);m_bd = m_M.Product(m_M.Product(IntervalProduct_Body(d_1_N_sqrt,i_1),m_M.PW(u,i_ulim - i_1)),IntervalProduct_Body(i_ulim,d_1_N_sqrt_plus));}}RE;}TE <TY U,TY NON_COMM_N_MODULE> IN VO IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalSet_Body(CRI i_min,CRI i_ulim,CO U& u){for(int i = i_min;i < i_ulim;i++){m_a[i]= u;}RE;}TE <TY U,TY NON_COMM_N_MODULE> IN U IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::OP[](CRI i){AS(0 <= i && i < m_N);CO int d = i / m_N_sqrt;RE m_suspENed[d]?m_lazy_substitution[d]:m_a[i];}TE <TY U,TY NON_COMM_N_MODULE> IN U IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY NON_COMM_N_MODULE> IN U IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();if(i_min < i_0){CO int d_0_minus = d_0 - 1;AN = m_suspENed[d_0_minus]?m_M.PW(m_lazy_substitution[d_0_minus],i_0 - i_min):IntervalProduct_Body(i_min,i_0);}for(int d = d_0;d < d_1;d++){AN = m_M.Product(MO(AN),m_b[d]);}if(i_1 < i_ulim){AN = m_M.Product(MO(AN),m_suspENed[d_1]?m_M.PW(m_lazy_substitution[d_1],i_ulim - i_1):IntervalProduct_Body(i_1,i_ulim));}RE AN;}TE <TY U,TY NON_COMM_N_MODULE> IN U IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::IntervalProduct_Body(CRI i_min,CRI i_ulim){U AN = m_M.One();for(int i = i_min;i < i_ulim;i++){AN = m_M.Product(MO(AN),m_a[i]);}RE AN;}TE <TY U,TY NON_COMM_N_MODULE> TE <TY F,SFINAE_FOR_SD_S> IN int IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Search(CRI i_start,CO F& f){RE Search_Body(i_start,f,m_M.One());}TE <TY U,TY NON_COMM_N_MODULE> IN int IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Search(CRI i_start,CO U& u){RE Search(i_start,[&](CO U& product,CRI){RE !(product < u);});}TE <TY U,TY NON_COMM_N_MODULE> TE <TY F> int IntervalSetSqrtDecomposition<U,NON_COMM_N_MODULE>::Search_Body(CRI i_start,CO F& f,U product_temp){CO int i_min = max(i_start,0);CO int d_0 = i_min / m_N_sqrt + 1;CO int i_0 = min(d_0 * m_N_sqrt,m_N);if(i_min < i_0){CO int d_0_minus = d_0 - 1;if(m_suspENed[d_0_minus]){CO U& m_lazy_substitution_d = m_lazy_substitution[d_0_minus];U product_next = m_M.Product(product_temp,m_lazy_substitution_d);if(f(product_next,i_min)){RE i_min;}int l = i_min,r = i_0;WH(l + 1 < r){int m =(l + r)>> 1;product_next = m_M.Product(product_temp,m_M.PW(m_lazy_substitution_d,m - i_min + 1));(f(product_next,m)?r:l)= m;}if(r < i_0){RE r;}product_temp = MO(product_next);}else{for(int i = i_min;i < i_0;i++){product_temp = m_M.Product(MO(product_temp),m_a[i]);if(f(product_temp,i)){RE i;}}}}int N_sqrt_d = m_N_sqrt * d_0;for(int d = d_0;d < m_N_d;d++,N_sqrt_d += m_N_sqrt){CO int j_rest = d + 1 < m_N_d?m_N_sqrt:m_N - N_sqrt_d;U product_next = m_M.Product(product_temp,m_suspENed[d]?m_M.PW(m_lazy_substitution[d],j_rest):m_b[d]);if(f(product_next,N_sqrt_d + j_rest - 1)){RE Search_Body(N_sqrt_d,f,product_temp);}product_temp = MO(product_next);}RE -1;}
#endif

