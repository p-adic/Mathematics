#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/LazyEvaluation/IntervalMultiply/a_Body.hpp"
#else
TE <TY L,TY R,TY U>CL VirtualBiModule:VI PU UnderlyingSet<U>{PU:VI U LAction(CO L& l,U u)= 0;VI U RAction(U u,CO R& r)= 0;IN U ScalarProduct(CO L& l,U u);IN U PW(U u,CO R& r);};TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP>CL AbstractBiModule:PU VirtualBiModule<L,R,U>,PU GROUP{PU:O_U_L m_o_U_L;O_U_R m_o_U_R;IN AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M);IN AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>& OP=(CO AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>&)NE;IN U LAction(CO L& l,U u);IN U RAction(U u,CO R& r);};TE <TY L,TY R,TY O_U_L,TY O_U_R,TY GROUP> AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M)-> AbstractBiModule<L,R,inner_t<GROUP>,O_U_L,O_U_R,GROUP>;TE <TY L,TY R,TY U>CL BiModule:VI PU VirtualBiModule<L,R,U>,PU AdditiveGroup<U>{PU:IN U LAction(CO L& r,U u);IN U RAction(U u,CO R& r);};
TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::AbstractBiModule(CO L& dummy_l,CO R& dummy_r,O_U_L o_U_L,O_U_R o_U_R,GROUP M):GROUP(MO(M)),m_o_U_L(MO(o_U_L)),m_o_U_R(MO(o_U_R)){ST_AS(is_same_v<U,inner_t<GROUP>> && is_invocable_r_v<U,O_U_L,CO L&,U> && is_invocable_r_v<U,O_U_R,U,CO R&>);}TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN U AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::LAction(CO L& l,U u){RE m_o_U_L(l,MO(u));}TE <TY L,TY R,TY U> IN U BiModule<L,R,U>::LAction(CO L& l,U u){RE MO(u *= l);}TE <TY L,TY R,TY U,TY O_U_L,TY O_U_R,TY GROUP> IN U AbstractBiModule<L,R,U,O_U_L,O_U_R,GROUP>::RAction(U u,CO R& r){RE m_o_U_R(MO(u),r);}TE <TY L,TY R,TY U> IN U BiModule<L,R,U>::RAction(U u,CO R& r){RE MO(u *= r);}TE <TY L,TY R,TY U> IN U VirtualBiModule<L,R,U>::ScalarProduct(CO L& l,U u){RE LAction(l,MO(u));}TE <TY L,TY R,TY U> IN U VirtualBiModule<L,R,U>::PW(U u,CO R& r){RE RAction(MO(u),r);}

CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

#define SFINAE_FOR_SD_S enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE>CL IntervalMultiplyLazySqrtDecomposition:PU SqrtDecompositionCoordinate{PU:PT_MAGMA m_L;RN_BIMODULE m_M;VE<U> m_a;VE<U> m_b;VE<U> m_lazy_substitution;VE<bool> m_suspended;VE<R> m_lazy_action;VE<U> m_lazy_MU;TE <TY...Args> IN IntervalMultiplyLazySqrtDecomposition(PT_MAGMA L,RN_BIMODULE M,CRI N = 0,CO Args&... args);TE <TY...Args> IN IntervalMultiplyLazySqrtDecomposition(PT_MAGMA L,RN_BIMODULE M,VE<U> a,CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO IntervalSet(CRI i_start,CRI i_final,CO U& u);IN VO IntervalAct(CRI i_start,CRI i_final,CO R& r);IN VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_SD_S = nullptr> IN int Search(CRI i_start,CO F& f,CO bool& reversed = false);IN int Search(CRI i_start,CO U& u,CO bool& reversed = false);IN VO COruct();IN VO SetProduct(CRI i);IN VO SolveSuspendedSubstitution(CRI d,CO U& u);IN VO IntervalSet_Body(CRI i_min,CRI i_ulim,CO U& u);IN VO SolveSuspendedAction(CRI d);IN VO IntervalAct_Body(CRI i_min,CRI i_ulim,CO R& r);IN VO IntervalMultiply_Body(CRI i_min,CRI i_ulim,CO U& u);IN U IntervalProduct_Body(CRI i_min,CRI i_ulim);TE <TY F> int Search_Body(CRI i_start,CO F& f,U product_temp);TE <TY F> int SearchReverse_Body(CRI i_final,CO F& f,U sum_temp);};TE <TY PT_MAGMA,TY RN_BIMODULE,TY...Args> IntervalMultiplyLazySqrtDecomposition(PT_MAGMA L,RN_BIMODULE M,CO Args&... args)-> IntervalMultiplyLazySqrtDecomposition<inner_t<PT_MAGMA>,PT_MAGMA,inner_t<RN_BIMODULE>,RN_BIMODULE>;
TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY...Args> IN IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalMultiplyLazySqrtDecomposition(PT_MAGMA L,RN_BIMODULE M,CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_L(MO(L)),m_M(MO(M)),m_a(N,m_M.One()),m_b(m_N_d,m_M.One()),m_lazy_substitution(m_b),m_suspended(m_N_d),m_lazy_action(m_N_d,m_L.Point()),m_lazy_MU(m_b){COruct();}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY...Args> IN IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalMultiplyLazySqrtDecomposition(PT_MAGMA L,RN_BIMODULE M,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_L(MO(L)),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.One()),m_lazy_substitution(m_b),m_suspended(m_N_d),m_lazy_action(m_N_d,m_L.Point()),m_lazy_MU(m_b){COruct();}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::COruct(){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<RN_BIMODULE>>);m_a.resize(m_N_m,m_M.One());int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(MO(m_bd),m_a[i]);}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY...Args> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Initialise(Args&&...args){IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE> temp{m_L,m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);m_lazy_substitution = MO(temp.m_lazy_substitution);m_suspended = MO(temp.m_suspended);m_lazy_action = MO(temp.m_lazy_action);m_lazy_MU = MO(temp.m_lazy_MU);}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Set(CRI i,CO U& u){CO int d = i / m_N_sqrt;U& m_ai = m_a[i];U& m_bd = m_b[d];if(m_suspended[d]){U& m_lazy_substitution_d = m_lazy_substitution[d];if(m_lazy_substitution_d != u){SolveSuspendedSubstitution(d,m_lazy_substitution_d);m_ai = u;m_bd = m_M.Product(m_M.Power(m_lazy_substitution_d,m_N_sqrt - 1),u);}}else{SolveSuspendedAction(d);if(m_ai != u){m_ai = u;SetProduct(d);}}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalSet(CRI i_start,CRI i_final,CO U& u){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int d_0_N_sqrt = d_0 * m_N_sqrt;CO int d_1_N_sqrt = d_1 * m_N_sqrt;CO int i_0 = min(d_0_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1_N_sqrt);if(i_min < i_0){CO int d_0_minus = d_0 - 1;CO int d_0_N_sqrt_minus = d_0_N_sqrt - m_N_sqrt;U& m_bd = m_b[d_0_minus];VE<bool>::reference m_suspended_d = m_suspended[d_0_minus];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_0_minus];IntervalSet_Body(d_0_N_sqrt_minus,i_min,m_lazy_substitution_d);IntervalSet_Body(i_min,i_0,u);IntervalSet_Body(i_0,d_0_N_sqrt,m_lazy_substitution_d);m_suspended_d = false;m_bd = m_M.Product(m_M.Power(m_lazy_substitution_d,m_N_sqrt -(i_0 - i_min)),m_M.Power(u,i_0 - i_min));}else{SolveSuspendedAction(d_0_minus);IntervalSet_Body(i_min,i_0,u);m_bd = m_M.Product(m_M.Product(IntervalProduct_Body(d_0_N_sqrt_minus,i_min),m_M.Power(u,i_0 - i_min)),IntervalProduct_Body(i_0,d_0_N_sqrt));}}CO U pw = m_M.Power(u,m_N_sqrt);CO U& one = m_M.One();CO R& point = m_L.Point();for(int d = d_0;d < d_1;d++){m_b[d]= pw;m_lazy_substitution[d]= u;m_suspended[d]= true;m_lazy_MU[d]= one;m_lazy_action[d]= point;}if(i_1 < i_ulim){CO int d_1_N_sqrt_plus = d_1_N_sqrt + m_N_sqrt;U& m_bd = m_b[d_1];VE<bool>::reference m_suspended_d = m_suspended[d_1];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_1];IntervalSet_Body(d_1_N_sqrt,i_1,m_lazy_substitution_d);IntervalSet_Body(i_1,i_ulim,u);IntervalSet_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_substitution_d);m_suspended_d = false;m_bd = m_M.Product(m_M.Product(m_M.Power(m_lazy_substitution_d,i_1 - d_1_N_sqrt),m_M.Power(u,i_ulim - i_1)),m_M.Power(m_lazy_substitution_d,d_1_N_sqrt_plus - i_ulim));}else{SolveSuspendedAction(d_1);IntervalSet_Body(i_1,i_ulim,u);m_bd = m_M.Product(m_M.Product(IntervalProduct_Body(d_1_N_sqrt,i_1),m_M.Power(u,i_ulim - i_1)),IntervalProduct_Body(i_ulim,d_1_N_sqrt_plus));}}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalAct(CRI i_start,CRI i_final,CO R& r){CO R& point = m_L.Point();if(r != point){CO U& one = m_M.One();CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int d_0_N_sqrt = d_0 * m_N_sqrt;CO int d_1_N_sqrt = d_1 * m_N_sqrt;CO int i_0 = min(d_0_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1_N_sqrt);if(i_min < i_0){CO int d_0_minus = d_0 - 1;CO int d_0_N_sqrt_minus = d_0_N_sqrt - m_N_sqrt;VE<bool>::reference m_suspended_d = m_suspended[d_0_minus];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_0_minus];U& m_bd = m_b[d_0_minus];CO U u = m_M.ScalarProduct(r,m_lazy_substitution_d);IntervalSet_Body(d_0_N_sqrt_minus,i_min,m_lazy_substitution_d);IntervalSet_Body(i_min,i_0,u);IntervalSet_Body(i_0,d_0_N_sqrt,m_lazy_substitution_d);m_suspended_d = false;m_bd = m_M.Product(m_M.Power(m_lazy_substitution_d,m_N_sqrt -(i_0 - i_min)),m_M.Power(u,i_0 - i_min));}else{R& m_lazy_action_d = m_lazy_action[d_0_minus];if(m_lazy_action_d == point){IntervalAct_Body(i_min,i_0,r);}else{IntervalAct_Body(d_0_N_sqrt_minus,i_min,m_lazy_action_d);IntervalAct_Body(i_min,i_0,m_L.Product(r,m_lazy_action_d));IntervalAct_Body(i_0,d_0_N_sqrt,m_lazy_action_d);m_lazy_action_d = point;}U& m_lazy_MU_d = m_lazy_MU[d_0_minus];if(m_lazy_MU_d != one){IntervalMultiply_Body(d_0_N_sqrt_minus,i_min,m_lazy_MU_d);IntervalMultiply_Body(i_min,i_0,m_M.ScalarProduct(r,m_lazy_MU_d));IntervalMultiply_Body(i_0,d_0_N_sqrt,m_lazy_MU_d);m_lazy_MU_d = one;}SetProduct(d_0_minus);}}for(int d = d_0;d < d_1;d++){U& m_bd = m_b[d];m_bd = m_M.ScalarProduct(r,m_bd);if(m_suspended[d]){U& m_lazy_substitution_d = m_lazy_substitution[d];m_lazy_substitution_d = m_M.ScalarProduct(r,m_lazy_substitution_d);}else{R& m_lazy_action_d = m_lazy_action[d];m_lazy_action_d = m_L.Product(r,m_lazy_action_d);U& m_lazy_MU_d = m_lazy_MU[d];m_lazy_MU_d = m_M.ScalarProduct(r,m_lazy_MU_d);}}if(i_1 < i_ulim){CO int d_1_N_sqrt_plus = d_1_N_sqrt + m_N_sqrt;VE<bool>::reference m_suspended_d = m_suspended[d_1];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_1];U& m_bd = m_b[d_1];CO U u = m_M.ScalarProduct(r,m_lazy_substitution_d);IntervalSet_Body(d_1_N_sqrt,i_1,m_lazy_substitution_d);IntervalSet_Body(i_1,i_ulim,u);IntervalSet_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_substitution_d);m_suspended_d = false;m_bd = m_M.Product(m_M.Power(m_lazy_substitution_d,m_N_sqrt -(i_ulim - i_1)),m_M.Power(u,i_ulim - i_1));}else{R& m_lazy_action_d = m_lazy_action[d_1];if(m_lazy_action_d == point){IntervalAct_Body(i_1,i_ulim,r);}else{IntervalAct_Body(d_1_N_sqrt,i_1,m_lazy_action_d);IntervalAct_Body(i_1,i_ulim,m_L.Product(r,m_lazy_action_d));IntervalAct_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_action_d);m_lazy_action_d = point;}U& m_lazy_MU_d = m_lazy_MU[d_1];if(m_lazy_MU_d != one){IntervalMultiply_Body(d_1_N_sqrt,i_1,m_lazy_MU_d);IntervalMultiply_Body(i_1,i_ulim,m_M.ScalarProduct(r,m_lazy_MU_d));IntervalMultiply_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_MU_d);m_lazy_MU_d = one;}SetProduct(d_1);}}}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){CO U& one = m_M.One();if(u != one){CO R& point = m_L.Point();CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int d_0_N_sqrt = d_0 * m_N_sqrt;CO int d_1_N_sqrt = d_1 * m_N_sqrt;CO int i_0 = min(d_0_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1_N_sqrt);if(i_min < i_0){CO int d_0_minus = d_0 - 1;CO int d_0_N_sqrt_minus = d_0_N_sqrt - m_N_sqrt;U& m_bd = m_b[d_0_minus];m_bd = m_M.Product(MO(m_bd),m_M.Power(u,i_0 - i_min));VE<bool>::reference m_suspended_d = m_suspended[d_0_minus];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_0_minus];IntervalSet_Body(d_0_N_sqrt_minus,i_min,m_lazy_substitution_d);IntervalSet_Body(i_min,i_0,m_M.Product(m_lazy_substitution_d,u));IntervalSet_Body(i_0,d_0_N_sqrt,m_lazy_substitution_d);m_suspended_d = false;}else{R& m_lazy_action_d = m_lazy_action[d_0_minus];if(m_lazy_action_d != point){IntervalAct_Body(d_0_N_sqrt_minus,d_0_N_sqrt,m_lazy_action_d);m_lazy_action_d = point;}U& m_lazy_MU_d = m_lazy_MU[d_0_minus];if(m_lazy_MU_d == one){IntervalMultiply_Body(i_min,i_0,u);}else{IntervalMultiply_Body(d_0_N_sqrt_minus,i_min,m_lazy_MU_d);IntervalMultiply_Body(i_min,i_0,m_M.Product(m_lazy_MU_d,u));IntervalMultiply_Body(i_0,d_0_N_sqrt,m_lazy_MU_d);m_lazy_MU_d = one;}}}CO U pw = m_M.Power(u,m_N_sqrt);for(int d = d_0;d < d_1;d++){U& m_bd = m_b[d];m_bd = m_M.Product(MO(m_bd),pw);if(m_suspended[d]){U& m_lazy_substitution_d = m_lazy_substitution[d];m_lazy_substitution_d = m_M.Product(MO(m_lazy_substitution_d),u);}else{U& m_lazy_MU_d = m_lazy_MU[d];m_lazy_MU_d = m_M.Product(MO(m_lazy_MU_d),u);}}if(i_1 < i_ulim){CO int d_1_N_sqrt_plus = d_1_N_sqrt + m_N_sqrt;U& m_bd = m_b[d_1];m_bd = m_M.Product(MO(m_bd),m_M.Power(u,i_ulim - i_1));VE<bool>::reference m_suspended_d = m_suspended[d_1];if(m_suspended_d){CO U& m_lazy_substitution_d = m_lazy_substitution[d_1];IntervalSet_Body(d_1_N_sqrt,i_1,m_lazy_substitution_d);IntervalSet_Body(i_1,i_ulim,m_M.Product(m_lazy_substitution_d,u));IntervalSet_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_substitution_d);m_suspended_d = false;}else{R& m_lazy_action_d = m_lazy_action[d_1];if(m_lazy_action_d != point){IntervalAct_Body(d_1_N_sqrt,d_1_N_sqrt_plus,m_lazy_action_d);m_lazy_action_d = point;}U& m_lazy_MU_d = m_lazy_MU[d_1];if(m_lazy_MU_d == one){IntervalMultiply_Body(i_1,i_ulim,u);}else{IntervalMultiply_Body(d_1_N_sqrt,i_1,m_lazy_MU_d);IntervalMultiply_Body(i_1,i_ulim,m_M.Product(m_lazy_MU_d,u));IntervalMultiply_Body(i_ulim,d_1_N_sqrt_plus,m_lazy_MU_d);m_lazy_MU_d = one;}}}}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN U IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::OP[](CRI i){AS(0 <= i && i < m_N);CO int d = i / m_N_sqrt;RE m_suspended[d]?m_lazy_substitution[d]:m_M.Product(m_M.ScalarProduct(m_lazy_action[d],m_a[i]),m_lazy_MU[d]);}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN U IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Get(CRI i){RE OP[](i);}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN U IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalProduct(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.One();if(i_min < i_0){CO int d_0_minus = d_0 - 1;AN = m_suspended[d_0_minus]?m_M.Power(m_lazy_substitution[d_0_minus],i_0 - i_min):m_M.Product(m_M.ScalarProduct(m_lazy_action[d_0_minus],IntervalProduct_Body(i_min,i_0)),m_M.Power(m_lazy_MU[d_0_minus],i_0 - i_min));}for(int d = d_0;d < d_1;d++){AN = m_M.Product(MO(AN),m_b[d]);}if(i_1 < i_ulim){AN = m_M.Product(MO(AN),m_suspended[d_1]?m_M.Power(m_lazy_substitution[d_1],i_ulim - i_1):m_M.Product(m_M.ScalarProduct(m_lazy_action[d_1],IntervalProduct_Body(i_1,i_ulim)),m_M.Power(m_lazy_MU[d_1],i_ulim - i_1)));}RE AN;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::SetProduct(CRI d){U& m_bd = m_b[d]= m_M.One();CO int i_min = d * m_N_sqrt;CO int i_ulim = i_min + m_N_sqrt;for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Product(MO(m_bd),m_a[i]);}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::SolveSuspendedSubstitution(CRI d,CO U& u){CO int i_min = d * m_N_sqrt;IntervalSet_Body(i_min,i_min + m_N_sqrt,u);m_suspended[d]= false;RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalSet_Body(CRI i_min,CRI i_ulim,CO U& u){for(int i = i_min;i < i_ulim;i++){m_a[i]= u;}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::SolveSuspendedAction(CRI d){CO int i_min = d * m_N_sqrt;CO int i_ulim = i_min + m_N_sqrt;U& m_bd = m_b[d];R& m_lazy_action_d = m_lazy_action[d];if(m_lazy_action_d != m_L.Point()){IntervalAct_Body(i_min,i_ulim,m_lazy_action_d);m_bd = m_M.ScalarProduct(m_lazy_action_d,m_bd);m_lazy_action_d = m_L.Point();}CO U& one = m_M.One();U& m_lazy_MU_d = m_lazy_MU[d];if(m_lazy_MU_d != one){IntervalMultiply_Body(i_min,i_ulim,m_lazy_MU_d);m_bd = m_M.Product(MO(m_bd),m_M.Power(m_lazy_MU_d,m_N_sqrt));m_lazy_MU_d = one;}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalAct_Body(CRI i_min,CRI i_ulim,CO R& r){for(int i = i_min;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_M.ScalarProduct(r,m_ai);}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN VO IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalMultiply_Body(CRI i_min,CRI i_ulim,CO U& u){for(int i = i_min;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_M.Product(MO(m_ai),u);}RE;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN U IntervalMultiplyLazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::IntervalProduct_Body(CRI i_min,CRI i_ulim){U AN = m_M.One();for(int i = i_min;i < i_ulim;i++){AN = m_M.Product(MO(AN),m_a[i]);}RE AN;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY F,SFINAE_FOR_SD_S> IN int LazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Search(CRI i_start,CO F& f,CO bool& reversed){RE reversed?SearchReverse_Body(i_start,f,m_M.One()):Search_Body(i_start,f,m_M.One());}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> IN int LazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Search(CRI i_start,CO U& u,CO bool& reversed){RE Search(i_start,[&](CO U& product,CRI){RE !(product < u);},reversed);}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY F> int LazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::Search_Body(CRI i_start,CO F& f,U product_temp){CO int i_min = max(i_start,0);CO int d_0 = i_min / m_N_sqrt + 1;CO int i_0 = min(d_0 * m_N_sqrt,m_N);if(i_min < i_0){CO int d_0_minus = d_0 - 1;if(m_suspended[d_0_minus]){SolveSuspendedSubstitution(d_0_minus,m_lazy_substitution[d_0_minus]);}else{SolveSuspendedAction(d_0_minus);}}for(int i = i_min;i < i_0;i++){product_temp = m_M.Product(MO(product_temp),m_a[i]);if(f(product_temp,i)){RE i;}}for(int d = d_0;d < m_N_d;d++){U product_next = m_M.Product(product_temp,m_b[d]);if(f(product_next,min((d + 1)* m_N_sqrt,m_N)- 1)){RE Search_Body(d * m_N_sqrt,f,MO(product_temp));}product_temp = MO(product_next);}RE -1;}TE <TY R,TY PT_MAGMA,TY U,TY RN_BIMODULE> TE <TY F> int LazySqrtDecomposition<R,PT_MAGMA,U,RN_BIMODULE>::SearchReverse_Body(CRI i_final,CO F& f,U product_temp){CO int i_max = min(i_final,m_N - 1);CO int d_1 = i_max / m_N_sqrt;CO int i_1 = max(d_1 * m_N_sqrt,0);if(m_suspended[d_1]){SolveSuspendedSubstitution(d_1,m_lazy_substitution[d_1]);}else{SolveSuspendedAction(d_1);}for(int i = i_max;i >= i_1;i--){product_temp = m_M.Product(m_a[i],product_temp);if(f(product_temp,i)){RE i;}}for(int d = d_1 - 1;d >= 0;d--){U product_next = m_M.Product(m_b[d],product_temp);if(f(product_next,d * m_N_sqrt)){RE Search_Body((d + 1)* m_N_sqrt - 1,f,MO(product_temp));}product_temp = MO(product_next);}RE -1;}
#endif

