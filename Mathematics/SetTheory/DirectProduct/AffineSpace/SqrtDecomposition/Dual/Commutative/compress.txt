// ../../../../../../Algebra/compress.txtÇêÊÇ…ì\ÇÈÅB

TE <TY R,TY U>CL VirtualModule{PU:VI U Action(CO R& r,CO U& u)= 0;IN U PW(CO U& u,CO R& r);IN U ScalarProduct(CO R& r,CO U& u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:VI PU VirtualModule<R,U>,PU GROUP{PU:O_U m_o_U;IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);IN U Action(CO R& r,CO U& u);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualModule<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,CO U& u);};
TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):GROUP(MO(M)),m_o_U(MO(o_U)){ST_AS(is_same_v<U,inner_t<GROUP>> && is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN U AbstractModule<R,U,O_U,GROUP>::Action(CO R& r,CO U& u){RE m_o_U(r,u);}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,CO U& u){RE r * u;}TE <TY R,TY U> IN U VirtualModule<R,U>::PW(CO U& u,CO R& r){RE Action(r,u);}TE <TY R,TY U> IN U VirtualModule<R,U>::ScalarProduct(CO R& r,CO U& u){RE Action(r,u);}

IN CE int Sqrt(CRI N)NE{if(N <= 1){RE 1;}int left = 0;int right = N;WH(left + 1 < right){int m =(left + right)/ 2;(m <=(N - 1)/ m?left:right)= m;}RE right;}

TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE>CL DualSqrtDecomposition{PU:PT_MAGMA m_L;R_MODULE m_X;int m_N;int m_N_sqrt;int m_N_d;int m_N_m;VE<U> m_a;VE<R> m_b;IN DualSqrtDecomposition(PT_MAGMA L,R_MODULE X,VE<U> a);IN DualSqrtDecomposition(PT_MAGMA L,R_MODULE X,VE<U> a,CRI N_sqrt);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO Act(CRI i,CO R& r);IN VO IntervalAct(CRI i_start,CRI i_final,CO R& r);IN U OP[](CRI i);IN U Get(CRI i);IN VO Update(CRI d);};TE <TY PT_MAGMA,TY U,TY R_MODULE,TY...Args> DualSqrtDecomposition(PT_MAGMA M,R_MODULE X,VE<U> a,Args&&... args)-> DualSqrtDecomposition<inner_t<PT_MAGMA>,PT_MAGMA,U,R_MODULE>;
TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::DualSqrtDecomposition(PT_MAGMA L,R_MODULE X,VE<U> a):m_L(MO(L)),m_X(MO(X)),m_N(a.SZ()),m_N_sqrt(Sqrt(m_N)),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt),m_a(MO(a)),m_b(m_N_d,m_L.Point()){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<R_MODULE>>);}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::DualSqrtDecomposition(PT_MAGMA L,R_MODULE X,VE<U> a,CRI N_sqrt):m_L(MO(L)),m_X(MO(X)),m_N(a.SZ()),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt),m_a(MO(a)),m_b(m_N_d,m_L.Point()){ST_AS(is_same_v<R,inner_t<PT_MAGMA>> && is_same_v<U,inner_t<R_MODULE>>);}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> TE <TY...Args> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::Initialise(Args&&... args){*TH = DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>(MO(m_L),MO(m_X),forward<Args>(args)...);}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::Set(CRI i,CO U& u){U& m_ai = m_a[i];if(m_ai != u){Update(i / m_N_sqrt);m_ai = u;}}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::IntervalAct(CRI i_start,CRI i_final,CO R& r){if(r != m_L.Point()){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);if(d_0 > 0){Update(d_0 - 1);}for(int i = i_min;i < i_0;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r,m_ai);}for(int d = d_0;d < d_1;d++){R& m_bd = m_b[d];m_bd = m_L.Product(r,m_bd);}if(d_1 < m_N_d){Update(d_1);}for(int i = i_1;i < i_ulim;i++){U& m_ai = m_a[i];m_ai = m_X.Action(r,m_ai);}}RE;}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::OP[](CRI i){AS(0 <= i && i < m_N);RE m_X.Action(m_b[i / m_N_sqrt],m_a[i]);}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN U DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::Get(CRI i){RE OP[](i);}TE <TY R,TY PT_MAGMA,TY U,TY R_MODULE> IN VO DualSqrtDecomposition<R,PT_MAGMA,U,R_MODULE>::Update(CRI d){R& m_bd = m_b[d];CO R& point = m_L.Point();if(m_bd != point){CO int j_min = d * m_N_sqrt;CO int j_ulim = min(j_min + m_N_sqrt,m_N);for(int j = j_min;j < j_ulim;j++){U& m_aj = m_a[j];m_aj = m_X.Action(m_bd,m_aj);}m_bd = point;}RE;}

TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_MODULE>CL CommutativeDualSqrtDecomposition:PU DualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_MODULE>{PU:TE <TY...Args> IN CommutativeDualSqrtDecomposition(PT_COMM_MAGMA L,R_MODULE X,VE<U> a,Args&&... args);IN VO Act(CRI i,CO R& r);};TE <TY PT_COMM_MAGMA,TY U,TY R_MODULE,TY...Args> CommutativeDualSqrtDecomposition(PT_COMM_MAGMA M,R_MODULE X,VE<U> a,Args&&... args)-> CommutativeDualSqrtDecomposition<inner_t<PT_COMM_MAGMA>,PT_COMM_MAGMA,U,R_MODULE>;
TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_MODULE> TE <TY...Args> IN CommutativeDualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_MODULE>::CommutativeDualSqrtDecomposition(PT_COMM_MAGMA L,R_MODULE X,VE<U> a,Args&&... args):DualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_MODULE>(MO(L),MO(X),MO(a),forward<Args>(args)...){}TE <TY R,TY PT_COMM_MAGMA,TY U,TY R_MODULE> IN VO CommutativeDualSqrtDecomposition<R,PT_COMM_MAGMA,U,R_MODULE>::Act(CRI i,CO R& r){TH->Update(i / TH->m_N_sqrt);U& m_ai = TH->m_a[i];m_ai = TH->m_X.Action(r,m_ai);}
