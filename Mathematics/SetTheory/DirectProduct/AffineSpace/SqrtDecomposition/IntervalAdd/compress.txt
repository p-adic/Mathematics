#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/IntervalAdd/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

CL SqrtDecompositionCoordinate{PU:int m_N;int m_N_sqrt;int m_N_d;int m_N_m;IN SqrtDecompositionCoordinate(CRI N = 0);IN SqrtDecompositionCoordinate(CRI N,CRI N_sqrt);ST IN int Sqrt(CRI N)NE;};
IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N):SqrtDecompositionCoordinate(N,Sqrt(N)){};IN SqrtDecompositionCoordinate::SqrtDecompositionCoordinate(CRI N,CRI N_sqrt):m_N(N),m_N_sqrt(N_sqrt),m_N_d((m_N + m_N_sqrt - 1)/ m_N_sqrt),m_N_m(m_N_d * m_N_sqrt){}IN int SqrtDecompositionCoordinate::Sqrt(CRI N)NE{if(N <= 1){RE 1;}int l = 0,r = N;WH(l + 1 < r){int m =(l + r)>> 1;(m <=(N - 1)/ m?l:r)= m;}RE r;}

#define SFINAE_FOR_SD_S enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY ABELIAN_GROUP>CL AbstractSqrtDecomposition:PU SqrtDecompositionCoordinate{PU:ABELIAN_GROUP m_M;VE<U> m_a;VE<U> m_b;TE <TY...Args> IN AbstractSqrtDecomposition(ABELIAN_GROUP M,CRI N = 0,CO Args&... args);TE <TY...Args> IN AbstractSqrtDecomposition(ABELIAN_GROUP M,VE<U> a,CO Args&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO Add(CRI i,CO U& u);IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_SD_S = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CRI i_start,CO U& u);VO COruct();TE <TY F> int Search_Body(CRI i_start,CO F& f,U sum_temp);};TE <TY ABELIAN_GROUP,TY...Args> AbstractSqrtDecomposition(ABELIAN_GROUP M,Args&&...args)-> AbstractSqrtDecomposition<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL SqrtDecomposition:PU AbstractSqrtDecomposition<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN SqrtDecomposition(Args&&... args);};TE <TY U,TY...Args> SqrtDecomposition(VE<U> a,Args&&...args)-> SqrtDecomposition<U>;
TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN AbstractSqrtDecomposition<U,ABELIAN_GROUP>::AbstractSqrtDecomposition(ABELIAN_GROUP M,CRI N,CO Args&... args):SqrtDecompositionCoordinate(N,args...),m_M(MO(M)),m_a(m_N_m,m_M.Zero()),m_b(m_N_d,m_M.Zero()){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<ABELIAN_GROUP>>);}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN AbstractSqrtDecomposition<U,ABELIAN_GROUP>::AbstractSqrtDecomposition(ABELIAN_GROUP M,VE<U> a,CO Args&... args):SqrtDecompositionCoordinate(a.SZ(),args...),m_M(MO(M)),m_a(MO(a)),m_b(m_N_d,m_M.Zero()){COruct();}TE <TY U> TE <TY...Args> IN SqrtDecomposition<U>::SqrtDecomposition(Args&&... args):AbstractSqrtDecomposition<U,AdditiveGroup<U>>(AdditiveGroup<U>(),forward<Args>(args)...){}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractSqrtDecomposition<U,ABELIAN_GROUP>::COruct(){ST_AS(! is_same_v<U,int> && is_same_v<U,inner_t<ABELIAN_GROUP>>);m_a.resize(m_N_m);int i_min = 0;int i_ulim = m_N_sqrt;for(int d = 0;d < m_N_d;d++){U& m_bd = m_b[d];for(int i = i_min;i < i_ulim;i++){m_bd = m_M.Sum(MO(m_bd),m_a[i]);}i_min = i_ulim;i_ulim += m_N_sqrt;}}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Initialise(Args&&... args){AbstractSqrtDecomposition<U,ABELIAN_GROUP> temp{m_M,forward<Args>(args)...};SqrtDecompositionCoordinate::OP=(temp);m_a = MO(temp.m_a);m_b = MO(temp.m_b);}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){U& m_ai = m_a[i];U& m_bd = m_b[i / m_N_sqrt];m_bd = m_M.Sum(MO(m_bd),m_M.Sum(m_M.Inverse(m_ai),u));m_ai = u;}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){U& m_ai = m_a[i];U& m_bd = m_b[i / m_N_sqrt];m_bd = m_M.Sum(MO(m_bd),u);m_ai = m_M.Sum(MO(m_ai),u);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractSqrtDecomposition<U,ABELIAN_GROUP>::OP[](CRI i)CO{AS(0 <= i && i < m_N);RE m_a[i];}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractSqrtDecomposition<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,m_N);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int d_1 = max(d_0,i_ulim / m_N_sqrt);CO int i_0 = min(d_0 * m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * m_N_sqrt);U AN = m_M.Zero();for(int i = i_min;i < i_0;i++){AN = m_M.Sum(MO(AN),m_a[i]);}for(int d = d_0;d < d_1;d++){AN = m_M.Sum(MO(AN),m_b[d]);}for(int i = i_1;i < i_ulim;i++){AN = m_M.Sum(MO(AN),m_a[i]);}RE AN;}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_SD_S> IN int AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Search(CRI i_start,CO F& f){RE Search_Body(i_start,f,m_M.Zero());}TE <TY U,TY ABELIAN_GROUP> IN int AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Search(CRI i_start,CO U& u){RE Search(i_start,[&](CO U& sum,CRI){RE !(u < sum);});}TE <TY U,TY ABELIAN_GROUP> TE <TY F> int AbstractSqrtDecomposition<U,ABELIAN_GROUP>::Search_Body(CRI i_start,CO F& f,U sum_temp){CO int i_min = max(i_start,0);CO int d_0 =(i_min + m_N_sqrt - 1)/ m_N_sqrt;CO int i_0 = min(d_0 * m_N_sqrt,m_N);for(int i = i_min;i < i_0;i++){sum_temp = m_M.Sum(MO(sum_temp),m_a[i]);if(f(sum_temp,i)){RE i;}}for(int d = d_0;d < m_N_d;d++){U sum_next = m_M.Sum(sum_temp,m_b[d]);if(f(sum_next,min((d + 1)* m_N_sqrt,m_N)- 1)){RE Search_Body(d * m_N_sqrt,f,sum_temp);}sum_temp = MO(sum_next);}RE -1;}

TE <TY U,TY Z_MODULE>CL IntervalAddAbstractSqrtDecomposition:PU AbstractSqrtDecomposition<U,Z_MODULE>{PU:VE<U> m_lazy_addition;TE <TY...Args> IN IntervalAddAbstractSqrtDecomposition(Z_MODULE M,Args&&... args);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,CO U& u);IN VO IntervalAdd(CRI i_start,CRI i_final,CO U& u);IN U OP[](CRI i);IN U Get(CRI i);IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_SD_S> IN int Search(CRI i_start,CO F& f)= delete;IN int Search(CRI i_start,CO U& u)= delete;};TE <TY Z_MODULE,TY...Args> IntervalAddAbstractSqrtDecomposition(Z_MODULE M,Args&&... args)-> IntervalAddAbstractSqrtDecomposition<inner_t<Z_MODULE>,Z_MODULE>;TE <TY U = ll>CL IntervalAddSqrtDecomposition:PU IntervalAddAbstractSqrtDecomposition<U,Module<int,U>>{PU:TE <TY...Args> IN IntervalAddSqrtDecomposition(Args&&... args);};TE <TY U,TY...Args> IntervalAddSqrtDecomposition(VE<U> a,Args&&...args)-> IntervalAddSqrtDecomposition<U>;
TE <TY U,TY Z_MODULE> TE <TY...Args> IN IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::IntervalAddAbstractSqrtDecomposition(Z_MODULE M,Args&&... args):AbstractSqrtDecomposition<U,Z_MODULE>(MO(M),forward<Args>(args)...),m_lazy_addition(TH->m_N_d,TH->m_M.Zero()){}TE <TY U> TE <TY...Args> IN IntervalAddSqrtDecomposition<U>::IntervalAddSqrtDecomposition(Args&&... args):IntervalAddAbstractSqrtDecomposition<U,Module<int,U>>(Module<int,U>(),args...){}TE <TY U,TY Z_MODULE> TE <TY...Args> IN VO IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::Initialise(Args&&... args){AbstractSqrtDecomposition<U,Z_MODULE>::Initialise(forward<Args>(args)...);m_lazy_addition = VE(TH->m_N_d,TH->m_M.Zero());}TE <TY U,TY Z_MODULE> IN VO IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::Set(CRI i,CO U& u){CO int d = i / TH->m_N_sqrt;TH->m_b[d]= TH->m_M.Sum(MO(TH->m_b[d]),TH->m_M.Sum(TH->m_M.Inverse(TH->m_a[i]),u));TH->m_a[i]= TH->m_M.Sum(TH->m_M.Inverse(m_lazy_addition[d]),u);}TE <TY U,TY Z_MODULE> IN VO IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::IntervalAdd(CRI i_start,CRI i_final,CO U& u){if(u != TH->m_M.Zero()){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,TH->m_N);CO int d_0 =(i_min + TH->m_N_sqrt - 1)/ TH->m_N_sqrt;CO int d_1 = max(d_0,i_ulim / TH->m_N_sqrt);CO int i_0 = min(d_0 * TH->m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * TH->m_N_sqrt);for(int i = i_min;i < i_0;i++){TH->Add(i,u);}for(int d = d_0;d < d_1;d++){U& m_lazy_addition_d = m_lazy_addition[d];m_lazy_addition_d = TH->m_M.Sum(MO(m_lazy_addition_d),u);}for(int i = i_1;i < i_ulim;i++){TH->Add(i,u);}}RE;}TE <TY U,TY Z_MODULE> IN U IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::OP[](CRI i){AS(0 <= i && i < TH->m_N);RE TH->m_M.Sum(AbstractSqrtDecomposition<U,Z_MODULE>::OP[](i),m_lazy_addition[i / TH->m_N_sqrt]);}TE <TY U,TY Z_MODULE> IN U IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::Get(CRI i){RE OP[](i);}TE <TY U,TY Z_MODULE> IN U IntervalAddAbstractSqrtDecomposition<U,Z_MODULE>::IntervalSum(CRI i_start,CRI i_final){CO int i_min = max(i_start,0);CO int i_ulim = min(i_final + 1,TH->m_N);CO int d_0 =(i_min + TH->m_N_sqrt - 1)/ TH->m_N_sqrt;CO int d_1 = max(d_0,i_ulim / TH->m_N_sqrt);CO int i_0 = min(d_0 * TH->m_N_sqrt,i_ulim);CO int i_1 = max(i_0,d_1 * TH->m_N_sqrt);U AN = TH->m_M.Zero();for(int d = d_0;d < d_1;d++){AN = TH->m_M.Sum(MO(AN),m_lazy_addition[d]);}AN = TH->m_M.ScalarProduct(AN,d_1 - d_0);if(d_0 > 0){AN = TH->m_M.Sum(MO(AN),TH->m_M.ScalarProduct(m_lazy_addition[d_0 - 1],i_0 - i_min));}if(d_1 < TH->m_N_d){AN = TH->m_M.Sum(MO(AN),TH->m_M.ScalarProduct(m_lazy_addition[d_1],i_ulim - i_1));}AN = TH->m_M.Sum(MO(AN),AbstractSqrtDecomposition<U,Z_MODULE>::IntervalSum(i_start,i_final));RE AN;}
#endif

