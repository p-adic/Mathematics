IN CE int Sqrt(CRI N)NE{if(N <= 1){RE 1;}int left = 0;int right = N;WH(left + 1 < right){int m =(left + right)/ 2;(m <=(N - 1)/ m?left:right)= m;}RE right;}

CL Mo{PU:int m_Q;int m_Y_d;VE<VE<tuple<int,int,int>>> m_query;IN Mo()= default;IN Mo(CO VE<pair<int,int>>& query,int y_dif_sqrt = 0);IN VO Set(CO VE<pair<int,int>>& query,int y_dif_sqrt = 0);IN CO VE<VE<tuple<int,int,int>>>& Get()CO NE;TE <TY F,TY DFx,TY DFy> VE<ret_t<F,int,int>> Solve(F& f,DFx& dfx,DFy& dfy)CO;IN VO IntroSort(CO VE<pair<int,int>>& query,CRI y_start,CRI y_dif_sqrt);IN VO BucketSort(CO VE<pair<int,int>>& query,CRI x_start,CRI x_dif,CRI y_start,CRI y_dif_sqrt);TE <TY R,TY DFx,TY DFy> VO Solve_Body(VE<R>& AN,R& temp,int& x,int& y,DFx& dfx,DFy& dfy,CRI d,CRI i_start)CO;};
IN Mo::Mo(CO VE<pair<int,int>>& query,int y_dif_sqrt):Mo(){Set(query,y_dif_sqrt);}IN VO Mo::Set(CO VE<pair<int,int>>& query,int y_dif_sqrt){m_Q = query.SZ();if(m_Q > 0){auto[x_start,y_start]= query[0];int x_final = x_start;int y_final = y_start;for(int q = 1;q < m_Q;q++){auto&[x,y]= query[q];x < x_start?x_start = x:x_final < x?x_final = x:x_final;y < y_start?y_start = y:y_final < y?y_final = y:y_final;}CO int x_dif = x_final - x_start + 1;CO int x_div = x_dif / m_Q;CO int y_dif = y_final - y_start + 1;y_dif_sqrt == 0?y_dif_sqrt = Sqrt(y_dif):y_dif_sqrt;m_query.reSZ(m_Y_d = y_dif / y_dif_sqrt + 1);if(x_div < 31 && m_Q >> x_div > 0){BucketSort(query,x_start,x_dif,y_start,y_dif_sqrt);}else{IntroSort(query,y_start,y_dif_sqrt);}}RE;}IN VO Mo::IntroSort(CO VE<pair<int,int>>& query,CRI y_start,CRI y_dif_sqrt){VE<tuple<int,int,int>> intro_sort(m_Q);for(int q = 0;q < m_Q;q++){auto&[x,y]= query[q];intro_sort[q]={x,y,q};}sort(intro_sort.BE(),intro_sort.EN());for(int i = 0;i < m_Q;i++){auto&[x,y,q]= intro_sort[i];m_query[(y - y_start)/ y_dif_sqrt].push_back({x,y,q});}RE;}IN VO Mo::BucketSort(CO VE<pair<int,int>>& query,CRI x_start,CRI x_dif,CRI y_start,CRI y_dif_sqrt){VE<VE<int>> bucket_sort(x_dif);for(int q = 0;q < m_Q;q++){bucket_sort[query[q].first - x_start].push_back(q);}for(int x = 0;x < x_dif;x++){auto& bucket_x = bucket_sort[x];CO int SZ = bucket_x.SZ();for(int i = 0;i < SZ;i++){CRI q = bucket_x[i];auto&[x,y]= query[q];m_query[(y - y_start)/ y_dif_sqrt].push_back({x,y,q});}}RE;}IN CO VE<VE<tuple<int,int,int>>>& Mo::Get()CO NE{RE m_query;}TE <TY F,TY DFx,TY DFy> VE<ret_t<F,int,int>> Mo::Solve(F& f,DFx& dfx,DFy& dfy)CO{US R = ret_t<F,int,int>;ST_AS(is_invocable_r_v<R,DFx,R,int,int,int> && is_invocable_r_v<R,DFy,R,int,int,int>);VE<R> AN(m_Q);if(m_Q > 0){int d = 0;WH(m_query[d].empty()){d++;}auto[x,y,i]= m_query[d][0];R temp = AN[i]= f(x,y);Solve_Body(AN,temp,x,y,dfx,dfy,d,1);WH(++d < m_Y_d){Solve_Body(AN,temp,x,y,dfx,dfy,d,0);}}RE AN;}TE <TY R,TY DFx,TY DFy> VO Mo::Solve_Body(VE<R>& AN,R& temp,int& x,int& y,DFx& dfx,DFy& dfy,CRI d,CRI i_start)CO{auto& m_query_d = m_query[d];CO int SZ = m_query_d.SZ();for(int i = i_start;i < SZ;i++){auto&[x_next,y_next,q]= m_query_d[i];AN[q]= temp = dfy(dfx(temp,x,y,x_next),x_next,y,y_next);x = x_next;y = y_next;}RE;}
