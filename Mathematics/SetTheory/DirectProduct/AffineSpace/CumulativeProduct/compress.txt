// êÊÇ…../../../Algebra/compress.txtÇì\ÇÈÅB

#define SFINAE_FOR_CP_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U>CL VirtualCumulativeProduct{PU:VI U PathProduct(CRI i,CRI j)= 0;VI int Parent(CRI i)= 0;VI int LCA(CRI i,CRI j)= 0;};TE <TY U,TY GROUP>CL PathProductImplementation:VI PU VirtualCumulativeProduct<U>{PU:GROUP m_M;int m_SZ;VE<U> m_right;VE<U> m_left;IN PathProductImplementation(GROUP M,CRI SZ);IN U PathProduct(CRI i_start,CRI i_final);};TE <TY U,TY GROUP>CL AbstractCumulativeProduct:PU PathProductImplementation<U,GROUP>{PU:VE<U> m_a;IN AbstractCumulativeProduct(GROUP M,CRI SZ = 0);IN AbstractCumulativeProduct(GROUP M,VE<U> a);IN VO Initialise(CO VE<U>& a);IN VO Set(CRI i,CO U& u);IN VO RightMultiply(CRI i,CO U& u);IN VO LeftMultiply(CRI i,CO U& u);IN CO U& RightInitialSegmentProduct(int i_final);IN CO U& LeftInitialSegmentProduct(int i_final);IN U RightIntervalProduct(CRI i_start,int i_final);IN U LeftIntervalProduct(CRI i_start,int i_final);ll CountRightIntervalProductInverseImage(CO U& u);ll CountLeftIntervalProductInverseImage(CO U& u);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int RightBinarySearch(CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int LeftBinarySearch(CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int RightBinarySearch(CRI i_start,CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int LeftBinarySearch(CRI i_start,CO F& f);int RightBinarySearch(CO U& u);int LeftBinarySearch(CO U& u);int RightBinarySearch(CRI i_start,CO U& u);int LeftBinarySearch(CRI i_start,CO U& u);IN int Parent(CRI i);IN int LCA(CRI i,CRI j);};TE <TY GROUP,TY...Args> AbstractCumulativeProduct(GROUP M,CO Args&... args)-> AbstractCumulativeProduct<inner_t<GROUP>,GROUP>;TE <TY U>CL CumulativeSum:PU AbstractCumulativeProduct<U,AdditiveGroup<U>>{PU:IN CumulativeSum(CRI SZ = 0);IN CumulativeSum(VE<U> a);IN VO Add(CRI i,CO U& u);IN CO U& InitialSegmentSum(int i_final);IN U IntervalSum(CRI i_start,int i_final);ll CountIntervalSumInverseImage(CO U& u = U());TE <TY...Args> int BinarySearch(CO Args&... args);};
TE <TY U,TY GROUP> IN PathProductImplementation<U,GROUP>::PathProductImplementation(GROUP M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_right(m_SZ,m_M.One()),m_left(m_right){}TE <TY U,TY GROUP> IN AbstractCumulativeProduct<U,GROUP>::AbstractCumulativeProduct(GROUP M,CRI SZ):AbstractCumulativeProduct(M,VE<U>(SZ,M.One())){}TE <TY U,TY GROUP> IN AbstractCumulativeProduct<U,GROUP>::AbstractCumulativeProduct(GROUP M,VE<U> a):PathProductImplementation<U,GROUP>(MO(M),a.SZ()),m_a(MO(a)){if(!m_a.empty()){TH->m_right[0]= TH->m_left[0]= m_a[0];for(int i = 1;i < TH->m_SZ;i++){TH->m_right[i]= TH->m_M.Product(TH->m_right[i-1],m_a[i]);TH->m_left[i]= TH->m_M.Product(m_a[i],TH->m_left[i-1]);}}}TE <TY U> IN CumulativeSum<U>::CumulativeSum(CRI SZ):CumulativeSum(VE<U>(SZ)){}TE <TY U> IN CumulativeSum<U>::CumulativeSum(VE<U> a):AbstractCumulativeProduct<U,AdditiveGroup<U>>(AdditiveGroup<U>(),MO(a)){}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::Initialise(CO VE<U>& a){*TH = AbstractCumulativeProduct(MO(TH->m_M),a);}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::Set(CRI i,CO U& u){AS(0 <= i && i < TH->_SZ);m_a[i]= u;if(i == 0){TH->m_right[0]= TH->m_left[0]= m_a[0];}for(int j = max(i,1);j < TH->m_SZ;j++){TH->m_right[j]= TH->m_M.Product(TH->m_right[j-1],m_a[j]);TH->m_left[j]= TH->m_M.Product(m_a[j],TH->m_left[j-1]);}}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::RightMultiply(CRI i,CO U& u){Set(i,TH->m_M.Product(m_a[i],u));}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::LeftMultiply(CRI i,CO U& u){Set(i,TH->m_M.Product(u,m_a[i]));}TE <TY U> IN VO CumulativeSum<U>::Add(CRI i,CO U& u){TH->RightMultiply(i,u);}TE <TY U,TY GROUP> IN U PathProductImplementation<U,GROUP>::PathProduct(CRI i_start,CRI i_final){AS(0 <= i_start && i_start < m_SZ && 0 <= i_final && i_final < m_SZ);CO int k = TH->LCA(i_start,i_final);RE m_M.Product(m_M.Product(m_left[i_start],m_M.Inverse(m_left[k])),k == 0?m_right[i_final]:m_M.Product(m_M.Inverse(m_right[TH->Parent(k)]),m_right[i_final]));}TE <TY U,TY GROUP> IN CO U& AbstractCumulativeProduct<U,GROUP>::RightInitialSegmentProduct(int i_final){i_final = min(i_final,TH->m_SZ - 1);RE 0 <= i_final?TH->m_right[i_final]:TH->m_M.One();}TE <TY U,TY GROUP> IN CO U& AbstractCumulativeProduct<U,GROUP>::LeftInitialSegmentProduct(int i_final){i_final = min(i_final,TH->m_SZ - 1);RE 0 <= i_final?TH->m_left[i_final]:TH->m_M.One();;}TE <TY U> IN CO U& CumulativeSum<U>::InitialSegmentSum(int i_final){RE TH->RightInitialSegmentProduct(MO(i_final));}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::RightIntervalProduct(CRI i_start,int i_final){i_final = min(i_final,TH->m_SZ - 1);RE i_start <= i_final?i_start <= 0?TH->m_right[i_final]:TH->m_M.Product(TH->m_M.Inverse(TH->m_right[i_start-1]),TH->m_right[i_final]):TH->m_M.One();}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::LeftIntervalProduct(CRI i_start,int i_final){i_final = min(i_final,TH->m_SZ - 1);RE i_start <= i_final?i_start <= 0?TH->m_left[i_final]:TH->m_M.Product(TH->m_left[i_final],TH->m_M.Inverse(TH->m_left[i_start - 1])):TH->m_M.One();}TE <TY U> IN U CumulativeSum<U>::IntervalSum(CRI i_start,int i_final){RE TH->RightIntervalProduct(i_start,MO(i_final));}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountRightIntervalProductInverseImage(CO U& u){map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 0;i < TH->m_SZ;i++){CO U& m_right_i = TH->m_right[i];f.count(m_right_i)== 1?AN += f[m_right_i]:AN;f[TH->m_M.Product(m_right_i,u)]++;}RE AN;}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountLeftIntervalProductInverseImage(CO U& u){map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 0;i < TH->m_SZ;i++){CO U& m_left_i = TH->m_left[i];f.count(m_left_i)== 1?AN += f[m_left_i]:AN;f[TH->m_M.Product(u,m_left_i)]++;}RE AN;}TE <TY U> ll CumulativeSum<U>::CountIntervalSumInverseImage(CO U& u){RE TH->CountRightIntervalProductInverseImage(u);}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CO F& f){if(f(m_a[0],0)){RE 0;}int l = 0;int r = TH->m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(RightInitialSegmentProduct(m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CO F& f){if(f(m_a[0],0)){RE 0;}int l = 0;int r = TH->m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(LeftInitialSegmentProduct(m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO F& f){if(f(m_a[i_start],i_start)){RE i_start;}int l = i_start;int r = TH->m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(RightIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO F& f){if(f(m_a[i_start],i_start)){RE i_start;}int l = i_start;int r = TH->m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(LeftIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CO U& u){RE RightBinarySearch([&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CO U& u){RE LeftBinarySearch([&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO U& u){RE RightBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO U& u){RE LeftBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U> TE <TY...Args> int CumulativeSum<U>::BinarySearch(CO Args&... args){RE TH->RightBinarySearch(args...);}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::Parent(CRI i){RE i - 1;}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LCA(CRI i,CRI j){RE min(i,j);}
