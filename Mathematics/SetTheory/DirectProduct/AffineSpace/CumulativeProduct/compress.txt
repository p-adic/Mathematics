#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/CumulativeProduct/a_Body.hpp"
#else
#define SFINAE_FOR_CP_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY GROUP>CL AbstractCumulativeProduct{PU:GROUP m_M;int m_SZ;VE<U> m_a;VE<U> m_right;VE<U> m_left;IN AbstractCumulativeProduct(GROUP M,CRI SZ = 0);IN AbstractCumulativeProduct(GROUP M,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Set(CRI i,U u);IN VO RightMultiply(CRI i,CO U& u);IN VO LeftMultiply(CRI i,U u);IN CO U& RightInitialSegmentProduct(int i_final);IN CO U& LeftInitialSegmentProduct(int i_final);IN U RightIntervalProduct(CRI i_start,int i_final);IN U LeftIntervalProduct(CRI i_start,int i_final);ll CountRightIntervalProductInverseImage(CO U& u);ll CountLeftIntervalProductInverseImage(CO U& u);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int RightBinarySearch(CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int LeftBinarySearch(CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int RightBinarySearch(CRI i_start,CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int LeftBinarySearch(CRI i_start,CO F& f);int RightBinarySearch(CO U& u);int LeftBinarySearch(CO U& u);int RightBinarySearch(CRI i_start,CO U& u);int LeftBinarySearch(CRI i_start,CO U& u);};TE <TY GROUP,TY...Args> AbstractCumulativeProduct(GROUP M,Args&&... args)-> AbstractCumulativeProduct<inner_t<GROUP>,GROUP>;TE <TY U>CL CumulativeSum:PU AbstractCumulativeProduct<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN CumulativeSum(Args&&... args);IN VO Add(CRI i,CO U& u);IN CO U& InitialSegmentSum(int i_final);IN U IntervalSum(CRI i_start,int i_final);ll CountIntervalSumInverseImage(CO U& u = U());TE <TY...Args> int BinarySearch(CO Args&... args);};TE <TY U> CumulativeSum(VE<U>)-> CumulativeSum<U>;
TE <TY U,TY GROUP> IN AbstractCumulativeProduct<U,GROUP>::AbstractCumulativeProduct(GROUP M,CRI SZ):AbstractCumulativeProduct(M,VE<U>(SZ,M.One())){}TE <TY U,TY GROUP> IN AbstractCumulativeProduct<U,GROUP>::AbstractCumulativeProduct(GROUP M,VE<U> a):m_M(MO(M)),m_SZ(a.SZ()),m_a(MO(a)),m_right(m_SZ + 1,m_M.One()),m_left(m_right){ST_AS(is_same_v<U,inner_t<GROUP>>);for(int i = 0;i < m_SZ;i++){m_right[i+1]= m_M.Product(m_right[i],m_a[i]);m_left[i+1]= m_M.Product(m_a[i],m_left[i]);}}TE <TY U> TE <TY...Args> IN CumulativeSum<U>::CumulativeSum(Args&&... args):AbstractCumulativeProduct<U,AdditiveGroup<U>>(AdditiveGroup<U>(),forward<Args>(args)...){}TE <TY U,TY GROUP> TE <TY...Args> IN VO AbstractCumulativeProduct<U,GROUP>::Initialise(Args&&... args){AbstractCumulativeProduct temp{m_M,forward<Args>(args)...};m_SZ = temp.m_SZ;m_a = MO(temp.m_a);m_right = MO(temp.m_right);m_left = MO(temp.m_left);}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::Set(CRI i,U u){AS(0 <= i && i < m_SZ);m_a[i]= MO(u);for(int j = i;j < m_SZ;j++){m_right[j+1]= m_M.Product(m_right[j],m_a[j]);m_left[j+1]= m_M.Product(m_a[j],m_left[j]);}}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::RightMultiply(CRI i,CO U& u){Set(i,m_M.Product(MO(m_a[i]),u));}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::LeftMultiply(CRI i,U u){Set(i,m_M.Product(MO(u),m_a[i]));}TE <TY U> IN VO CumulativeSum<U>::Add(CRI i,CO U& u){TH->RightMultiply(i,u);}TE <TY U,TY GROUP> IN CO U& AbstractCumulativeProduct<U,GROUP>::RightInitialSegmentProduct(int i_final){RE m_right[max(0,min(++i_final,m_SZ))];}TE <TY U,TY GROUP> IN CO U& AbstractCumulativeProduct<U,GROUP>::LeftInitialSegmentProduct(int i_final){RE m_left[max(0,min(++i_final,m_SZ))];}TE <TY U> IN CO U& CumulativeSum<U>::InitialSegmentSum(int i_final){RE TH->RightInitialSegmentProduct(MO(i_final));}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::RightIntervalProduct(CRI i_start,int i_final){RE i_start <(i_final = min(i_final + 1,m_SZ))?i_start <= 0?m_right[i_final]:m_M.Product(m_M.Inverse(m_right[i_start]),m_right[i_final]):m_M.One();}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::LeftIntervalProduct(CRI i_start,int i_final){RE i_start <(i_final = min(i_final + 1,m_SZ))?i_start <= 0?m_left[i_final]:m_M.Product(m_left[i_final],m_M.Inverse(m_left[i_start])):m_M.One();}TE <TY U> IN U CumulativeSum<U>::IntervalSum(CRI i_start,int i_final){RE TH->RightIntervalProduct(i_start,MO(i_final));}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountRightIntervalProductInverseImage(CO U& u){Map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 1;i <= m_SZ;i++){CO U& m_right_i = m_right[i];f.count(m_right_i)== 1?AN += f[m_right_i]:AN;f[m_M.Product(m_right_i,u)]++;}RE AN;}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountLeftIntervalProductInverseImage(CO U& u){Map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 1;i <= m_SZ;i++){CO U& m_left_i = m_left[i];f.count(m_left_i)== 1?AN += f[m_left_i]:AN;f[m_M.Product(u,m_left_i)]++;}RE AN;}TE <TY U> ll CumulativeSum<U>::CountIntervalSumInverseImage(CO U& u){RE TH->CountRightIntervalProductInverseImage(u);}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CO F& f){if(f(m_a[0],0)){RE 0;}int l = 0;int r = m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(RightInitialSegmentProduct(m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CO F& f){if(f(m_a[0],0)){RE 0;}int l = 0;int r = m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(LeftInitialSegmentProduct(m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO F& f){if(f(m_a[i_start],i_start)){RE i_start;}int l = i_start;int r = m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(RightIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO F& f){if(f(m_a[i_start],i_start)){RE i_start;}int l = i_start;int r = m_SZ;WH(l + 1 < r){int m =(l + r)/ 2;(f(LeftIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CO U& u){RE RightBinarySearch([&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CO U& u){RE LeftBinarySearch([&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO U& u){RE RightBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO U& u){RE LeftBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U> TE <TY...Args> int CumulativeSum<U>::BinarySearch(CO Args&... args){RE TH->RightBinarySearch(args...);}
#endif

