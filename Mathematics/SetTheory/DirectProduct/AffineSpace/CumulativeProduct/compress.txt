#define SFINAE_FOR_CP_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U>CL VirtualCumulativeProduct{PU:VI U PathProduct(CRI i,CRI j)= 0;VI int Parent(CRI i)= 0;VI int LCA(CRI i,CRI j)= 0;};TE <TY U,TY GROUP>CL PathProductImplementation:VI PU VirtualCumulativeProduct<U>{PU:int m_SZ;GROUP m_M;VE<U> m_right;VE<U> m_left;IN PathProductImplementation(CRI SZ,GROUP M);IN U PathProduct(CRI i,CRI j);};TE <TY U,TY GROUP>CL AbstractCumulativeProduct:PU PathProductImplementation<U,GROUP>{PU:IN AbstractCumulativeProduct(GROUP M,CO VE<U>& a = VE<U>());IN VO Set(CO VE<U>& a);IN VO RightMultiply(CRI i,CO U& u);IN VO LeftMultiply(CRI i,CO U& u);IN U RightIntervalProduct(CRI i,int j);IN U LeftIntervalProduct(CRI i,int j);ll CountRightIntervalProductInverseImage(CO U& u = One());ll CountLeftIntervalProductInverseImage(CO U& u = One());TE <TY F,SFINAE_FOR_CP_BS = nullptr> int RightBinarySearch(CRI i_start,CO F& f);TE <TY F,SFINAE_FOR_CP_BS = nullptr> int LeftBinarySearch(CRI i_start,CO F& f);int RightBinarySearch(CRI i_start,CO U& u);int LeftBinarySearch(CRI i_start,CO U& u);IN int Parent(CRI i);IN int LCA(CRI i,CRI j);IN CO U& One()CO;};TE <TY GROUP> AbstractCumulativeProduct(GROUP M)-> AbstractCumulativeProduct<inner_t<GROUP>,GROUP>;TE <TY U>CL CumulativeSum:PU AbstractCumulativeProduct<U,AdditiveGroup<U>>{PU:IN CumulativeSum(CRI SZ = 0);IN CumulativeSum(CO VE<U>& a);IN VO Add(CRI i,CO U& u);IN U IntervalSum(CRI i,int j);ll CountIntervalSumInverseImage(CO U& u = U());TE <TY F> int BinarySearch(CRI i_start,CO F& f);};
TE <TY U,TY GROUP> IN PathProductImplementation<U,GROUP>::PathProductImplementation(CRI SZ,GROUP M):m_SZ(SZ),m_M(MO(M)),m_right(m_SZ,m_M.One()),m_left(m_right){}TE <TY U,TY GROUP> IN AbstractCumulativeProduct<U,GROUP>::AbstractCumulativeProduct(GROUP M,CO VE<U>& a):PathProductImplementation<U,GROUP>(a.SZ(),MO(M)){if(!a.empty()){TH->m_right[0]= TH->m_left[0]= a[0];for(int i = 1;i < TH->m_SZ;i++){TH->m_right[i]= TH->m_M.Product(TH->m_right[i-1],a[i]);TH->m_left[i]= TH->m_M.Product(a[i],TH->m_left[i-1]);}}}TE <TY U> IN CumulativeSum<U>::CumulativeSum(CRI SZ):CumulativeSum(VE<U>(SZ)){}TE <TY U> IN CumulativeSum<U>::CumulativeSum(CO VE<U>& a):AbstractCumulativeProduct<U,AdditiveGroup<U>>(AdditiveGroup<U>(),a){}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::Set(CO VE<U>& a){*TH = AbstractCumulativeProduct(MO(TH->m_M),a);}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::RightMultiply(CRI i,CO U& u){CO U m_right_i_inv = TH->m_M.Inverse(TH->m_right[i]);CO U& m_right_i = TH->m_right[i]= TH->m_M.Product(TH->m_right[i],u);for(int j = i + 1;j < TH->m_SZ;j++){TH->m_right[j]= TH->m_M.Product(m_right_i,TH->m_M.Product(m_right_i_inv,TH->m_right[j]));}CO U m_left_i_prev_inv = i == TH->m_SZ - 1?One():TH->m_M.Inverse(TH->m_left[i-1]);CO U m_left_i_prev = TH->m_M.Product(u,TH->m_left[i-1]);for(int j = i + 1;j < TH->m_SZ;j++){TH->m_left[j]= TH->m_M.Product(TH->m_M.Product(TH->m_left[j],m_left_i_prev_inv),m_left_i_prev);}}TE <TY U,TY GROUP> IN VO AbstractCumulativeProduct<U,GROUP>::LeftMultiply(CRI i,CO U& u){CO U m_right_i_prev_inv = i == 0?One():TH->m_M.Inverse(TH->m_right[i-1]);CO U m_right_i_prev = i == 0?u:TH->m_M.Product(TH->m_right[i-1],u);for(int j = i;j < TH->m_SZ;j++){TH->m_right[j]= TH->m_M.Product(m_right_i_prev,TH->m_M.Product(m_right_i_prev_inv,TH->m_right[j]));}CO U m_left_i_inv = TH->m_M.Inverse(TH->m_left[i]);CO U& m_left_i = TH->m_left[i]= TH->m_M.Product(u,TH->m_left[i]);for(int j = i + 1;j < TH->m_SZ;j++){TH->m_left[j]= TH->m_M.Product(TH->m_M.Product(TH->m_left[j],m_left_i_inv),m_left_i);}}TE <TY U> IN VO CumulativeSum<U>::Add(CRI i,CO U& u){TH->RightMultiply(i,u);}TE <TY U,TY GROUP> IN U PathProductImplementation<U,GROUP>::PathProduct(CRI i,CRI j){AS(0 <= i && i < m_SZ && 0 <= j && j < m_SZ);CO int k = TH->LCA(i,j);RE m_M.Product(m_M.Product(m_left[i],m_M.Inverse(m_left[k])),k == 0?m_right[j]:m_M.Product(m_M.Inverse(m_right[TH->Parent(k)]),m_right[j]));}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::RightIntervalProduct(CRI i,int j){j = min(j,TH->m_SZ - 1);RE i <= j?i <= 0?TH->m_right[j]:TH->m_M.Product(TH->m_M.Inverse(TH->m_right[i-1]),TH->m_right[j]):One();}TE <TY U,TY GROUP> IN U AbstractCumulativeProduct<U,GROUP>::LeftIntervalProduct(CRI i,int j){j = min(j,TH->m_SZ - 1);RE i <= j?i <= 0?TH->m_left[j]:TH->m_M.Product(TH->m_left[j],TH->m_M.Inverse(TH->m_left[i - 1])):One();}TE <TY U> IN U CumulativeSum<U>::IntervalSum(CRI i,int j){RE TH->RightIntervalProduct(i,MO(j));}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountRightIntervalProductInverseImage(CO U& u){Map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 0;i < TH->m_SZ;i++){CO U& m_right_i = TH->m_right[i];f.count(m_right_i)== 1?AN += f[m_right_i]:AN;f[TH->m_M.Product(m_right_i,u)]++;}RE AN;}TE <TY U,TY GROUP> ll AbstractCumulativeProduct<U,GROUP>::CountLeftIntervalProductInverseImage(CO U& u){Map<U,ll> f{};f[u]++;ll AN = 0;for(int i = 0;i < TH->m_SZ;i++){CO U& m_left_i = TH->m_left[i];f.count(m_left_i)== 1?AN += f[m_left_i]:AN;f[TH->m_M.Product(u,m_left_i)]++;}RE AN;}TE <TY U> ll CumulativeSum<U>::CountIntervalSumInverseImage(CO U& u){RE TH->CountRightIntervalProductInverseImage(u);}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO F& f){int l = i_start - 1;int r = TH->m_SZ - 1;WH(l + 1 < r){int m =(l + r)/ 2;(f(RightIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> TE <TY F,SFINAE_FOR_CP_BS>int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO F& f){int l = i_start - 1;int r = TH->m_SZ - 1;WH(l + 1 < r){int m =(l + r)/ 2;(f(LeftIntervalProduct(i_start,m),m)?r:l)= m;}RE r;}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::RightBinarySearch(CRI i_start,CO U& u){RE RightBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LeftBinarySearch(CRI i_start,CO U& u){RE LeftBinarySearch(i_start,[&](CO U& prod,CRI i){RE !(prod < u);});}TE <TY U> TE <TY F> int CumulativeSum<U>::BinarySearch(CRI i_start,CO F& f){RE TH->RightBinarySearch(i_start,f);}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::Parent(CRI i){RE i - 1;}TE <TY U,TY GROUP> IN int AbstractCumulativeProduct<U,GROUP>::LCA(CRI i,CRI j){RE min(i,j);}TE <TY U,TY GROUP> IN CO U& AbstractCumulativeProduct<U,GROUP>::One()CO{RE TH->m_M.One();}

