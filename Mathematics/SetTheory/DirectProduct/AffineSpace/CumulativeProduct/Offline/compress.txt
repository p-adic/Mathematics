#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/DirectProduct/AffineSpace/CumulativeProduct/Offline/a_Body.hpp"
#else
TE <TY U1,TY MONOID,TY U2,TY GROUP,TY ARRAY,TY HOM,TY T>CL OfflineCumulativeProduct{PU:MONOID m_M1;GROUP m_M2;ARRAY m_a;HOM& m_h;IN OfflineCumulativeProduct(MONOID M1,GROUP M2,ARRAY a,HOM& h,CO T& dummy);IN VE<U2> TotalIntervalProduct(CO VE<tuple<int,int,T>>& query);};TE <TY MONOID,TY GROUP,TY ARRAY,TY HOM,TY T> OfflineCumulativeProduct(MONOID M1,GROUP M2,ARRAY a,HOM& h,CO T& dummy)-> OfflineCumulativeProduct<inner_t<MONOID>,MONOID,inner_t<GROUP>,GROUP,ARRAY,HOM,T>;
TE <TY U1,TY MONOID,TY U2,TY GROUP,TY ARRAY,TY HOM,TY T> IN OfflineCumulativeProduct<U1,MONOID,U2,GROUP,ARRAY,HOM,T>::OfflineCumulativeProduct(MONOID M1,GROUP M2,ARRAY a,HOM& h,CO T& dummy):m_M1(MO(M1)),m_M2(MO(M2)),m_a(MO(a)),m_h(h){ST_AS(is_same_v<U1,inner_t<MONOID>> && is_same_v<U2,inner_t<GROUP>> && is_invocable_r_v<U1,ARRAY,CRI> && is_invocable_r_v<U2,HOM,CO T&,U1&>);}TE <TY U1,TY MONOID,TY U2,TY GROUP,TY ARRAY,TY HOM,TY T> IN VE<U2> OfflineCumulativeProduct<U1,MONOID,U2,GROUP,ARRAY,HOM,T>::TotalIntervalProduct(CO VE<tuple<int,int,T>>& query){CO int Q = query.SZ();set<tuple<int,int>> event{};for(int q = 0;q < Q;q++){auto&[l,r,t]= query[q];AS(0 <= l && l <= r + 1);event.insert({l - 1,q});event.insert({r,Q + q});}int N = -1;U1 temp = m_M1.One();VE<U2> AN(Q,m_M2.One());for(auto&[i,j]:event){WH(N < i){temp = m_M1.Product(MO(temp),m_a(++N));}CO bool left = j < Q;CO int q = left?j:j - Q;auto&& u = m_h(get<2>(query[q]),temp);AN[q]= left?m_M2.Inverse(u):m_M2.Product(MO(AN[q]),u);}RE AN;}
#endif
