#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/SetTheory/Line/Bounded/Debug/a_Body.hpp"
#else
#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY ABELIAN_GROUP>CL AbstractBIT{PU:ABELIAN_GROUP m_M;int m_SZ;VE<U> m_fenwick;int m_PW;IN AbstractBIT(ABELIAN_GROUP M,CRI SZ = 0);IN AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI i,CO U& u);VO Add(CRI i,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i);IN U Get(CRI i);IN CO U& LSBSegmentSum(CRI j)CO;U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CO U& u);IN int Search(CRI i_start,CO U& u);IN VO COruct();};TE <TY ABELIAN_GROUP,TY...Args> AbstractBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL BIT:PU AbstractBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN BIT(CO Args&... args);};TE <TY U> BIT(CO VE<U>& a)-> BIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();for(int j = 1;j <= m_SZ;j++){U& fenwick_j = m_fenwick[j];int i = j - 1;fenwick_j = a[i];int i_lim = j -(j & -j);WH(i > i_lim){fenwick_j = m_M.Sum(MO(fenwick_j),m_fenwick[i]);i -=(i & -i);}}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::COruct(){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U> TE <TY...Args> IN BIT<U>::BIT(CO Args&... args):AbstractBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){AbstractBIT<U,ABELIAN_GROUP> temp{m_M,args...};m_SZ = temp.m_SZ;m_fenwick = MO(temp.m_fenwick);m_PW = temp.m_PW;}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractBIT<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){int j = i + 1;WH(j <= m_SZ){U& fenwick_j = m_fenwick[j];fenwick_j = m_M.Sum(MO(fenwick_j),u);j +=(j & -j);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractBIT<U,ABELIAN_GROUP>::SZ()CO NE{RE m_SZ;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::OP[](CRI i){AS(0 <= i && i < m_SZ);RE IntervalSum(i,i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::Get(CRI i){RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractBIT<U,ABELIAN_GROUP>::LSBSegmentSum(CRI j)CO{AS(0 < j && j <= m_SZ);RE m_fenwick[j];}TE <TY U,TY ABELIAN_GROUP>U AbstractBIT<U,ABELIAN_GROUP>::InitialSegmentSum(CRI i_final){U sum = m_M.Zero();int j = min(i_final + 1,m_SZ);WH(j > 0){sum = m_M.Sum(MO(sum),m_fenwick[j]);j -= j & -j;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS>int AbstractBIT<U,ABELIAN_GROUP>::Search(CO F& f){int j = 0;int PW = m_PW;U sum = m_M.Zero();U sum_next = sum;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){sum_next = m_M.Sum(MO(sum_next),m_fenwick[j_next]);if(f(sum_next,j_next - 1)){sum_next = sum;}else{sum = sum_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO F& f){CO U u_inv = m_M.Inverse(InitialSegmentSum(i_start - 1));RE max(i_start,Search([&](CO U& sum,CRI i){RE i_start <= i && f(m_M.Sum(u_inv,sum),i);}));}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CO U& u){RE Search([&](CO U& sum,CRI){RE !(sum < u);});}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO U& u){RE max(i_start,Search(m_M.Sum(InitialSegmentSum(i_start - 1),u)));}

TE <TY INT,TE <TY...> TY DATA_STR> CL AbstractBoundedLineSubset;
TE <TY INT,TE <TY...> TY DATA_STR>CL IteratorOfBoundedLineSubset{PU:CO AbstractBoundedLineSubset<INT,DATA_STR>* m_p;INT m_i;PU:IN IteratorOfBoundedLineSubset(CO AbstractBoundedLineSubset<INT,DATA_STR>& S,INT i);IN bool OP==(CO IteratorOfBoundedLineSubset<INT,DATA_STR>& IT)CO NE;IN bool OP!=(CO IteratorOfBoundedLineSubset<INT,DATA_STR>& IT)CO NE;IN INT OP*()CO;IN IteratorOfBoundedLineSubset<INT,DATA_STR>& OP++();IN IteratorOfBoundedLineSubset<INT,DATA_STR> OP++(int);IN IteratorOfBoundedLineSubset<INT,DATA_STR>& OP--();IN IteratorOfBoundedLineSubset<INT,DATA_STR> OP--(int);IN VO Next();IN VO Prev();IN pair<INT,INT> ConnectedComponent()CO;IN IteratorOfBoundedLineSubset<INT,DATA_STR>& erase_from(AbstractBoundedLineSubset<INT,DATA_STR>& S);};
TE <TY INT,TE <TY...> TY DATA_STR>CL AbstractBoundedLineSubset{PU:INT m_lbound;INT m_ubound;DATA_STR<INT> m_ds;IN AbstractBoundedLineSubset(CO INT& lbound,CO INT& ubound);US iterator = IteratorOfBoundedLineSubset<INT,DATA_STR>;IN VO insert(CO INT& i);IN VO erase(CO INT& i);IN iterator& erase(iterator& IT);IN int count(CO INT& i)NE;bool find(CO INT& i)NE;IN int InitialSegmentSZ(CO INT& i_final)NE;IN int IntervalSZ(CO INT& i_start,CO INT& i_final)NE;IN bool empty()NE;IN iterator BE()NE;IN iterator EN()CO NE;IN iterator MaximumLeq(CO INT& i,CRI k = 0)NE;IN iterator MaximumLt(CO INT& i,CRI k = 0)NE;IN iterator MinimumGeq(CO INT& i,CRI k = 0)NE;IN iterator MinimumGt(CO INT& i,CRI k = 0)NE;IN INT Maximum(CRI k = 0);IN INT Minimum(CRI k = 0);INT RightENPointOf(CO INT& i,CO bool& in = false)NE;INT LeftENPointOf(CO INT& i,CO bool& in = false)NE;IN pair<INT,INT> ConnectedComponentOf(CO INT& i,bool in = false)NE;VE<pair<INT,INT>> GetConnectedComponent()NE;IN CO INT& lbound()CO NE;IN CO INT& ubound()CO NE;};
TE <TY INT>US BoundedLineSubset = AbstractBoundedLineSubset<INT,BIT>;
TE <TY INT,TE <TY...> TY DATA_STR> IN AbstractBoundedLineSubset<INT,DATA_STR>::AbstractBoundedLineSubset(CO INT& lbound,CO INT& ubound):m_lbound(lbound),m_ubound(ubound),m_ds(m_ubound - m_lbound + 1){AS(m_lbound <= m_ubound + 1);}TE <TY INT,TE <TY...> TY DATA_STR> IN VO AbstractBoundedLineSubset<INT,DATA_STR>::insert(CO INT& i){AS(m_lbound <= i && i <= m_ubound);m_ds.Set(i - m_lbound,1);}TE <TY INT,TE <TY...> TY DATA_STR> IN VO AbstractBoundedLineSubset<INT,DATA_STR>::erase(CO INT& i){m_ds.Set(i - m_lbound,0);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR>& AbstractBoundedLineSubset<INT,DATA_STR>::erase(IteratorOfBoundedLineSubset<INT,DATA_STR>& IT){RE IT.erase_from(*TH);}TE <TY INT,TE <TY...> TY DATA_STR> IN int AbstractBoundedLineSubset<INT,DATA_STR>::count(CO INT& i)NE{RE m_lbound <= i && i <= m_ubound?m_ds[i - m_lbound]:0;}TE <TY INT,TE <TY...> TY DATA_STR> IN bool AbstractBoundedLineSubset<INT,DATA_STR>::find(CO INT& i)NE{RE count(i)== 1;}TE <TY INT,TE <TY...> TY DATA_STR> IN int AbstractBoundedLineSubset<INT,DATA_STR>::InitialSegmentSZ(CO INT& i_final)NE{RE m_ds.InitialSegmentSum(i_final - m_lbound);}TE <TY INT,TE <TY...> TY DATA_STR> IN int AbstractBoundedLineSubset<INT,DATA_STR>::IntervalSZ(CO INT& i_start,CO INT& i_final)NE{RE m_ds.IntervalSum(i_start - m_lbound,i_final - m_lbound);}TE <TY INT,TE <TY...> TY DATA_STR> IN bool AbstractBoundedLineSubset<INT,DATA_STR>::empty()NE{RE InitialSegmentSZ(m_ubound)== 0;}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::BE()NE{RE MinimumGeq(m_lbound);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::EN()CO NE{RE IteratorOfBoundedLineSubset<INT,DATA_STR>(*TH,m_ubound + 1);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::MaximumLeq(CO INT& i,CRI k)NE{CO INT num = InitialSegmentSZ(i)- k;CO INT l = m_ds.Search([&](CO INT& sum,CRI j){RE num <= sum;})+ m_lbound;RE num >= 0 && find(l)?IteratorOfBoundedLineSubset<INT,DATA_STR>{*TH,l}:EN();}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::MaximumLt(CO INT& i,CRI k)NE{RE MaximumLeq(i - 1,k);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::MinimumGeq(CO INT& i,CRI k)NE{RE MinimumGt(i - 1,k);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> AbstractBoundedLineSubset<INT,DATA_STR>::MinimumGt(CO INT& i,CRI k)NE{CO INT num = InitialSegmentSZ(i)+ k;CO INT r = m_ds.Search([&](CO INT& sum,CRI j){RE num < sum;})+ m_lbound;RE find(r)?IteratorOfBoundedLineSubset<INT,DATA_STR>{*TH,r}:EN();}TE <TY INT,TE <TY...> TY DATA_STR> IN INT AbstractBoundedLineSubset<INT,DATA_STR>::Maximum(CRI k){RE MaximumLeq(m_ubound,k);}TE <TY INT,TE <TY...> TY DATA_STR> IN INT AbstractBoundedLineSubset<INT,DATA_STR>::Minimum(CRI k){RE MinimumGeq(m_lbound,k);}TE <TY INT,TE <TY...> TY DATA_STR>INT AbstractBoundedLineSubset<INT,DATA_STR>::RightENPointOf(CO INT& i,CO bool& in)NE{if(!in && !find(i)){RE i - 1;}CO int d = i - m_lbound;CO INT comp_minus = d - InitialSegmentSZ(i);RE m_ds.Search([&](CO INT& sum,CRI j){RE d <= j && sum + comp < j;})+ m_lbound - 1;}TE <TY INT,TE <TY...> TY DATA_STR>INT AbstractBoundedLineSubset<INT,DATA_STR>::LeftENPointOf(CO INT& i,CO bool& in)NE{if(!in && !find(i)){RE i + 1;}CO int d = i - m_lbound;CO INT comp_minus = d - InitialSegmentSZ(i);RE m_ds.Search([&](CO INT& sum,CRI j){RE d <= j ||(find(j)&& sum + comp == j);})+ m_lbound;}TE <TY INT,TE <TY...> TY DATA_STR> IN pair<INT,INT> AbstractBoundedLineSubset<INT,DATA_STR>::ConnectedComponentOf(CO INT& i,bool in)NE{if(!in){in = find(i);}RE{LeftENPointOf(i,in),RightENPointOf(i,in)};}TE <TY INT,TE <TY...> TY DATA_STR>VE<pair<INT,INT>> AbstractBoundedLineSubset<INT,DATA_STR>::GetConnectedComponent()NE{VE<pair<INT,INT>> AN{};INT r;for(auto IT = BE();*IT <= m_ubound;IT = MinimumGt(r)){AN.push_back({*IT,r = RightENPointOf(*IT)});}RE AN;}TE <TY INT,TE <TY...> TY DATA_STR> IN CO INT& AbstractBoundedLineSubset<INT,DATA_STR>::lbound()CO NE{RE m_lbound;}TE <TY INT,TE <TY...> TY DATA_STR> IN CO INT& AbstractBoundedLineSubset<INT,DATA_STR>::ubound()CO NE{RE m_ubound;}
TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR>::IteratorOfBoundedLineSubset(CO AbstractBoundedLineSubset<INT,DATA_STR>& S,INT i):m_p(&S),m_i(MO(i)){}TE <TY INT,TE <TY...> TY DATA_STR> IN bool IteratorOfBoundedLineSubset<INT,DATA_STR>::OP==(CO IteratorOfBoundedLineSubset<INT,DATA_STR>& IT)CO NE{RE m_p == IT.m_p && m_i == IT.m_i;}TE <TY INT,TE <TY...> TY DATA_STR> IN bool IteratorOfBoundedLineSubset<INT,DATA_STR>::OP!=(CO IteratorOfBoundedLineSubset<INT,DATA_STR>& IT)CO NE{RE !(*TH == IT);}TE <TY INT,TE <TY...> TY DATA_STR> IN INT IteratorOfBoundedLineSubset<INT,DATA_STR>::OP*()CO{RE m_i;}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR>& IteratorOfBoundedLineSubset<INT,DATA_STR>::OP++(){AS(m_i <= m_p->ubound);RE *TH = m_p->MinimumGt(m_i);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> IteratorOfBoundedLineSubset<INT,DATA_STR>::OP++(int){auto IT = *TH;++(*TH);RE IT;}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR>& IteratorOfBoundedLineSubset<INT,DATA_STR>::OP--(){AS(m_p->BE().m_i <= m_i);RE *TH = m_p->MaximumLt(m_i);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR> IteratorOfBoundedLineSubset<INT,DATA_STR>::OP--(int){auto IT = *TH;--(*TH);RE IT;}TE <TY INT,TE <TY...> TY DATA_STR> IN VO IteratorOfBoundedLineSubset<INT,DATA_STR>::Next(){AS(m_i < m_p->ubound);CO INT r = m_p->RightENPointOf(m_i);*TH = m_i <= r?m_p->MinimumGt(r):m_p->EN();}TE <TY INT,TE <TY...> TY DATA_STR> IN VO IteratorOfBoundedLineSubset<INT,DATA_STR>::Prev(){AS(m_p->lbound < m_i);CO INT l = m_p->LeftENPointOf(m_i);*TH = l <= m_i?m_p->MaximumLt(l):m_p->EN();}TE <TY INT,TE <TY...> TY DATA_STR> IN pair<INT,INT> IteratorOfBoundedLineSubset<INT,DATA_STR>::ConnectedComponent()CO{RE m_p->ConnectedComponentOf(m_i);}TE <TY INT,TE <TY...> TY DATA_STR> IN IteratorOfBoundedLineSubset<INT,DATA_STR>& IteratorOfBoundedLineSubset<INT,DATA_STR>::erase_from(AbstractBoundedLineSubset<INT,DATA_STR>& S){AS(&S == m_p);auto IT_copy =(*TH)++;S.erase(IT_copy);RE *TH;}
#endif
