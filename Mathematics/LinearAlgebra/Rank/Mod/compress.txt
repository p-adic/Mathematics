#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/LinearAlgebra/Rank/Mod/Debug/a_Body.hpp"
#else
#define DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_MOD(DECL_J)CO MODINT& zero = MODINT::zero();CO int M_N = L == 0?0:A[0].SZ(),M = M_N - N;AS(M >= 0);int rank = RowEchelonForm(A);VE<bool> solvable(N,true);int i = rank;WH(--i >= 0){auto& A_i = A[i];DECL_J;WH(++j < M){if(A_i[j]!= zero){break;}}if(j == M){WH(j < M_N){solvable[j]= solvable[j]&& A_i[j]== zero;j++;}rank--;}else{int i_curr = i;WH(--i_curr >= 0){auto& A_i_curr = A[i_curr];CO MODINT A_i_curr_j = A_i_curr[j];for(int j_curr = j;j_curr < M_N;j_curr++){A_i_curr[j_curr]-= A_i_curr_j * A_i[j_curr];}}}}
TE <TY MODINT>int RowEchelonForm(VE<VE<MODINT>>& A){CO MODINT& zero = MODINT::zero();CO int L = A.SZ(),M = L == 0?0:A[0].SZ();int i_min = 0,i_curr,j_curr = 0;WH(i_min < L && j_curr < M){i_curr = i_min;WH(i_curr < L && A[i_curr][j_curr]== zero){i_curr++;}if(i_curr < L){swap(A[i_min],A[i_curr]);auto& A_i_min = A[i_min];MODINT inv = 1 / A_i_min[j_curr];for(int j = j_curr;j < M;j++){A_i_min[j]*= inv;}for(int i = i_min + 1;i < L;i++){auto& A_i = A[i];CO MODINT& A_i_j_curr = A_i[j_curr];if(A_i_j_curr != zero){for(int j = M - 1;j >= j_curr;j--){A_i[j]-= A_i_j_curr * A_i_min[j];}}}i_min++;}j_curr++;}RE i_min;}TE <TY MODINT>pair<int,VE<MODINT>> ExtendedReducedRowEchelonForm(VE<VE<MODINT>>& A){CO int L = A.SZ();CE int N = 1;VE<int> left(L,-1);DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_MOD(int& j = left[i]);VE<MODINT> solution{};if(solvable[0]){solution.resize(M);i = rank;WH(--i >= 0){auto& A_i = A[i];CRI j = left[i];solution[j]= A_i[M];}}RE{rank,MO(solution)};}TE <TY MODINT>tuple<int,VE<bool>,VE<VE<MODINT>>> MultiExtendedReducedRowEchelonForm(VE<VE<MODINT>>& A,CRI N){CO int L = A.SZ();VE<int> left(L,-1);DF_OF_EXTENED_REDUCED_ROW_ECHELON_FORM_FOR_MOD(int& j = left[i]);VE<VE<MODINT>> solutions(M,VE<MODINT>(N));i = rank;WH(--i >= 0){auto& A_i = A[i];CRI j = left[i];auto& solutions_j = solutions[j];for(int k = 0;k < N;k++){solutions_j[k]= A_i[M + k];}}RE{rank,MO(solvable),MO(solutions)};}TE <TY MODINT> IN int ReducedRowEchelonForm(VE<VE<MODINT>>& A){RE get<0>(MultiExtendedReducedRowEchelonForm(A,0));}TE <TY MODINT>VE<VE<MODINT>> Inverse(CO VE<VE<MODINT>>& A){CO int L = A.SZ();VE A_copy(L,VE<MODINT>(L + L));for(int i = 0;i < L;i++){auto& A_i = A[i];auto& A_copy_i = A_copy[i];for(int j = 0;j < L;j++){A_copy_i[j]= A_i[j];}for(int j = 0;j < L;j++){A_copy_i[L + j]= i == j?1:0;}}auto[rank,solvable,AN]= MultiExtendedReducedRowEchelonForm(A_copy,AN,L);if(rank != L){AN.clear();}RE AN;}TE <TY MODINT>pair<int,VE<MODINT>> LinearRelation(VE<VE<MODINT>>& A){CO int L = A.SZ();CO int M = A.empty()?0:A[0].SZ();CO int rank = ReducedRowEchelonForm(A);VE<MODINT> coeff{};if(rank < M){coeff.resize(M);CO MODINT& zero = MODINT::zero();int j = 0;WH(j < L && A[j][j]!= zero){j++;}for(int i = 0;i < j;i++){coeff[i]= -A[i][j];}coeff[j]= 1;}RE{rank,MO(coeff)};}
#endif

