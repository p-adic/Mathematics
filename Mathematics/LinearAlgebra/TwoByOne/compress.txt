#define TTMA TwoByTwoMatrix
#define SFINAE_FOR_MA(DEFAULT)TY Arg,enable_if_t<is_COructible_v<T,Arg>>* DEFAULT
TE <TY T>CL TTMA{PU:T m_M00;T m_M01;T m_M10;T m_M11;CE TTMA(T M00,T M01,T M10,T M11)NE;CE TTMA(CO T& scalar = T())NE;TE <SFINAE_FOR_MA(= nullptr)> CE TTMA(CO Arg& scalar)NE;CE TTMA(CO TTMA<T>& mat)NE;CE TTMA(TTMA<T>&& mat)NE;CE TTMA<T>& OP=(TTMA<T> mat)NE;CE TTMA<T>& OP+=(CO TTMA<T>& mat)NE;CE TTMA<T>& OP-=(CO TTMA<T>& mat)NE;CE TTMA<T>& OP*=(CO TTMA<T>& mat)NE;CE TTMA<T>& OP*=(CO T& scalar)NE;TE <SFINAE_FOR_MA(= nullptr)> CE TTMA<T>& OP*=(CO Arg& scalar)NE;IN TTMA<T>& OP/=(CO TTMA<T>& mat);IN TTMA<T>& OP/=(CO T& scalar);TE <SFINAE_FOR_MA(= nullptr)> IN TTMA<T>& OP/=(CO Arg& scalar);IN TTMA<T>& OP%=(CO T& scalar);IN TTMA<T>& Invert();IN TTMA<T> Inverse()CO;CE bool OP==(CO TTMA<T>& mat)CO NE;CE bool OP!=(CO TTMA<T>& mat)CO NE;CE TTMA<T> OP+(TTMA<T> mat)CO NE;CE TTMA<T> OP-()CO NE;CE TTMA<T> OP-(CO TTMA<T>& mat)CO NE;CE TTMA<T> OP*(CO TTMA<T>& mat)CO NE;TE <SFINAE_FOR_MA(= nullptr)> CE TTMA<T> OP*(CO Arg& scalar)CO NE;IN TTMA<T> OP/(CO TTMA<T>& mat)CO;TE <SFINAE_FOR_MA(= nullptr)> IN TTMA<T> OP/(CO Arg& scalar)CO;IN TTMA<T> OP%(CO T& scalar)CO;TE <TY INT> CE TTMA<T> OP^(INT EX)CO;CE T tr()CO NE;CE T det()CO NE;CE VO swap(TTMA<T>& mat)NE;CE CO T& Get(CRUI y,CRUI x)CO NE;CE T& Ref(CRUI y,CRUI x)NE;CE TTMA<T> Square()CO NE;};
TE <TY T,SFINAE_FOR_MA(= nullptr)> CE TTMA<T> OP*(CO Arg& scalar,CO TTMA<T>& mat)NE;TE <TY T,TY INT> CE TTMA<T> PW(CO TTMA<T>& mat,INT EX)NE;TE <TY T> CE VO swap(TTMA<T>& mat1,TTMA<T>& mat2)NE;TE <TY T> CE TTMA<T>::TTMA(T M00,T M01,T M10,T M11)NE:m_M00(MO(M00)),m_M01(MO(M01)),m_M10(MO(M10)),m_M11(MO(M11)){}TE <TY T> CE TTMA<T>::TTMA(CO T& scalar)NE:m_M00(scalar),m_M01(),m_M10(),m_M11(scalar){}TE <TY T> TE <SFINAE_FOR_MA()> CE TTMA<T>::TTMA(CO Arg& scalar)NE:TTMA(T(scalar)){}TE <TY T> CE TTMA<T>::TTMA(CO TTMA<T>& mat)NE:m_M00(mat.m_M00),m_M01(mat.m_M01),m_M10(mat.m_M10),m_M11(mat.m_M11){}TE <TY T> CE TTMA<T>::TTMA(TTMA<T>&& mat)NE:m_M00(MO(mat.m_M00)),m_M01(MO(mat.m_M01)),m_M10(MO(mat.m_M10)),m_M11(MO(mat.m_M11)){}TE <TY T> CE TTMA<T>& TTMA<T>::OP=(TTMA<T> mat)NE{m_M00 = MO(mat.m_M00);m_M01 = MO(mat.m_M01);m_M10 = MO(mat.m_M10);m_M11 = MO(mat.m_M11);RE *TH;}TE <TY T> CE TTMA<T>& TTMA<T>::OP+=(CO TTMA<T>& mat)NE{m_M00 += mat.m_M00;m_M01 += mat.m_M01;m_M10 += mat.m_M10;m_M11 += mat.m_M11;RE *TH;}TE <TY T> CE TTMA<T>& TTMA<T>::OP-=(CO TTMA<T>& mat)NE{m_M00 -= mat.m_M00;m_M01 -= mat.m_M01;m_M10 -= mat.m_M10;m_M11 -= mat.m_M11;RE *TH;}TE <TY T> CE TTMA<T>& TTMA<T>::OP*=(CO TTMA<T>& mat)NE{RE *TH = *TH * mat;}TE <TY T> CE TTMA<T>& TTMA<T>::OP*=(CO T& scalar)NE{m_M00 *= scalar;m_M01 *= scalar;m_M10 *= scalar;m_M11 *= scalar;RE *TH;}TE <TY T> TE <SFINAE_FOR_MA()> CE TTMA<T>& TTMA<T>::OP*=(CO Arg& scalar)NE{RE *TH *= T(scalar);}TE <TY T> IN TTMA<T>& TTMA<T>::OP/=(CO TTMA<T>& mat){RE *TH = *TH / mat;}TE <TY T> IN TTMA<T>& TTMA<T>::OP/=(CO T& scalar){RE *TH *= T(1)/ scalar;}TE <TY T> TE <SFINAE_FOR_MA()> IN TTMA<T>& TTMA<T>::OP/=(CO Arg& scalar){RE *TH /= T(scalar);}TE <TY T> IN TTMA<T>& TTMA<T>::OP%=(CO T& scalar){m_M00 %= scalar;m_M01 %= scalar;m_M10 %= scalar;m_M11 %= scalar;RE *TH;}TE <TY T> IN TTMA<T>& TTMA<T>::Invert(){swap(m_M00,m_M11);m_M01 = -m_M01;m_M10 = -m_M10;RE *TH /= det();}TE <TY T> TTMA<T> TTMA<T>::Inverse()CO{RE MO(TTMA<T>(*TH).invert());}TE <TY T> CE bool TTMA<T>::OP==(CO TTMA<T>& mat)CO NE{RE m_M00 == mat.m_M00 && m_M01 == mat.m_M01 && m_M10 == mat.m_M10 && m_M11 == mat.m_M11;}TE <TY T> CE bool TTMA<T>::OP!=(CO TTMA<T>& mat)CO NE{RE !(*TH == mat);}TE <TY T> CE TTMA<T> TTMA<T>::OP+(TTMA<T> mat)CO NE{RE MO(mat += *TH);}TE <TY T> CE TTMA<T> TTMA<T>::OP-()CO NE{RE TTMA<T>(-m_M00,-m_M01,-m_M10,-m_M11);}TE <TY T> CE TTMA<T> TTMA<T>::OP-(CO TTMA<T>& mat)CO NE{RE MO(-mat += *TH);}TE <TY T> CE TTMA<T> TTMA<T>::OP*(CO TTMA<T>& mat)CO NE{RE TTMA<T>(m_M00 * mat.m_M00 + m_M01 * mat.m_M10,m_M00 * mat.m_M01 + m_M01 * mat.m_M11,m_M10 * mat.m_M00 + m_M11 * mat.m_M10,m_M10 * mat.m_M01 + m_M11 * mat.m_M11);}TE <TY T> TE <SFINAE_FOR_MA()> CE TTMA<T> TTMA<T>::OP*(CO Arg& scalar)CO NE{RE MO(TTMA<T>(*TH)*= scalar);}TE <TY T> IN TTMA<T> TTMA<T>::OP/(CO TTMA<T>& mat)CO{CO T det_inv{T(1)/(mat.m_M00 * mat.m_M11 - mat.m_M01 * mat.m_M10)};RE TTMA<T>((m_M00 * mat.m_M11 - m_M01 * mat.m_M10)* det_inv,(m_M01 * mat.m_M00 - m_M00 * mat.m_M01)* det_inv,(m_M10 * mat.m_M11 - m_M11 * mat.m_M10)* det_inv,(m_M11 * mat.m_M00 - m_M10 * mat.m_M01)* det_inv);}TE <TY T> TE <SFINAE_FOR_MA()> IN TTMA<T> TTMA<T>::OP/(CO Arg& scalar)CO{RE MO(TTMA<T>(*TH)/= scalar);}TE <TY T> IN TTMA<T> TTMA<T>::OP%(CO T& scalar)CO{RE MO(TTMA<T>(*TH)%= scalar);}TE <TY T> TE <TY INT> CE TTMA<T> TTMA<T>::OP^(INT EX)CO{TTMA<T> AN{1},PW{*TH};EX < 0?(EX *= -1,PW.Invert()):*TH;WH(EX > 0){(EX & 1)== 1?AN *= PW:AN;PW = PW.Square();EX >>= 1;}RE AN;}TE <TY T> CE TTMA<T> TTMA<T>::Square()CO NE{RE TTMA<T>(m_M00 * m_M00 + m_M01 * m_M10,(m_M00 + m_M11)* m_M01,m_M10 *(m_M00 + m_M11),m_M10 * m_M01 + m_M11 * m_M11);}TE <TY T> CE T TTMA<T>::tr()CO NE{RE m_M00 + m_M11;}TE <TY T> CE T TTMA<T>::det()CO NE{RE m_M00 * m_M11 - m_M01 * m_M10;}TE <TY T> CE VO TTMA<T>::swap(TTMA<T>& mat)NE{std::swap(m_M00,mat.m_M00);std::swap(m_M01,mat.m_M01);std::swap(m_M10,mat.m_M10);std::swap(m_M11,mat.m_M11);}TE <TY T> CE CO T& TTMA<T>::Get(CRUI y,CRUI x)CO NE{RE y == 0?x == 0?m_M00:m_M01:x == 0?m_M10:m_M11;}TE <TY T> CE T& TTMA<T>::Ref(CRUI y,CRUI x)NE{RE y == 0?x == 0?m_M00:m_M01:x == 0?m_M10:m_M11;}TE <TY T,SFINAE_FOR_MA()> CE TTMA<T> OP*(CO Arg& scalar,CO TTMA<T>& mat)NE{RE MO(TTMA<T>(mat)*= scalar);}TE <TY T,TY INT> CE TTMA<T> PW(CO TTMA<T>& mat,INT EX)NE{RE mat ^ MO(EX);}TE <TY T> CE VO swap(TTMA<T>& mat1,TTMA<T>& mat2)NE{mat1.swap(mat2);}

#define TOMA TwoByOneMatrix
TE <TY T>CL TOMA{PU:T m_M0;T m_M1;CE TOMA(T M0 = T(),T M1 = T())NE;CE TOMA(CO TOMA<T>& mat)NE;CE TOMA(TOMA<T>&& mat)NE;CE TOMA<T>& OP=(TOMA<T> mat)NE;CE TOMA<T>& OP+=(CO TOMA<T>& mat)NE;CE TOMA<T>& OP-=(CO TOMA<T>& mat)NE;CE TOMA<T>& OP*=(CO T& scalar)NE;IN TOMA<T>& OP/=(CO T& scalar);IN TOMA<T>& OP%=(CO T& scalar);CE TOMA<T>& Act(CO TTMA<T>& mat)NE;CE TOMA<T> Action(CO TTMA<T>& mat)CO NE;CE TOMA<T> OP+(TOMA<T> mat)CO NE;CE TOMA<T> OP-(TOMA<T> mat)CO NE;CE TOMA<T> OP*(CO T& scalar)CO NE;IN TOMA<T> OP/(CO T& scalar)CO;IN TOMA<T> OP%(CO T& scalar)CO;CE CO T& Get(CRUI y)CO NE;CE T& Ref(CRUI y)NE;};
TE <TY T> CE TOMA<T>::TOMA(T M0,T M1)NE:m_M0(MO(M0)),m_M1(MO(M1)){}TE <TY T> CE TOMA<T>::TOMA(CO TOMA<T>& mat)NE:m_M0(mat.m_M0),m_M1(mat.m_M1){}TE <TY T> CE TOMA<T>::TOMA(TOMA<T>&& mat)NE:m_M0(MO(mat.m_M0)),m_M1(MO(mat.m_M1)){}TE <TY T> CE TOMA<T>& TOMA<T>::OP=(TOMA<T> mat)NE{m_M0 = MO(mat.m_M0);m_M1 = MO(mat.m_M1);RE *TH;}TE <TY T> CE TOMA<T>& TOMA<T>::OP+=(CO TOMA<T>& mat)NE{m_M0 += mat.m_M0;m_M1 += mat.m_M1;RE *TH;}TE <TY T> CE TOMA<T>& TOMA<T>::OP-=(CO TOMA<T>& mat)NE{m_M0 -= mat.m_M0;m_M1 -= mat.m_M1;RE *TH;}TE <TY T> CE TOMA<T>& TOMA<T>::OP*=(CO T& scalar)NE{m_M0 *= scalar;m_M1 *= scalar;RE *TH;}TE <TY T> IN TOMA<T>& TOMA<T>::OP/=(CO T& scalar){m_M0 /= scalar;m_M1 /= scalar;RE *TH;}TE <TY T> IN TOMA<T>& TOMA<T>::OP%=(CO T& scalar){m_M0 %= scalar;m_M1 %= scalar;RE *TH;}TE <TY T> CE TOMA<T>& TOMA<T>::Act(CO TTMA<T>& mat)NE{RE *TH = Action(mat);}TE <TY T> CE TOMA<T> TOMA<T>::Action(CO TTMA<T>& mat)CO NE{RE TOMA<T>(mat.m_M00 * m_M0 + mat.m_M01 * m_M1,mat.m_M10 * m_M0 + mat.m_M11 * m_M1);}TE <TY T> CE TOMA<T> TOMA<T>::OP+(TOMA<T> mat)CO NE{RE MO(mat += *TH);}TE <TY T> CE TOMA<T> TOMA<T>::OP-(TOMA<T> mat)CO NE{RE MO(mat -= *TH);}TE <TY T> CE TOMA<T> TOMA<T>::OP*(CO T& scalar)CO NE{RE MO(TOMA<T>(*TH)*= scalar);}TE <TY T> IN TOMA<T> TOMA<T>::OP/(CO T& scalar)CO{RE MO(TOMA<T>(*TH)/ scalar);}TE <TY T> IN TOMA<T> TOMA<T>::OP%(CO T& scalar)CO{RE MO(TOMA<T>(*TH)% scalar);}TE <TY T> CE CO T& TOMA<T>::Get(CRUI y)CO NE{RE y == 0?m_M0:m_M1;}TE <TY T> CE T& TOMA<T>::Ref(CRUI y)NE{RE y == 0?m_M0:m_M1;}TE <TY T> CE TOMA<T> OP*(CO TTMA<T>& mat1,CO TOMA<T>& mat2)NE{RE mat2.Action(mat1);}
