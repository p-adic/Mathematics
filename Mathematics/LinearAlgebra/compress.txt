TE <TY T>using TT = VE<VE<T> >;TE <uint Y,uint X,TY T>class MA{PR:TT<T> m_M;PU:IN MA(CO T& t = T()) NE;IN MA(CO int& t) NE;TE <TY... Args> IN MA(CO T& t0,CO T& t1,CO Args&... args) NE;TE <TY... Args> IN MA(T&& t0,T&& t1,Args&&... args) NE;IN MA(CO MA<Y,X,T>& mat) NE;IN MA(MA<Y,X,T>&& mat) NE;TE <TY... Args> IN MA(CO TT<T>& M) NE;TE <TY... Args> IN MA(TT<T>&& M) NE;IN MA<Y,X,T>& operator=(CO MA<Y,X,T>& mat) NE;IN MA<Y,X,T>& operator=(MA<Y,X,T>&& mat) NE;MA<Y,X,T>& operator+=(CO MA<Y,X,T>& mat);MA<Y,X,T>& operator-=(CO MA<Y,X,T>& mat);MA<Y,X,T>& operator*=(CO T& scalar) NE;IN MA<Y,X,T>& operator*=(CO MA<X,X,T>& mat) NE;MA<Y,X,T>& operator%=(CO T& scalar) NE;IN TT<T>& RefTable() NE;IN CO TT<T>& GetTable() CO NE;ST IN CO MA<Y,X,T>& Zero() NE;ST IN CO MA<Y,X,T>& Unit() NE;ST MA<Y,X,T> Scalar(CO T& t) NE;PR:ST IN void COructTable(TT<T>& M,VE<T>& vec) NE;TE <TY... Args> ST void COructTable(TT<T>& M,VE<T>& vec,CO T& t,CO Args&... args) NE;TE <TY... Args> ST void COructTable(TT<T>& M,VE<T>& vec,T&& t,Args&&... args) NE;ST MA<Y,X,T> Zero_Body() NE;};TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator==(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) NE;TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator!=(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) NE;TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator+(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2);TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator-(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2);TE <uint Y,uint X,uint Z,TY T>MA<Y,Z,T> operator*(CO MA<Y,X,T>& mat1,CO MA<X,Z,T>& mat2);TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator*(CO MA<Y,X,T>& mat,CO T& scalar);TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator*(CO T& scalar,CO MA<Y,X,T>& mat);TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator%(CO MA<Y,X,T>& mat,CO T& scalar);TE <uint Y,uint X,TY T>MA<X,Y,T> Transpose(CO MA<Y,X,T>& mat);TE <uint X,TY T>T Trace(CO MA<X,X,T>& mat);TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CO T& t) NE:m_M() { operator=(MO(Scalar(t))); }TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CO int& t) NE:MA(T(t)) {}TE <uint Y,uint X,TY T> TE <TY... Args>MA<Y,X,T>::MA(CO T& t0,CO T& t1,CO Args&... args) NE: m_M(){VE<T> vec{};COructTable(m_M,vec,t0,t1,args...);}TE <uint Y,uint X,TY T> TE <TY... Args>MA<Y,X,T>::MA(T&& t0,T&& t1,Args&&... args) NE: m_M(){VE<T> vec{};COructTable(m_M,vec,MO(t0),MO(t1),MO(args)...);}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(CO MA<Y,X,T>& mat) NE:m_M(mat.m_M) {}TE <uint Y,uint X,TY T> IN MA<Y,X,T>::MA(MA<Y,X,T>&& mat) NE:m_M(MO(mat.m_M)) {}TE <uint Y,uint X,TY T> TE <TY... Args> IN MA<Y,X,T>::MA(CO TT<T>& M) NE:m_M(M) {}TE <uint Y,uint X,TY T> TE <TY... Args> IN MA<Y,X,T>::MA(TT<T>&& M) NE:m_M(MO(M)) {}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::operator=(CO MA<Y,X,T>& mat) NE { m_M = mat.m_M; RE *this; }TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::operator=(MA<Y,X,T>&& mat) NE { m_M = move(mat.m_M); RE *this; }TE <uint Y,uint X,TY T>MA<Y,X,T>& MA<Y,X,T>::operator+=(CO MA<Y,X,T>& mat){auto I1y = m_M.begin(),end1y = m_M.end();auto I2y = mat.m_M.begin(); WH(I1y != end1y){auto I1xy = I1y->begin(),end1xy = I1y->end();auto I2xy = I2y->begin(); WH(I1xy != end1xy){*I1xy += *I2xy;I1xy++;I2xy++;}I1y++;I2y++;}RE *this;}TE <uint Y,uint X,TY T>MA<Y,X,T>& MA<Y,X,T>::operator-=(CO MA<Y,X,T>& mat){auto I1y = m_M.begin(),end1y = m_M.end();auto I2y = mat.m_M.begin(); WH(I1y != end1y){auto I1xy = I1y->begin(),end1xy = I1y->end();auto I2xy = I2y->begin(); WH(I1xy != end1xy){*I1xy -= *I2xy;I1xy++;I2xy++;}I1y++;I2y++;}RE *this;}TE <uint Y,uint X,TY T> MA<Y,X,T>& MA<Y,X,T>::operator*=(CO T& scalar) NE{for(auto Iy = m_M.begin(),endy = m_M.end();Iy != endy;Iy++){for(auto Ixy = Iy->begin(),endxy = Iy->end();Ixy != endxy;Ixy++){*Ixy *= scalar;}}RE *this;}TE <uint Y,uint X,TY T> IN MA<Y,X,T>& MA<Y,X,T>::operator*=(CO MA<X,X,T>& mat) NE { RE operator=(MO(*this * mat)); }TE <uint Y,uint X,TY T> MA<Y,X,T>& MA<Y,X,T>::operator%=(CO T& scalar) NE{for(auto Iy = m_M.begin(),endy = m_M.end();Iy != endy;Iy++){for(auto Ixy = Iy->begin(),endxy = Iy->end();Ixy != endxy;Ixy++){*Ixy %= scalar;}}RE *this;}TE <uint Y,uint X,TY T> IN TT<T>& MA<Y,X,T>::RefTable() NE { RE m_M; }TE <uint Y,uint X,TY T> IN CO TT<T>& MA<Y,X,T>::GetTable() CO NE { RE m_M; }TE <uint Y,uint X,TY T> IN CO MA<Y,X,T>& MA<Y,X,T>::Zero() NE { ST CO MA<Y,X,T> zero = MO(Zero_Body()); RE zero; }TE <uint Y,uint X,TY T> IN CO MA<Y,X,T>& MA<Y,X,T>::Unit() NE { ST CO MA<Y,X,T> unit = MO(Scalar(T(1))); RE unit; }TE <uint Y,uint X,TY T>MA<Y,X,T> MA<Y,X,T>::Zero_Body() NE{VE<T> vec(X);TT<T> M(Y,vec);RE MA<Y,X,T>(MO(M));}TE <uint Y,uint X,TY T>MA<Y,X,T> MA<Y,X,T>::Scalar(CO T& t) NE{MA<Y,X,T> M{ MO(Zero_Body()) };CE CO uint minXY = Y < X ? Y:X;for(uint y = 0;y < minXY;y++){M.m_M[y][y] = t;}RE M;}TE <uint Y,uint X,TY T> IN void MA<Y,X,T>::COructTable(TT<T>& M,VE<T>& vec) NE { M.push_back(MO(vec)); }TE <uint Y,uint X,TY T> TE <TY... Args> void MA<Y,X,T>::COructTable(TT<T>& M,VE<T>& vec,CO T& t,CO Args&... args) NE{vec.push_back(t);if(vec.SZ() == X){VE<T> v{};v.swap(vec);COructTable(M,v);}if(M.SZ() < Y){COructTable(M,vec,args...);}RE;}TE <uint Y , uint X , TY T> TE <TY... Args> void MA<Y,X,T>::COructTable(TT<T>& M,VE<T>& vec,T&& t,Args&&... args) NE{vec.push_back(MO(t));if(vec.SZ() == X){VE<T> v{};v.swap(vec);COructTable(M,v);}if(M.SZ() < Y){COructTable(M,vec,MO(args)...);}RE;}TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator==(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) NE { RE mat1.GetTable() == mat2.GetTable(); }TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator!=(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) NE { RE !(mat1 == mat2); }TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator+(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) { RE MA<Y,X,T>(mat1) += mat2; }TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator-(CO MA<Y,X,T>& mat1,CO MA<Y,X,T>& mat2) { RE MA<Y,X,T>(mat1) -= mat2; }TE <uint Y,uint X,uint Z,TY T> IN MA<Y,Z,T> operator*(CO MA<Y,X,T>& mat1,CO MA<X,Z,T>& mat2){CO TT<T>& M1 = mat1.GetTable();CO TT<T>& M2 = mat2.GetTable();TT<T> M_prod{};auto begin2x = M2.begin();for(auto I1y = M1.begin(),end1y = M1.end();I1y != end1y;I1y++){VE<T> vec{};auto begin1yx = I1y->begin(),end1yx = I1y->end();for(uint z = 0;z < Z;z++){auto I1yx = begin1yx;auto I2x = begin2x;T inner_product{};WH(I1yx != end1yx){inner_product += (*I1yx) * (*I2x)[z];I1yx++;I2x++;}vec.push_back(inner_product);}M_prod.push_back(MO(vec));}RE MA<Y,Z,T>(MO(M_prod));}TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator*(CO MA<Y,X,T>& mat,CO T& scalar) { RE MA<Y,X,T>(mat) *= scalar; }TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator*(CO T& scalar,CO MA<Y,X,T>& mat) { RE mat * scalar; }TE <uint Y,uint X,TY T> IN MA<Y,X,T> operator%(CO MA<Y,X,T>& mat,CO T& scalar) { RE MA<Y,X,T>(mat) %= scalar; }TE <uint Y,uint X,TY T>MA<X,Y,T> Transpose(CO MA<Y,X,T>& mat){CO TT<T>& M = mat.GetTable();TT<T> M_t{};auto beginy = M.begin();for(auto I1x = beginy->begin(),end1x = beginy->end();I1x != end1x;I1x++){M_t.push_back(VE<T>());}for(auto Iy = beginy,endy = M.end();Iy != endy;Iy++){auto Iyx = Iy->begin(),endyx = Iy->end();auto I_ty = M_t.begin();WH(Iyx != endyx){I_ty->push_back(*Iyx);Iyx++;I_ty++;}}RE MA<X,Y,T>(M_t);}TE <uint X,TY T>T Trace(CO MA<X,X,T>& mat){int i = 0;T AN =0;CO TT<T>& M = mat.GetTable();for(auto Iy = M.begin(),endy = M.end();Iy != endy;Iy++){AN += (*Iy)[i];i++;}RE AN;}