#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Restrictive/a_Body.hpp"
#else
TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeRestrictiveKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_ubound,CO U1& exceptional,CO VE<U2>& cost,CO U2& cost_sum_lbound,CO U2& cost_sum_ubound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_ubound < one1));CO U2& one2 = M2.One();AS(!(one2 < cost_sum_lbound)&& !(cost_sum_ubound < one2));pair<U1,U2> AN ={one1,one2};CO int PW = 1 << N;VE<pair<U1,U2>> sum(PW,{exceptional,one2});sum[0]={one1,one2};for(int s = 1;s < PW;s++){auto& sum_s = sum[s];for(int i = 0;i < N;i++){if(((s >> i)& 1)== 0){continue;}auto& sum_s_minus = sum[s ^(1 << i)];if(sum_s_minus.first != exceptional &&!(sum_s_minus.second < cost_sum_lbound)&&!(cost_sum_ubound < sum_s_minus.second)){sum_s.first = M1.Product(sum_s_minus.first,value[i]);sum_s.second = M2.Product(sum_s_minus.second,cost[i]);!(value_sum_ubound < sum_s.first)&&!(sum_s.second < cost_sum_lbound)&& !(cost_sum_ubound < sum_s.second)&&(AN.first < sum_s.first ||(AN.first == sum_s.first && sum_s.second < AN.second))?AN = sum_s:AN;break;}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeRestrictiveKnapsack(CO VE<INT1>& value,CO INT1& value_sum_ubound,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_lbound,CO INT2& cost_sum_ubound){RE AbstractNegativeRestrictiveKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_ubound,exceptional,cost,cost_sum_lbound,cost_sum_ubound);}
#endif
