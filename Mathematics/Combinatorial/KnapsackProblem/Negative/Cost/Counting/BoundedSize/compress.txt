#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Cost/Counting/BoundedSize/a_Body.hpp"
#else
#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY ABELIAN_GROUP>CL AbstractBIT{PU:ABELIAN_GROUP m_M;int m_SZ;VE<U> m_fenwick;int m_PW;IN AbstractBIT(ABELIAN_GROUP M,CRI SZ = 0);IN AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI i,CO U& u);VO Add(CRI i,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i);IN U Get(CRI i);IN CO U& LSBSegmentSum(CRI j)CO;U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CO U& u);IN int Search(CRI i_start,CO U& u);IN VO COruct();};TE <TY ABELIAN_GROUP,TY...Args> AbstractBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL BIT:PU AbstractBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN BIT(CO Args&... args);};TE <TY U> BIT(CO VE<U>& a)-> BIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_fenwick(m_SZ + 1,m_M.Zero()),m_PW(1){COruct();for(int j = 1;j <= m_SZ;j++){U& fenwick_j = m_fenwick[j];int i = j - 1;fenwick_j = a[i];int i_lim = j -(j & -j);WH(i > i_lim){fenwick_j = m_M.Sum(MO(fenwick_j),m_fenwick[i]);i -=(i & -i);}}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::COruct(){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U> TE <TY...Args> IN BIT<U>::BIT(CO Args&... args):AbstractBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){AbstractBIT<U,ABELIAN_GROUP> temp{m_M,args...};m_SZ = temp.m_SZ;m_fenwick = MO(temp.m_fenwick);m_PW = temp.m_PW;}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractBIT<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){int j = i + 1;WH(j <= m_SZ){U& fenwick_j = m_fenwick[j];fenwick_j = m_M.Sum(MO(fenwick_j),u);j +=(j & -j);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractBIT<U,ABELIAN_GROUP>::SZ()CO NE{RE m_SZ;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::OP[](CRI i){AS(0 <= i && i < m_SZ);RE IntervalSum(i,i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::Get(CRI i){RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractBIT<U,ABELIAN_GROUP>::LSBSegmentSum(CRI j)CO{AS(0 < j && j <= m_SZ);RE m_fenwick[j];}TE <TY U,TY ABELIAN_GROUP>U AbstractBIT<U,ABELIAN_GROUP>::InitialSegmentSum(CRI i_final){U sum = m_M.Zero();int j = min(i_final + 1,m_SZ);WH(j > 0){sum = m_M.Sum(MO(sum),m_fenwick[j]);j -= j & -j;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS>int AbstractBIT<U,ABELIAN_GROUP>::Search(CO F& f){int j = 0;int PW = m_PW;U sum = m_M.Zero();U sum_next = sum;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){sum_next = m_M.Sum(MO(sum_next),m_fenwick[j_next]);if(f(sum_next,j_next - 1)){sum_next = sum;}else{sum = sum_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO F& f){CO U u_inv = m_M.Inverse(InitialSegmentSum(i_start - 1));RE max(i_start,Search([&](CO U& sum,CRI i){RE i_start <= i && f(m_M.Sum(u_inv,sum),i);}));}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CO U& u){RE Search([&](CO U& sum,CRI){RE !(sum < u);});}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO U& u){RE max(i_start,Search(m_M.Sum(InitialSegmentSum(i_start - 1),u)));}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractBIT<U,ABELIAN_GROUP>& bit){auto&& SZ = bit.SZ();for(int i = 0;i < SZ;i++){(i == 0?os:os << " ")<< bit[i];}RE os;}

TE <TY BLS,TY INT>CL IteratorOfBoundedLineSubset{PU:BLS* m_p;INT m_i;IN IteratorOfBoundedLineSubset(BLS& S,INT i);IN bool OP==(CO IteratorOfBoundedLineSubset<BLS,INT>& IT)CO NE;IN bool OP!=(CO IteratorOfBoundedLineSubset<BLS,INT>& IT)CO NE;IN INT OP*()CO;IN IteratorOfBoundedLineSubset<BLS,INT>& OP++();IN IteratorOfBoundedLineSubset<BLS,INT> OP++(int);IN IteratorOfBoundedLineSubset<BLS,INT>& OP--();IN IteratorOfBoundedLineSubset<BLS,INT> OP--(int);IN VO Next();IN VO Prev();IN pair<INT,INT> ConnectedComponent()CO;IN IteratorOfBoundedLineSubset<BLS,INT>& erase_from(BLS& S);};
TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT>::IteratorOfBoundedLineSubset(BLS& S,INT i):m_p(&S),m_i(MO(i)){}TE <TY BLS,TY INT> IN bool IteratorOfBoundedLineSubset<BLS,INT>::OP==(CO IteratorOfBoundedLineSubset<BLS,INT>& IT)CO NE{RE m_p == IT.m_p && m_i == IT.m_i;}TE <TY BLS,TY INT> IN bool IteratorOfBoundedLineSubset<BLS,INT>::OP!=(CO IteratorOfBoundedLineSubset<BLS,INT>& IT)CO NE{RE !(*TH == IT);}TE <TY BLS,TY INT> IN INT IteratorOfBoundedLineSubset<BLS,INT>::OP*()CO{RE m_i;}TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT>& IteratorOfBoundedLineSubset<BLS,INT>::OP++(){AS(m_i <= m_p->ubound());RE *TH = m_p->MinimumGt(m_i);}TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT> IteratorOfBoundedLineSubset<BLS,INT>::OP++(int){auto IT = *TH;++(*TH);RE IT;}TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT>& IteratorOfBoundedLineSubset<BLS,INT>::OP--(){AS(m_p->BE().m_i <= m_i);RE *TH = m_p->MaximumLt(m_i);}TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT> IteratorOfBoundedLineSubset<BLS,INT>::OP--(int){auto IT = *TH;--(*TH);RE IT;}TE <TY BLS,TY INT> IN VO IteratorOfBoundedLineSubset<BLS,INT>::Next(){AS(m_i < m_p->ubound());CO INT r = m_p->RightEndPointOf(m_i);*TH = m_i <= r?m_p->MinimumGt(r):m_p->EN();}TE <TY BLS,TY INT> IN VO IteratorOfBoundedLineSubset<BLS,INT>::Prev(){AS(m_p->lbound()< m_i);CO INT l = m_p->LeftEndPointOf(m_i);*TH = l <= m_i?m_p->MaximumLt(l):m_p->EN();}TE <TY BLS,TY INT> IN pair<INT,INT> IteratorOfBoundedLineSubset<BLS,INT>::ConnectedComponent()CO{RE m_p->ConnectedComponentOf(m_i);}TE <TY BLS,TY INT> IN IteratorOfBoundedLineSubset<BLS,INT>& IteratorOfBoundedLineSubset<BLS,INT>::erase_from(BLS& S){AS(&S == m_p);auto IT_copy =(*TH)++;S.erase(IT_copy);RE *TH;}

TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR>CL VirtualBoundedLineSubset{PU:INT m_lbound;INT m_ubound;DATA_STR<INT> m_ds;US iterator = IteratorOfBoundedLineSubset<VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>,INT>;IN VO insert(CO INT& i);IN VO erase(CO INT& i)NE;IN iterator& erase(iterator& IT);IN VO clear();IN int count(CO INT& i)NE;bool find(CO INT& i)NE;IN int InitialSegmentCount(CO INT& i_final);IN int IntervalCount(CO INT& i_start,CO INT& i_final);IN bool empty()NE;IN iterator BE()NE;IN iterator EN()NE;IN iterator MaximumLeq(CO INT& i,CO INT& k = 0);IN iterator MaximumLt(CO INT& i,CO INT& k = 0);IN iterator MinimumGeq(CO INT& i,CO INT& k = 0);IN iterator MinimumGt(CO INT& i,CO INT& k = 0);IN INT Maximum(CO INT& k = 0);IN INT Minimum(CO INT& k = 0);INT RightEndPointOf(CO INT& i,int d = -1,int comp_minus = -1,CO bool& in = false);INT LeftEndPointOf(CO INT& i,int d = -1,int comp_minus = -1,CO bool& in = false);IN pair<INT,INT> ConnectedComponentOf(CO INT& i,bool in = false);VE<pair<INT,INT>> GetConnectedComponent()NE;IN CO INT& lbound()CO NE;IN CO INT& ubound()CO NE;VI bool InRange(CO INT& i)= 0;VI RET_NOR Normalise(CO INT& i)= 0;VI RET_DEN Denormalise(CO decay_t<RET_NOR>& d)= 0;};TE <TY INT,TE <TY...> TY DATA_STR>CL AbstractBoundedLineSubset:VI PU VirtualBoundedLineSubset<INT,INT,INT,DATA_STR>{PU:IN AbstractBoundedLineSubset(CO INT& lbound,CO INT& ubound);IN bool InRange(CO INT& i);IN INT Normalise(CO INT& i);IN INT Denormalise(CO INT& d);};
TE <TY INT>US BoundedLineSubset = AbstractBoundedLineSubset<INT,BIT>;
TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::insert(CO INT& i){AS(InRange(i));m_ds.Set(Normalise(i),1);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::erase(CO INT& i)NE{if(InRange(i)){m_ds.Set(Normalise(i),0);}}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator& VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::erase(TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator& IT){RE IT.erase_from(*TH);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::clear(){m_ds.Initialise(m_ds.SZ());}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN int VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::count(CO INT& i)NE{RE InRange(i)?m_ds[Normalise(i)]:0;}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN bool VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::find(CO INT& i)NE{RE count(i)> 0;}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN int VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::InitialSegmentCount(CO INT& i_final){RE i_final < m_lbound?0:m_ds.InitialSegmentSum(Normalise(i_final));}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN int VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::IntervalCount(CO INT& i_start,CO INT& i_final){auto&& l = Normalise(i_start);RE m_ds.IntervalSum((l < 0 || Denormalise(l)< i_start)?l + 1:l,Normalise(i_final));}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN bool VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::empty()NE{RE InitialSegmentCount(m_ubound)== 0;}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::BE()NE{RE MinimumGeq(m_lbound);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::EN()NE{RE TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator(*TH,m_ubound + 1);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::MaximumLeq(CO INT& i,CO INT& k){CO INT num = InitialSegmentCount(i)- k;if(num >= 0){CO int d = m_ds.Search([&](CO INT& sum,CRI j){RE num <= sum;});if(d < m_ds.SZ()){auto&& l = Denormalise(d);if(find(l)){RE TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator{*TH,l};}}}RE EN();}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::MaximumLt(CO INT& i,CO INT& k){CO int d = Normalise(i);if(d == 0){RE EN();}RE MaximumLeq(Denormalise(d - 1),k);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::MinimumGeq(CO INT& i,CO INT& k){CO int c = count(i);RE c > k?TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator{*TH,i}:MinimumGt(i,k - c);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::MinimumGt(CO INT& i,CO INT& k){CO INT num = InitialSegmentCount(i)+ k;CO int d = m_ds.Search([&](CO INT& sum,CRI j){RE num < sum;});if(d < m_ds.SZ()){auto&& r = Denormalise(d);if(find(r)){RE TY VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::iterator{*TH,r};}}RE EN();}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN INT VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::Maximum(CO INT& k){RE MaximumLeq(m_ubound,k);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN INT VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::Minimum(CO INT& k){RE MinimumGeq(m_lbound,k);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR>INT VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::RightEndPointOf(CO INT& i,int d,int comp_minus,CO bool& in){if(!in && !find(i)){RE i - 1;}if(d == -1){d = Normalise(i);comp_minus = d - InitialSegmentCount(i);}RE Denormalise(m_ds.Search([&](CO INT& sum,CRI j){RE d <= j && sum + comp_minus < j;})- 1);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR>INT VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::LeftEndPointOf(CO INT& i,int d,int comp_minus,CO bool& in){if(!in && !find(i)){RE i + 1;}if(d == -1){d = Normalise(i);comp_minus = d - InitialSegmentCount(i);}RE Denormalise(m_ds.Search([&](CO INT& sum,CRI j){RE d <= j ||(find(j)&& sum + comp_minus == j);}));}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN pair<INT,INT> VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::ConnectedComponentOf(CO INT& i,bool in){if(!in){in = find(i);}CO int d = Normalise(i),comp_minus = d - InitialSegmentCount(i);RE{LeftEndPointOf(i,d,comp_minus,in),RightEndPointOf(i,d,comp_minus,in)};}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR>VE<pair<INT,INT>> VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::GetConnectedComponent()NE{VE<pair<INT,INT>> AN{};INT r;for(auto IT = BE();*IT <= m_ubound;IT = MinimumGt(r)){AN.push_back({*IT,r = RightEndPointOf(*IT)});}RE AN;}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN CO INT& VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::lbound()CO NE{RE m_lbound;}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN CO INT& VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>::ubound()CO NE{RE m_ubound;}TE <TY INT,TE <TY...> TY DATA_STR> IN AbstractBoundedLineSubset<INT,DATA_STR>::AbstractBoundedLineSubset(CO INT& lbound,CO INT& ubound){AS(lbound <= ubound + 1);TH->m_lbound = lbound;TH->m_ubound = ubound;TH->m_ds.Initialise(TH->m_ubound - TH->m_lbound + 1);}TE <TY INT,TE <TY...> TY DATA_STR> IN bool AbstractBoundedLineSubset<INT,DATA_STR>::InRange(CO INT& i){RE TH->m_lbound <= i && i <= TH->m_ubound;}TE <TY INT,TE <TY...> TY DATA_STR> IN INT AbstractBoundedLineSubset<INT,DATA_STR>::Normalise(CO INT& i){RE i - TH->m_lbound;}TE <TY INT,TE <TY...> TY DATA_STR> IN INT AbstractBoundedLineSubset<INT,DATA_STR>::Denormalise(CO INT& d){RE d + TH->m_lbound;}

TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR>CL AbstractBoundedLineMultiSubset:VI PU VirtualBoundedLineSubset<INT,RET_NOR,RET_DEN,DATA_STR>{PU:IN VO insert(CO INT& i,CO INT& c = 1);IN VO erase(CO INT& i,CO INT& c = 1);IN VO EraseAll(CO INT& i);INT RightEndPointOf(CO INT& i,CO bool& in = false)= delete;INT LeftEndPointOf(CO INT& i,CO bool& in = false)= delete;IN pair<INT,INT> ConnectedComponentOf(CO INT& i,bool in = false)= delete;VE<pair<INT,INT>> GetConnectedComponent()NE = delete;};
TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO AbstractBoundedLineMultiSubset<INT,RET_NOR,RET_DEN,DATA_STR>::insert(CO INT& i,CO INT& c){AS(TH->InRange(i)&& c >= 0);TH->m_ds.Add(TH->Normalise(i),c);}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO AbstractBoundedLineMultiSubset<INT,RET_NOR,RET_DEN,DATA_STR>::erase(CO INT& i,CO INT& c){AS(c >= 0);if(TH->InRange(i)){TH->m_ds.Add(TH->Normalise(i),-c);}}TE <TY INT,TY RET_NOR,TY RET_DEN,TE <TY...> TY DATA_STR> IN VO AbstractBoundedLineMultiSubset<INT,RET_NOR,RET_DEN,DATA_STR>::EraseAll(CO INT& i){if(TH->InRange(i)){TH->m_ds.Set(TH->Normalise(i),0);}}

TE <TY INT,TE <TY...> TY DATA_STR>CL AbstractCompressedSortedSet:VI PU VirtualBoundedLineSubset<INT,CRI,CO INT&,DATA_STR>{PU:VE<INT> m_sorted_coord;map<INT,int> m_sorted_coord_inv;IN AbstractCompressedSortedSet(CO VE<INT>& query);IN bool InRange(CO INT& i);IN CRI Normalise(CO INT& i);IN CO INT& Denormalise(CRI d);};
TE <TY INT>US CompressedSortedSet = AbstractCompressedSortedSet<INT,BIT>;
TE <TY INT,TE <TY...> TY DATA_STR> IN AbstractCompressedSortedSet<INT,DATA_STR>::AbstractCompressedSortedSet(CO VE<INT>& query):m_sorted_coord(),m_sorted_coord_inv(){set<INT> S{};for(auto& i:query){S.insert(i);}m_sorted_coord.reserve(S.SZ());for(auto& i:S){m_sorted_coord_inv[i]= m_sorted_coord.SZ();m_sorted_coord.push_back(i);}if(m_sorted_coord.empty()){TH->m_lbound = 0;TH->m_ubound = -1;}else{TH->m_lbound = m_sorted_coord.front();TH->m_ubound = m_sorted_coord.back();}TH->m_ds.Initialise(int(S.SZ()));}TE <TY INT,TE <TY...> TY DATA_STR> IN bool AbstractCompressedSortedSet<INT,DATA_STR>::InRange(CO INT& i){RE m_sorted_coord_inv.count(i)> 0;}TE <TY INT,TE <TY...> TY DATA_STR> IN CRI AbstractCompressedSortedSet<INT,DATA_STR>::Normalise(CO INT& i){ST CO int exceptional = -1;RE i < TH->m_lbound || m_sorted_coord_inv.empty()?exceptional:(--m_sorted_coord_inv.upper_bound(i))->second;}TE <TY INT,TE <TY...> TY DATA_STR> IN CO INT& AbstractCompressedSortedSet<INT,DATA_STR>::Denormalise(CRI d){RE m_sorted_coord[d];}

TE <TY INT>CL CompressedSortedMultiSet:PU CompressedSortedSet<INT>,PU AbstractBoundedLineMultiSubset<INT,CRI,CO INT&,BIT>{PU:IN CompressedSortedMultiSet(CO VE<INT>& query);};
TE <TY INT> IN CompressedSortedMultiSet<INT>::CompressedSortedMultiSet(CO VE<INT>& query):CompressedSortedSet<INT>(query){}

TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY INT,TY U,TY COMM_MONOID>VE<VE<ll>> AbstractCountingNegativeCostBoundedValueSumBoundedSizeKnapsack(COMM_MONOID M,CO VE<INT>& value,CO VE<pair<INT,INT>>& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_bound,CO pair<int,int>& SZ_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto&[SZ_min,SZ_max]= SZ_bound;AS(0 <= SZ_min && SZ_min <= SZ_max && SZ_max <= N);CO int N_half = N >> 1;CO int SZ_max_half[2]={min(SZ_max,N_half),min(SZ_max,N - N_half)};CO U& one = M.One();VE<map<pair<U,INT>,int>> count[2]={};for(int b = 0;b < 2;b++){CO int i_min = b == 0?0:N_half;CO int i_ulim = b == 0?N_half:N;count[b].resize(SZ_max_half[b]+ 1);count[b][0][{one,0}]= 1;for(int i = i_min;i < i_ulim;i++){for(int SZ = SZ_max_half[b]- 1;SZ >= 0;SZ--){for(auto&[key,num]:count[b][SZ]){count[b][SZ+1][{M.Product(key.first,cost[i]),key.second + value[i]}]+= num;}}}}CO int Q = value_sum_bound.SZ();VE<CompressedSortedMultiSet<ll>> S{};for(int SZ_1 = 0;SZ_1 <= SZ_max_half[1];SZ_1++){VE<INT> query{};for(auto&[key,num]:count[1][SZ_1]){query.push_back(key.second);}S.push_back(query)}VE AN(SZ_max + 1,VE<ll>(Q));for(int SZ_0 = 0;SZ_0 <= SZ_max_half[0];SZ_0++){CO int SZ_1_max = min(SZ_max_half[1],SZ_max - SZ_0);for(int SZ_1 = max(0,SZ_min - SZ_0);SZ_1 <= SZ_1_max;SZ_1++){CO int SZ = SZ_0 + SZ_1;auto IT_0 = count[0][SZ_0].rBE(),EN_0 = count[0][SZ_0].rend();auto IT_1 = count[1][SZ_1].BE(),EN_1 = count[1][SZ_1].EN();IT_0 = count[0][SZ_0].rBE();IT_1 = count[1][SZ_1].BE();S[SZ_1].clear();auto EN = S[SZ_1].EN();WH(IT_0 != EN_0){WH(IT_1 != EN_1 && M.Product(IT_0->first.first,IT_1->first.first)<= cost_sum_bound){S[SZ_1].insert(IT_1->first.second,IT_1->second);++IT_1;}for(int q = 0;q < Q;q++){auto&[l,r]= value_sum_bound[q];auto IT_l = S[SZ_1].MinimumGeq(l - IT_0->first.second),IT_r = S[SZ_1].MaximumLeq(r - IT_0->first.second);if(IT_l != EN && IT_r != EN){AN[SZ][q]+= ll(IT_0->second)* S[SZ_1].IntervalCount(*IT_l,*IT_r);}}++IT_0;}}}RE AN;}TE <TY INT1,TY INT2> IN VE<VE<ll>> CountingNegativeCostBoundedValueSumBoundedSizeKnapsack(CO VE<INT1>& value,CO VE<pair<INT1,INT1>>& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO pair<int,int>& SZ_bound){RE AbstractCountingNegativeCostBoundedValueSumBoundedSizeKnapsack(AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound,SZ_bound);}
#endif

