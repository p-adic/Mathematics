#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Value/Multicost/a_Body.hpp"
#else
TE <TY INT> bool NextLoopEq(CRI SZ,CO VE<INT>& lower_bound,CO VE<INT>& upper_bound,VE<INT>& index){int depth = 0;WH(depth < SZ){if(++index[depth]<= upper_bound[depth]){break;}index[depth]= lower_bound[depth];depth++;}RE depth < SZ;}TE <TY INT> bool NextLoopEq(CO VE<INT>& lower_bound,CO VE<INT>& upper_bound,VE<INT>& index){RE NextLoop(index.SZ(),lower_bound,upper_bound,index);}

TE <TY U>CL VirtualMeetSemilattice:VI PU VirtualMonoid<U>{PU:IN U Meet(U u0,CO U& u1);};TE <TY U>CL MinSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MinSemilattice(U infty_U);IN U Product(U u0,CO U& u1);};TE <TY U>CL MaxSemilattice:VI PU VirtualMeetSemilattice<U>,PU PointedSet<U>{PU:IN MaxSemilattice(U zero_U);IN U Product(U u0,CO U& u1);};
TE <TY U> IN U VirtualMeetSemilattice<U>::Meet(U u0,CO U& u1){RE TH->Product(MO(u0),u1);}TE <TY U> IN MinSemilattice<U>::MinSemilattice(U infty_U):PointedSet<U>(MO(infty_U)){}TE <TY U> IN MaxSemilattice<U>::MaxSemilattice(U zero_U):PointedSet<U>(MO(zero_U)){}TE <TY U> IN U MinSemilattice<U>::Product(U u0,CO U& u1){RE u0 < u1?MO(u0):u1;}TE <TY U> IN U MaxSemilattice<U>::Product(U u0,CO U& u1){RE u1 < u0?MO(u0):u1;}

#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*

TE <TY U,TY COMM_IDEM_MONOID>CL IdempotentMonoidBIT{PU:COMM_IDEM_MONOID m_M;int m_SZ;VE<U> m_a;VE<U> m_fenwick_0;VE<U> m_fenwick_1;int m_PW;IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ = 0);IN IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a);TE <TY...Args> IN VO Initialise(Args&&... args);VO Set(CRI i,CO U& u);IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>& OP+=(VE<U>&& a);VO Multiply(CRI i,CO U& u);VO IntervalMultiply(CRI i_start,CRI i_final,CO U& u);IN CRI SZ()CO NE;IN CO U& OP[](CRI i)CO;IN CO U& Get(CRI i)CO;IN CO U& LSBSegmentProduct(CRI j,CO bool& left = true)CO;U IntervalProduct(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int BinarySearch(CO F& f);int BinarySearch(CO U& u);IN VO COruct();};TE <TY COMM_IDEM_MONOID> IdempotentMonoidBIT(COMM_IDEM_MONOID M)-> IdempotentMonoidBIT<inner_t<COMM_IDEM_MONOID>,COMM_IDEM_MONOID>;TE <TY U>CL IntervalMaxBIT:PU IdempotentMonoidBIT<U,MaxSemilattice<U>>{PU:TE <TY...Args> IN IntervalMaxBIT(CO U& zero_U,Args&&... args);IN VO SetMax(CRI i,CO U& u);IN VO IntervalSetMax(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMax(CRI j,CO bool& left = true)CO;IN U IntervalMax(CRI i_start,CRI i_final);};TE <TY U>CL IntervalMinBIT:PU IdempotentMonoidBIT<U,MinSemilattice<U>>{PU:TE <TY...Args> IN IntervalMinBIT(CO U& infty_U,Args&&... args);IN VO SetMin(CRI i,CO U& u);IN VO IntervalSetMin(CRI i_start,CRI i_final,CO U& u);IN CO U& LSBSegmentMin(CRI j,CO bool& left = true)CO;IN U IntervalMin(CRI i_start,CRI i_final);};
TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_a(SZ,m_M.One()),m_fenwick_0(m_SZ + 1,m_M.One()),m_fenwick_1(m_SZ + 1,m_M.One()),m_PW(1){COruct();}TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IdempotentMonoidBIT(COMM_IDEM_MONOID M,VE<U> a):m_M(MO(M)),m_SZ(a.SZ()),m_a(MO(a)),m_fenwick_0(m_SZ + 1),m_fenwick_1(m_SZ + 1),m_PW(1){COruct();for(int i = 0;i < m_SZ;i++){int j = i + 1;U& fenwick_0i = m_fenwick_0[j];fenwick_0i = m_a[i];CO int j_llim = j -(j & -j);j--;WH(j > j_llim){fenwick_0i = m_M.Product(m_fenwick_0[j],fenwick_0i);j -=(j & -j);}}for(int i = m_SZ - 1;i >= 0;i--){int j = i + 1;U& fenwick_1i = m_fenwick_1[j];fenwick_1i = m_a[i];CO int j_ulim = min(j +(j & -j),m_SZ + 1);j++;WH(j < j_ulim){fenwick_1i = m_M.Product(MO(fenwick_1i),m_fenwick_1[j]);j +=(j & -j);}}}TE <TY U> TE <TY...Args> IN IntervalMaxBIT<U>::IntervalMaxBIT(CO U& zero_U,Args&&... args):IdempotentMonoidBIT<U,MaxSemilattice<U>>(MaxSemilattice<U>(zero_U),forward<Args>(args)...){}TE <TY U> TE <TY...Args> IN IntervalMinBIT<U>::IntervalMinBIT(CO U& infty_U,Args&&... args):IdempotentMonoidBIT<U,MinSemilattice<U>>(MinSemilattice<U>(infty_U),forward<Args>(args)...){}TE <TY U,TY COMM_IDEM_MONOID> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::COruct(){ST_AS(is_same_v<U,inner_t<COMM_IDEM_MONOID>>);WH(m_PW < m_SZ){m_PW <<= 1;}}TE <TY U,TY COMM_IDEM_MONOID> TE <TY...Args> IN VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Initialise(Args&&... args){IdempotentMonoidBIT<U,COMM_IDEM_MONOID> temp{m_M,forward<Args>(args)...};m_SZ = temp.m_SZ;m_a = MO(temp.m_a);m_fenwick_0 = MO(temp.m_fenwick_0);m_fenwick_1 = MO(temp.m_fenwick_1);m_PW = temp.m_PW;}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Set(CRI i,CO U& u){U& ai = m_a[i];if(u == m_M.Product(ai,u)){Multiply(i,u);}else{ai = u;int j = i + 1;int j_minus = j -(j & -j);U temp_left = m_M.Product(IntervalProduct(j_minus,i - 1),ai);U temp_right = m_M.One();WH(j <= m_SZ){m_fenwick_0[j]= m_M.Product(temp_left,temp_right);int j_next = j +(j & -j);int j_minus_next = j_next -(j_next & -j_next);if(j_minus_next != j_minus - 1){temp_left = m_M.Product(IntervalProduct(j_minus_next,j_minus - 1),temp_left);j_minus = j_minus_next;}temp_right = m_M.Product(MO(temp_right),IntervalProduct(j,j_next - 1));j = j_next;}j = i + 1;int j_plus = j +(j & -j)- 1;temp_left = m_M.One();temp_right = m_M.Product(ai,IntervalProduct(j,j_plus - 1));WH(j > 0){m_fenwick_1[j]= m_M.Product(temp_left,temp_right);int j_next = j -(j & -j);int j_plus_next = j_next +(j_next & -j_next)- 1;temp_left = m_M.Product(IntervalProduct(j_next - 1,j - 2),temp_left);j = j_next;if(j_plus != j_plus_next - 1){temp_right = m_M.Product(MO(temp_right),IntervalProduct(j_plus,j_plus_next - 1));j_plus = j_plus_next;}}}RE;}TE <TY U,TY COMM_IDEM_MONOID> IN IdempotentMonoidBIT<U,COMM_IDEM_MONOID>& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::OP+=(VE<U>&& a){IdempotentMonoidBIT<U,COMM_IDEM_MONOID> a_copy{m_M,MO(a)};AS(m_SZ == a_copy.m_SZ);for(int j = 1;j <= m_SZ;j++){U& t0j = m_fenwick_0[j];t0j = m_M.Product(MO(t0j),a_copy.m_fenwick_0[j]);U& t1j = m_fenwick_1[j];t1j = m_M.Product(MO(t1j),a_copy.m_fenwick_1[j]);}}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Multiply(CRI i,CO U& u){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);int j = i + 1;WH(j <= m_SZ){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);j +=(j & -j);}j = i + 1;WH(j > 0){U& tj = m_fenwick_1[j];tj = m_M.Product(MO(tj),u);j -=(j & -j);}RE;}TE <TY U> VO IntervalMaxBIT<U>::SetMax(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U> VO IntervalMinBIT<U>::SetMin(CRI i,CO U& u){TH->Multiply(i,u);}TE <TY U,TY COMM_IDEM_MONOID>VO IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalMultiply(CRI i_start,CRI i_final,CO U& u){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);for(int i = j_min - 1;i < j_max;i++){U& ai = m_a[i];ai = m_M.Product(MO(ai),u);}CO int j_llim = j_min -(j_min & -j_min);CO int j_ulim = min(j_max +(j_max & j_max),m_SZ + 1);if(j_min <= j_max){int j = j_min;WH(j < j_ulim){if(j -(j & -j)< j_max){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j++;}j = j_max;WH(j > j_llim){if(j +(j & -j)> j_min){U& tj = m_fenwick_0[j];tj = m_M.Product(MO(tj),u);}j--;}}RE;}TE <TY U> VO IntervalMaxBIT<U>::IntervalSetMax(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U> VO IntervalMinBIT<U>::IntervalSetMin(CRI i_start,CRI i_final,CO U& u){TH->IntervalMultiply(i_start,i_final,u);}TE <TY U,TY COMM_IDEM_MONOID> IN CRI IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::SZ()CO NE{RE m_SZ;}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::OP[](CRI i)CO{AS(0 <= i && i < m_SZ);RE m_a[i];}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::Get(CRI i)CO{RE OP[](i);}TE <TY U,TY COMM_IDEM_MONOID> IN CO U& IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::LSBSegmentProduct(CRI j,CO bool& left)CO{AS(0 < j && j <= m_SZ);RE(left?m_fenwick_0:m_fenwick_1)[j];}TE <TY U> CO U& IntervalMaxBIT<U>::LSBSegmentMax(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U> CO U& IntervalMinBIT<U>::LSBSegmentMin(CRI j,CO bool& left)CO{RE TH->LSBSegmentProduct(j,left);}TE <TY U,TY COMM_IDEM_MONOID>U IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::IntervalProduct(CRI i_start,CRI i_final){CO int j_min = max(i_start + 1,1);CO int j_max = min(i_final + 1,m_SZ);if(j_min > j_max){RE m_M.One();}U AN1 = m_M.One();int j = j_min;int j_next = j +(j & -j);WH(j_next <= j_max){AN1 = m_M.Product(MO(AN1),m_fenwick_1[j]);j = j_next;j_next +=(j & -j);}AN1 = m_M.Product(MO(AN1),m_a[j-1]);U AN0 = m_M.One();j = j_max;j_next = j -(j & -j);WH(j_next >= j_min){AN0 = m_M.Product(MO(AN0),m_fenwick_0[j]);j = j_next;j_next -=(j & -j);}RE m_M.Product(MO(AN1),AN0);}TE <TY U> U IntervalMaxBIT<U>::IntervalMax(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U> U IntervalMinBIT<U>::IntervalMin(CRI i_start,CRI i_final){RE TH->IntervalProduct(i_start,i_final);}TE <TY U,TY COMM_IDEM_MONOID> TE <TY F,SFINAE_FOR_BIT_BS> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::BinarySearch(CO F& f){int j = 0;int PW = m_PW;U product = m_M.One();U product_next = product;WH(PW > 0){int j_next = j | PW;if(j_next <= m_SZ){product_next = m_M.Product(product_next,m_fenwick_0[j_next]);if(f(product_next,j_next - 1)){product_next = product;}else{product = product_next;j = j_next;}}PW >>= 1;}RE j;}TE <TY U,TY COMM_IDEM_MONOID> IN int IdempotentMonoidBIT<U,COMM_IDEM_MONOID>::BinarySearch(CO U& u){RE BinarySearch([&](CO U& prod,CRI){RE prod == m_M.Product(prod,u);});}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractNegativeValueCostwiseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(value_i != exceptional);AS(cost_i >= 0);for(INT c = cost_sum_bound;c >= cost_i;c--){auto& AN_c_minus = AN[c - cost_i];if(AN_c_minus != exceptional){auto temp = M.Product(AN_c_minus,value_i);AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> NegativeValueCostwiseKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueCostwiseKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}

TE <TY U,TY COMM_MONOID,TY INT,TY VALID> U AbstractNegativeValueMulticostKnapsack(COMM_MONOID M,CO VE<VE<U>>& value,CO U& exceptional,CO VE<VE<INT>>& cost,CO VE<INT>& cost_sum_bound,VALID valid){ST_AS(is_invocable_r_v<VE<pair<INT,INT>>,VALID,CO VE<INT>&>);CO int D = cost_sum_bound.SZ();AS(D >= 2);VE value_max(D,VE<U>());for(int d = 0;d < D;d++){value_max[d]= AbstractNegativeValueCostwiseKnapsack(M,value[d],exceptional,cost[d],cost_sum_bound[d]);}CO U& one = M.One();CO int D_minus = D - 1;IntervalMaxBIT bit{one,value_max[D_minus]};VE<INT> index(D_minus,0),lower_bound = index;U AN = one;bool b = true;WH(b){U temp = one;for(int d = 0;d < D_minus;d++){value_max[d][index[d]]== exceptional?temp = exceptional:temp = M.Product(MO(temp),value_max[d][index[d]]);}if(temp != exceptional){for(auto&[l,r]:valid(index)){AS(l <= r);AN = max(AN,M.Product(bit.IntervalMax(l,r),temp));}}b = NextLoopEq(D_minus,lower_bound,cost_sum_bound,index);}RE AN;}TE <TY U,TY COMM_MONOID,TY INT1,TY INT2,TY VALID> U AbstractNegativeValueMulticostKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT1>& coord,CO VE<INT2>& cost,CO VE<INT2>& cost_sum_bound,VALID valid){CO int N = value.SZ();CO INT1 D = cost_sum_bound.SZ();AS(int(coord.SZ())== N && int(cost.SZ())== N);VE value_copy(D,VE<U>());VE cost_copy(D,VE<INT2>());for(int i = 0;i < N;i++){auto& coord_i = coord[i];AS(0 <= coord_i && coord_i < D);value_copy[coord_i].push_back(value[i]);cost_copy[coord_i].push_back(cost[i]);}RE AbstractNegativeValueMulticostKnapsack(MO(M),value_copy,exceptional,cost_copy,cost_sum_bound,MO(valid));}TE <TY INT1,TY INT2,TY INT3,TY VALID> IN INT1 NegativeValueMulticostKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& coord,CO VE<INT3>& cost,CO VE<INT3>& cost_sum_bound,VALID valid){RE AbstractNegativeValueMulticostKnapsack(AdditiveMonoid<INT1>(),value,exceptional,coord,cost,cost_sum_bound,MO(valid));}
#endif
