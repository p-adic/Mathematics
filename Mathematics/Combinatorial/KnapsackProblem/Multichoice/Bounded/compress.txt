#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Multichoice/Bounded/a_Body.hpp"
#else
TE <TY INT> CE INT Log(CO INT& N){INT AN = 0;if(N > 0){WH((N - 1)>> AN > 0){AN++;}}RE AN;}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractMulticaseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(!(value_i < one));auto& cost_i = cost[i];AS(cost_i >= 0);if(cost_sum_bound < cost_i || value_sum_bound < value_i){continue;}for(INT c = cost_sum_bound;c >= cost_i;c--){auto temp = M.Product(AN[c - cost_i],value_i);if(temp <= value_sum_bound){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> MulticaseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE Knapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2>VE<INT2> DualMulticaseKnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){VE cost_min(value_sum_bound + 1,INT2(-1));cost_min[0]= 0;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(value_i >= 0);auto& cost_i = cost[i];AS(cost_i >= 0);if(cost_sum_bound < cost_i || value_sum_bound < value_i){continue;}for(INT1 v = value_sum_bound,v_plus = v + 1;v_plus > value_i;v--,v_plus--){auto& cost_min_v_i = cost_min[v - value_i];if(cost_min_v_i != -1){auto temp = cost_min[v - value_i]+ cost_i;if(temp <= cost_sum_bound){auto& cost_min_v = cost_min[v];cost_min_v = cost_min_v == -1?MO(temp):min(cost_min_v,temp);}}}}RE cost_min;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> KnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){auto cost_min = DualMulticaseKnapsackFewValues(N,value,value_sum_bound,cost,cost_sum_bound);pair<INT1,INT2> AN ={0,0};for(INT2 v = 0;v <= value_sum_bound;v++){auto& c_v = cost_min[v];c_v == -1?AN:AN ={v,MO(c_v)};}RE AN;}TE <TY INT1,TY INT2>pair<INT1,INT2> KnapsackFewItems(CRI N,CO VE<INT2>& value,CO INT2& value_sum_bound,CO VE<INT1>& cost,CO INT1& cost_sum_bound){pair<INT1,INT2> AN ={0,0};if(N == 1){if(cost[0]<= cost_sum_bound && value[0]<= value_sum_bound){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<INT2,INT1>> sum_left(PW_left);for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = sum_left_s_minus.first + cost[i];sum_left_s.second = sum_left_s_minus.second + value[i];}CO int PW_right = 1 << N_half_right;VE<pair<INT2,INT1>> sum_right(PW_right);for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = sum_right_s_minus.first + cost[i];sum_right_s.second = sum_right_s_minus.second + value[i];}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];CO pair<INT2,INT1> diff ={cost_sum_bound - sum_left_s.first,value_sum_bound - sum_left_s.second};if(diff.first >= 0 && diff.second >= 0){BS2(t,0,PW_right - 1,sum_right[t].first <= diff.first && sum_right[t].second <= diff.second?0:1,0);if(AN.first <= sum_left_s.second + sum_right[t].second){BS1(u,0,t,sum_right[u].second,sum_right[t].second);pair<INT1,INT2> temp ={sum_left_s.second + sum_right[u].second,sum_left_s.first + sum_right[u].first};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> Knapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){CO int N = value.SZ();RE Log(N)+ Log(min(ll(cost_sum_bound),ll(value_sum_bound)))< ll(N >> 1)?cost_sum_bound < value_sum_bound?AbstractKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT2(-1),cost,cost_sum_bound):KnapsackFewValues(N,value,value_sum_bound,cost,cost_sum_bound):KnapsackFewItems(N,value,value_sum_bound,cost,cost_sum_bound);}

TE <TY U,TY COMM_MONOID,TY INT,TY COST,TY CHOICE_NUM_BOUND>VE<U> AbstractBoundedChoiceUnstableCostMulticaseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,COST cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT& cost_sum_bound){ST_AS(is_invocable_r_v<INT,COST,CRI,CRI> && is_invocable_v<CHOICE_NUM_BOUND,CRI>);CO int N = value.SZ();auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(!(value_i < one));ll choice_num_bound_i = choice_num_bound(i);AS(choice_num_bound_i <= choice_num_bound_max);int choice_num_bound_fixed_i = int(min(choice_num_bound_i,ll(cost_sum_bound + 1)));INT c_min = 0;auto temp = AN;for(ll choice_num = 0;choice_num < choice_num_bound_fixed_i && c_min < cost_sum_bound;choice_num++){auto&& c_i = cost(i,choice_num);AS(c_i >= 1);c_min += c_i;for(INT c = cost_sum_bound;c >= c_min;c--){auto& AN_c = AN[c];auto& temp_c_i = temp[c - c_i];if(temp_c_i != exceptional){auto& temp_c = temp[c]= M.Product(temp_c_i,value_i);AN_c = AN_c == exceptional?temp_c:max(AN_c,temp_c);}}}}RE AN;}TE <TY INT1,TY INT2,TY COST,TY CHOICE_NUM_BOUND> IN VE<INT1> BoundedChoiceUnstableCostMulticaseKnapsack(CO VE<INT2>& value,CO INT2& value_sum_bound,COST cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT1& cost_sum_bound){RE AbstractBoundedChoiceUnstableCostMulticaseKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),MO(cost),MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT,TY COST,TY CHOICE_NUM_BOUND> IN pair<U,INT> AbstractBoundedChoiceUnstableCostKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,COST cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractBoundedChoiceUnstableCostMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,MO(cost),MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2,TY COST,TY CHOICE_NUM_BOUND> IN pair<INT1,INT2> BoundedChoiceUnstableCostKnapsack(CO VE<INT2>& value,CO INT2& value_sum_bound,COST cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT1& cost_sum_bound){RE AbstractBoundedChoiceUnstableCostKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),MO(cost),MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);}TE <TY U,TY INT,TY CHOICE_NUM_BOUND>VO SetIteratedItem(CRI N,CO VE<U>& value,VE<U>& value_new,CO VE<INT>& cost,VE<INT>& cost_new,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max){ST_AS(!is_same_v<U,int> && !is_same_v<U,uint>);ST_AS(!is_same_v<INT,int> && !is_same_v<INT,uint>);for(int i = 0;i < N;i++){auto value_i = value[i];auto cost_i = cost[i];ll m = choice_num_bound(i);AS(m <= choice_num_bound_max);ll p = 1;WH(p <= m){m -= p;value_new.push_back(value_i);cost_new.push_back(cost_i);cost_i <<= 1;value_i <<= 1;p <<= 1;}if(m > 0){value_new.push_back(value[i]* m);cost_new.push_back(cost[i]* m);}}RE;}TE <TY U,TY N_MODULE,TY INT,TY CHOICE_NUM_BOUND> IN VE<U> AbstractBoundedChoiceMulticaseKnapsackFewCost(N_MODULE M,CRI N,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT& cost_sum_bound){VE<U> value_new;VE<INT> cost_new;SetIteratedItem(N,value,value_new,cost,cost_new,MO(choice_num_bound),choice_num_bound_max);RE AbstractMulticaseKnapsack(MO(M),value_new,value_sum_bound,exceptional,cost_new,cost_sum_bound);}TE <TY U,TY N_MODULE,TY INT,TY CHOICE_NUM_BOUND> IN VE<U> AbstractBoundedChoiceMulticaseKnapsack(N_MODULE M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT& cost_sum_bound){CO int N = value.SZ();RE N == 0?VE<U>(cost_sum_bound + 1,M.One()):cost_sum_bound / N < Log(cost_sum_bound)?AbstractBoundedChoiceUnstableCostMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,[&](CRI i,CRI){RE cost[i];},MO(choice_num_bound),cost_sum_bound):AbstractBoundedChoiceMulticaseKnapsackFewCost(MO(M),N,value,value_sum_bound,exceptional,cost,MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);}TE <TY INT1,TY INT2,TY CHOICE_NUM_BOUND> IN VE<INT1> BoundedChoiceMulticaseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT2& cost_sum_bound){RE AbstractBoundedChoiceMulticaseKnapsack(AdditiveGroup<INT1>(),value,value_sum_bound,cost,MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);}TE <TY INT,TY CHOICE_NUM_BOUND> IN VE<bool> BoundedChoiceCostfreeCOructibilityKnapsack(CO VE<INT>& value,CO INT& value_sum_bound,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max){auto value_COructed = BoundedChoiceMulticaseKnapsack(value,value_sum_bound,value,MO(choice_num_bound),choice_num_bound_max,value_sum_bound);VE<bool> AN(value_sum_bound + 1);for(INT v = 0;v <= value_sum_bound;v++){AN[v]= value_COructed[v]== v;}RE AN;}TE <TY U,TY N_MODULE,TY INT,TY CHOICE_NUM_BOUND> IN pair<U,INT> AbstractBoundedChoiceKnapsack(N_MODULE M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractBoundedChoiceMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,cost,MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY CHOICE_NUM_BOUND,TY INT2> IN pair<INT1,INT2> BoundedChoiceKnapsackFewItems(CRI N,CO VE<INT2>& value,CO INT2& value_sum_bound,CO VE<INT1>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT1& cost_sum_bound){VE<INT2> value_new;VE<INT1> cost_new;SetIteratedItem(N,value,value_new,cost,cost_new,MO(choice_num_bound),choice_num_bound_max);RE Knapsack(value_new,value_sum_bound,cost_new,cost_sum_bound);}TE <TY INT1,TY INT2,TY CHOICE_NUM_BOUND>pair<INT1,INT2> BoundedChoiceKnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_bound,CO INT1& value_sum_bound,CO VE<INT2>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT2& cost_sum_bound){CO INT1 value_sum_range = min(value_sum_bound,value_bound * value_bound * INT1(N));VE<INT1> value_new{};VE<INT2> cost_new{};VE<int> choice_num(N);for(int i = 0;i < N;i++){ll choice_num_bound_i = choice_num_bound(i);AS(choice_num_bound_i <= choice_num_bound_max);choice_num[i]= int(min(choice_num_bound_i,ll(value_bound)));}SetIteratedItem(N,value,value_new,cost,cost_new,[&](CRI i){RE choice_num[i];},choice_num_bound_max);auto cost_min = DualMulticaseKnapsackFewValues(value_new.SZ(),value_new,value_sum_range,cost_new,cost_sum_bound);pair<INT1,INT2> AN ={0,0};VE<pair<double,int>> item(N);for(int i = 0;i < N;i++){AS(value[i]> 0);item[i]={double(cost[i])/ value[i],i};choice_num[i]= choice_num_bound(i)- choice_num[i];}sort(item.BE(),item.EN());for(INT1 v = 0;v <= value_sum_range;v++){if(cost_min[v]!= -1){ll value_rest = value_sum_bound - v;ll cost_rest = cost_sum_bound - cost_min[v];for(int j = 0;j < N;j++){CRI i = item[j].second;ll num = choice_num[i];num = min(num,value_rest / ll(value[i]));cost[i]> 0?num = min(num,cost_rest / ll(cost[i])):num;value_rest -= ll(value[i])* num;cost_rest -= ll(cost[i])* num;}pair<INT1,INT2> temp ={value_sum_bound - value_rest,cost_sum_bound - cost_rest};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}RE AN;}TE <TY INT1,TY INT2,TY CHOICE_NUM_BOUND> IN pair<INT1,INT2> BoundedChoiceKnapsack(CO VE<INT1>& value,CO INT1& value_bound,CO INT1& value_sum_bound,CO VE<INT2>& cost,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max,CO INT2& cost_sum_bound){CO int N = value.SZ();CO ll log_N = Log(N),log_value_bound = Log(ll(value_bound)),log_cost_sum_bound = Log(ll(cost_sum_bound)),log_choice_num_bound_max = Log(choice_num_bound_max),parameter0 = log_cost_sum_bound << 1,parameter1 = log_N + min((ll(cost_sum_bound)< ll(value_sum_bound)?log_cost_sum_bound:Log(ll(value_sum_bound))),N * log_choice_num_bound_max >> 1)+ Log(log_choice_num_bound_max),parameter2 =(log_N << 1)+(log_value_bound << 1)+ Log(log_value_bound);CO int type = parameter0 < parameter1?parameter0 < parameter2?0:2:parameter1 < parameter2?1:2;RE type == 0?BoundedChoiceUnstableCostKnapsack(value,value_sum_bound,[&](CRI i,CRI){RE cost[i];},MO(choice_num_bound),choice_num_bound_max,cost_sum_bound):type == 1?BoundedChoiceKnapsackFewItems(N,value,value_sum_bound,cost,MO(choice_num_bound),choice_num_bound_max,cost_sum_bound):BoundedChoiceKnapsackFewValues(N,value,value_bound,value_sum_bound,cost,MO(choice_num_bound),choice_num_bound_max,cost_sum_bound);}TE <TY INT,TY CHOICE_NUM_BOUND> IN INT BoundedChoiceCostfreeKnapsack(CO VE<INT>& value,CO INT& value_bound,CO INT& value_sum_bound,CHOICE_NUM_BOUND choice_num_bound,CRL choice_num_bound_max){RE BoundedChoiceKnapsack(value,value_bound,value_sum_bound,value,MO(choice_num_bound),choice_num_bound_max,value_sum_bound);}
#endif

