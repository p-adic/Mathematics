#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Multichoice/Unbounded/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractUnboundedChoiceMulticaseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE<U> value_max(cost_sum_bound + 1,exceptional);value_max[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS((cost_i > 0 && !(value_i < one))||(cost_i == 0 && value_i == one));if(cost_sum_bound < cost_i || value_sum_bound < value_i){continue;}auto& value_max_i = value_max[cost_i];value_max_i = value_max_i == exceptional?value_i:max(value_max[cost_i],value_i);}auto AN = value_max;for(INT d = 1;d < cost_sum_bound;d++){auto& value_max_d = value_max[d];if(value_max_d == exceptional){continue;}for(INT c = d + d;c <= cost_sum_bound;c++){auto temp = M.Product(AN[c - d],value_max_d);if(temp <= value_sum_bound){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> UnboundedChoiceMulticaseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractUnboundedChoiceMulticaseKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractUnboundedChoiceKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractUnboundedChoiceMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> UnboundedChoiceKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractUnboundedChoiceKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),cost,cost_sum_bound);}TE <TY INT>VE<bool> UnboundedChoiceCostfreeCOructibiilityKnapsack(CO VE<INT>& value,CO INT& value_sum_bound){CO int N = value.SZ();VE<bool> valid(value_sum_bound + 1);for(int i = 0;i < N;i++){auto& value_i = value[i];AS(value_i >= 0);if(value_sum_bound < value_i){continue;}valid[value_i]= true;}auto AN = valid;for(INT d = 1;d < value_sum_bound;d++){if(!valid[d]){continue;}for(INT v = d + d;v <= value_sum_bound;v++){AN[v]|= AN[v - d];}}RE AN;}TE <TY INT> IN INT UnboundedChoiceCostfreeKnapsack(CO VE<INT>& value,CO INT& value_sum_bound){INT AN = 0;auto COructible = UnboundedChoiceCostfreeMulticaseKnapsack(value,value_sum_bound);for(INT v = 0;v <= value_sum_bound;v++){COructible[v]?AN = v:AN;}RE AN;}
#endif
