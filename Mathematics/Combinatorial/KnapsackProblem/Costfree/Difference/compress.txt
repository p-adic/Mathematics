#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Costfree/Difference/a_Body.hpp"
#else
TE <TY T> IN TY set<T>::const_iterator MaximumLeq(CO set<T>& S,CO T& t){auto IT = S.upper_bound(t);RE IT == S.BE()?S.EN():--IT;}TE <TY T> IN TY set<T>::const_iterator MinimumGeq(CO set<T>& S,CO T& t){RE S.lower_bound(t);}

TE <TY INT>INT CostfreeDifferenceKnapsack(CO VE<INT>& value,CO INT& value_bound,int SZ_diff_bound = 0){CO int N = value.SZ();INT value_sum_bound = 0;SZ_diff_bound = min(SZ_diff_bound,N);VE<ll> Comb(N + 1,1);ll comb_sum = Comb[0];for(int i = 1;i <= SZ_diff_bound;i++){if((comb_sum += Comb[i]= Comb[i-1]*(N - 1 - i)/ i)>(value_sum_bound += value_bound)){RE 0;}}for(int i = SZ_diff_bound + 1;i <= N;i++){if(Comb[i - SZ_diff_bound - 1]<(Comb[i]= Comb[i-1]*(N - 1 - i)/ i)){if((comb_sum += Comb[i]- Comb[i - SZ_diff_bound - 1])>(value_sum_bound += value_bound)){RE 0;}}else{break;}}CO int N_back = N / 2;CO int N_front = N - N_back;VE<set<int>> S_non_empty(N_back + 1);VE<set<int>> S_empty(N_back + 1);VE<int> lower_bound(N_back,-1),upper_bound(N_back,1),index = lower_bound;INT AN = value_bound;WH(true){INT temp = 0;int SZ_diff = 0;bool non_empty = false;for(int i = 0;i < N_back;i++){temp += value[i + N_front]* index[i];SZ_diff += index[i];non_empty |= index[i]== -1;}if(SZ_diff >= 0){(non_empty?S_non_empty:S_empty)[SZ_diff].insert(temp);if(SZ_diff == 0 && non_empty){AN = min(AN,abs(temp));}}if(!NextLoopEq(lower_bound,upper_bound,index)){break;}}lower_bound.resize(N_front,-1),upper_bound.resize(N_front,1),index = lower_bound;WH(true){INT temp = 0;int SZ_diff = 0;bool non_empty = false;for(int i = 0;i < N_front;i++){temp += value[i]* index[i];SZ_diff += index[i];non_empty |= index[i]== -1;}CO int SZ_min = max(0,-SZ_diff - SZ_diff_bound);CO int SZ_max = min(N_back,-SZ_diff + SZ_diff_bound);for(int SZ = SZ_min;SZ <= SZ_max;SZ++){CO set<int>& s_non_empty = S_non_empty[SZ];auto IT = MaximumLeq(s_non_empty,-temp);auto EN = s_non_empty.EN();if(IT != EN){AN = min(AN,abs(*IT + temp));}IT = MinimumGeq(s_non_empty,-temp);if(IT != EN){AN = min(AN,abs(*IT + temp));}if(non_empty){CO set<int>& s_empty = S_empty[SZ];IT = MaximumLeq(s_empty,-temp);EN = s_empty.EN();if(IT != EN){AN = min(AN,abs(*IT + temp));}IT = MinimumGeq(s_empty,-temp);if(IT != EN){AN = min(AN,abs(*IT + temp));}}}if(SZ_diff == 0 && non_empty){AN = min(AN,abs(temp));}if(!NextLoopEq(lower_bound,upper_bound,index)){break;}}RE AN;}
#endif

