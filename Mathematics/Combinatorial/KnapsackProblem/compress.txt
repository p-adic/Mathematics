#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/a_Body.hpp"
#else
TE <TY INT> CE INT Log(CO INT& N){INT AN = 0;if(N > 0){WH((N - 1)>> AN > 0){AN++;}}RE AN;}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_ubound < one1));CO U2& one2 = M2.One();AS(!(cost_sum_ubound < one2));pair<U1,U2> AN ={one1,one2};if(N == 1){if(!(cost_sum_bound < cost[0])&& !(value_sum_bound < value[0])){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<U2,U1>> sum_left(PW_left,{one2,one1});for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = M2.Product(sum_left_s_minus.first,cost[i]);sum_left_s.second = M1.Product(sum_left_s_minus.second,value[i]);}CO int PW_right = 1 << N_half_right;VE<pair<U2,U1>> sum_right(PW_right,{one2,one1});for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = M2.Product(sum_right_s_minus.first,cost[i]);sum_right_s.second = M1.Product(sum_right_s_minus.second,value[i]);}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];if(!(cost_sum_bound < sum_left_s.first)&& !(value_sum_bound < sum_left_s.second)){BS2(t,0,PW_right - 1,!(value_sum_bound < M1.Product(sum_left_s.second,sum_right[t].second))&& !(cost_sum_bound < M2.Product(sum_left_s.first,sum_right[t].first))?0:1,0);if(!(M1.Product(sum_left_s.second,sum_right[t].second)< AN.first)){auto& value_max = sum_right[t].second;BS1(u,0,t,sum_right[u].second,value_max);AS(sum_right[u].second == value_max);pair<U1,U2> temp ={M1.Product(sum_left_s.second,value_max),M2.Product(sum_left_s.first,sum_right[u].first)};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}

TE <TY INT,TY U,TY COMM_MONOID>VE<U> AbstractDualMulticaseNegativeCostKnapsack(COMM_MONOID M,CO VE<INT>& value,CO INT& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_lbound,CO U& exceptional){AS(value_sum_bound >= 0);CO int N = value.SZ();AS(int(cost.SZ())== N);VE cost_min(value_sum_bound + 1,exceptional);CO U& one = M.One();AS(!(cost_sum_lbound < exceptional)&& !(one < cost_sum_lbound));cost_min[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(value_i >= 0);auto& cost_i = cost[i];for(INT v = value_sum_bound,v_plus = v + 1;v_plus > value_i;v--,v_plus--){auto& cost_min_v_i = cost_min[v - value_i];if(cost_min_v_i != exceptional){auto temp = M.Product(cost_min[v - value_i],cost_i);if(!(temp < cost_sum_lbound)){auto& cost_min_v = cost_min[v];cost_min_v = cost_min_v == exceptional?MO(temp):min(cost_min_v,temp);}}}}RE cost_min;}TE <TY INT1,TY INT2> IN VE<INT2> DualMulticaseNegativeCostKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_lbound,CO INT2& exceptional){RE AbstractDualMulticaseNegativeCostKnapsack(AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_lbound,exceptional);}TE <TY INT,TY U,TY COMM_MONOID> IN pair<INT,U> AbstractNegativeCostKnapsackFewValues(COMM_MONOID M,CO VE<INT>& value,CO INT& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_bound,CO U& exceptional){pair<INT,U> AN ={0,M.One()};auto cost_min = AbstractDualMulticaseNegativeCostKnapsack(MO(M),value,value_sum_bound,cost,exceptional,exceptional);for(INT v = 0;v <= value_sum_bound;v++){auto& c_v = cost_min[v];c_v == exceptional || cost_sum_ubound < c_v?AN:AN ={v,MO(c_v)};}RE AN;}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractMulticaseNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();AS(!(value_sum_bound < one));VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(cost_i >= 0);for(INT c = cost_sum_bound;c >= cost_i;c--){auto temp = M.Product(AN[c - cost_i],value_i);if(!(value_sum_bound < temp)){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> MulticaseNegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractMulticaseNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,exceptional,cost,cost_sum_bound);}
TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueKnapsackFewCosts(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}

TE <TY INT1,TY INT2> IN pair<INT1,INT2> Knapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){CO int N = value.SZ();RE Log(N)+ Log(min(ll(cost_sum_bound),ll(value_sum_bound)))< ll(N >> 1)?cost_sum_bound < value_sum_bound?AbstractNegativeValueKnapsackFewCosts(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),cost,cost_sum_bound):AbstractNegativeCostKnapsackFewValues(AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound,INT2(-1)):NegativeKnapsack(value,value_sum_bound,cost,cost_sum_bound);}
#endif

