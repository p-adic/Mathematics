#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/a_Body.hpp"
#else
TE <TY INT> CE INT Log(CO INT& N){INT AN = 0;if(N > 0){WH((N - 1)>> AN > 0){AN++;}}RE AN;}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractMulticaseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(!(value_i < one));auto& cost_i = cost[i];AS(cost_i >= 0);if(cost_sum_bound < cost_i || value_sum_bound < value_i){continue;}for(INT c = cost_sum_bound;c >= cost_i;c--){auto temp = M.Product(AN[c - cost_i],value_i);if(temp <= value_sum_bound){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> MulticaseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE Knapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT1(-1),cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractMulticaseKnapsack(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2>VE<INT2> DualMulticaseKnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){VE cost_min(value_sum_bound + 1,INT2(-1));cost_min[0]= 0;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(value_i >= 0);auto& cost_i = cost[i];AS(cost_i >= 0);if(cost_sum_bound < cost_i || value_sum_bound < value_i){continue;}for(INT1 v = value_sum_bound,v_plus = v + 1;v_plus > value_i;v--,v_plus--){auto& cost_min_v_i = cost_min[v - value_i];if(cost_min_v_i != -1){auto temp = cost_min[v - value_i]+ cost_i;if(temp <= cost_sum_bound){auto& cost_min_v = cost_min[v];cost_min_v = cost_min_v == -1?MO(temp):min(cost_min_v,temp);}}}}RE cost_min;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> KnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){auto cost_min = DualMulticaseKnapsackFewValues(N,value,value_sum_bound,cost,cost_sum_bound);pair<INT1,INT2> AN ={0,0};for(INT2 v = 0;v <= value_sum_bound;v++){auto& c_v = cost_min[v];c_v == -1?AN:AN ={v,MO(c_v)};}RE AN;}TE <TY INT1,TY INT2>pair<INT1,INT2> KnapsackFewItems(CRI N,CO VE<INT2>& value,CO INT2& value_sum_bound,CO VE<INT1>& cost,CO INT1& cost_sum_bound){pair<INT1,INT2> AN ={0,0};if(N == 1){if(cost[0]<= cost_sum_bound && value[0]<= value_sum_bound){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<INT2,INT1>> sum_left(PW_left);for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = sum_left_s_minus.first + cost[i];sum_left_s.second = sum_left_s_minus.second + value[i];}CO int PW_right = 1 << N_half_right;VE<pair<INT2,INT1>> sum_right(PW_right);for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = sum_right_s_minus.first + cost[i];sum_right_s.second = sum_right_s_minus.second + value[i];}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];CO pair<INT2,INT1> diff ={cost_sum_bound - sum_left_s.first,value_sum_bound - sum_left_s.second};if(diff.first >= 0 && diff.second >= 0){BS2(t,0,PW_right - 1,sum_right[t].first <= diff.first && sum_right[t].second <= diff.second?0:1,0);if(AN.first <= sum_left_s.second + sum_right[t].second){BS1(u,0,t,sum_right[u].second,sum_right[t].second);pair<INT1,INT2> temp ={sum_left_s.second + sum_right[u].second,sum_left_s.first + sum_right[u].first};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> Knapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){CO int N = value.SZ();RE Log(N)+ Log(min(ll(cost_sum_bound),ll(value_sum_bound)))< ll(N >> 1)?cost_sum_bound < value_sum_bound?AbstractKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,INT2(-1),cost,cost_sum_bound):KnapsackFewValues(N,value,value_sum_bound,cost,cost_sum_bound):KnapsackFewItems(N,value,value_sum_bound,cost,cost_sum_bound);}
#endif

