#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/UnboundedChoice/UnboundedValueSum/NegativeValue/Unstable/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY VALUE,TY INT1,TY COST,TY INT2>VE<U> AbstractNegativeValueUnboundedChoiceMulticaseUnboundedValueSumUnstableKnapsack(COMM_MONOID M,CRI N,VALUE value,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){ST_AS(is_invocable_r_v<U,VALUE,CRI,CRI> && is_invocable_r_v<INT1,COST,CRI,CRI>);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){int choice_stability_num_i = choice_stability_num[i];int choice_num = -1;INT c_min = 0;auto temp = AN;WH(++choice_num < choice_stability_num_i && c_min < cost_sum_bound){VE temp_next(cost_sum_bound + 1,exceptional);auto&& v_i = value(i,choice_num);auto&& c_i = cost(i,choice_num);AS(c_i >= 0);c_min += c_i;for(INT c = cost_sum_bound;c >= c_min;c--){auto& temp_c_i = temp[c - c_i];if(temp_c_i != exceptional){auto& temp_next_c = temp_next[c]= M.Product(temp_c_i,value_i);auto& AN_c = AN[c];AN_c = AN_c == exceptional?temp_next_c:max(AN_c,temp_next_c);}}temp = MO(temp_next);}if(choice_num == choice_stability_num_i){auto&& v_i = value(i,choice_num);auto&& c_i = cost(i,choice_num);AS(one < v_i?c_i > 0:c_i >= 0);CO INT c_max = c_i < cost_sum_bound?cost_sum_bound - c_i:0;for(INT c = c_min;c <= c_max;c++){auto& temp_c = temp[c];if(temp_c != exceptional){auto& temp_c_i = temp[c + c_i];auto temp_c_i_new = M.Product(temp_c,v_i);temp_c_i = temp_c_i == exceptional?MO(temp_c_i_new):max(temp_c_i,temp_c_i_new);auto& AN_c_i = AN[c + c_i];AN_c_i = AN_c_i == exceptional?temp_c_i:max(AN_c_i,temp_c_i);}}}}RE AN;}TE <TY VALUE,TY INT1,TY COST,TY INT2> IN VE<ret_t<VALUE,int,int>> NegativeValueUnboundedChoiceMulticaseUnboundedValueSumUnstableKnapsack(CRI N,VALUE value,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){RE AbstractNegativeValueUnboundedChoiceMulticaseUnboundedValueSumUnstableKnapsack(AdditiveMonoid<ret_t<VALUE,int,int>>(),value,ret_t<VALUE,int,int>(-1),MO(cost),cost_sum_bound,choice_stability_num);}TE <TY U,TY COMM_MONOID,TY VALUE,TY INT1,TY COST,TY INT2> IN pair<U,INT1> AbstractNegativeValueUnboundedChoiceUnboundedValueSumUnstableKnapsack(COMM_MONOID M,CRI N,VALUE value,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){pair<U,INT1> AN ={M.One(),0};auto value_max = AbstractUnboundedChoiceMulticaseUnstableKnapsack(MO(M),MO(value),exceptional,MO(cost),cost_sum_bound,choice_stability_num);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY VALUE,TY INT1,TY COST,TY INT2> IN pair<ret_t<VALUE,int,int>,INT1> NegativeValueUnboundedChoiceUnboundedValueSumUnstableKnapsack(CRI N,VALUE value,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){RE AbstractNegativeValueUnboundedChoiceUnboundedValueSumUnstableKnapsack(AdditiveMonoid<ret_t<VALUE,int,int>>(),MO(value),ret_t<VALUE,int,int>(-1),MO(cost),cost_sum_bound,choice_stability_num);}
#endif
