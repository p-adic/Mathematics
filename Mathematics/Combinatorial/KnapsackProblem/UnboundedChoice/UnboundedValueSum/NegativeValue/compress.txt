#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/UnboundedChoice/NegativeValue/UnboundedValueSum/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractNegativeValueUnboundedChoiceMulticaseUnboundedValueSumKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE<U> value_max(cost_sum_bound + 1,exceptional);value_max[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(cost_i > 0 ||(cost_i == 0 && !(one < value_i)));auto& value_max_i = value_max[cost_i];value_max_i = value_max_i == exceptional?value_i:max(value_max[cost_i],value_i);}auto AN = value_max;for(INT d = 1;d < cost_sum_bound;d++){auto& value_max_d = value_max[d];if(value_max_d == exceptional){continue;}for(INT c = d + d;c <= cost_sum_bound;c++){auto temp = M.Product(AN[c - d],value_max_d);if(!(temp < one)){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> NegativeValueUnboundedChoiceMulticaseUnboundedValueSumKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueUnboundedChoiceMulticaseUnboundedValueSumKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueUnboundedChoiceUnboundedValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractNegativeValueUnboundedChoiceMulticaseUnboundedValueSumKnapsack(MO(M),value,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeValueUnboundedChoiceUnboundedValueKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractUnboundedChoiceUnboundedValueKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}
#endif
