#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/UnboundedChoice/NegativeValue/Unstable/Dependent/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY VALUE,TY INT1,TY COST,TY INT2>VE<U> AbstractNegativeValueUnboundedChoiceMulticaseUnstableKnapsack(COMM_MONOID M,VALUE value,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){ST_AS(is_invocable_r_v<U,VALUE,CRI,CRL> && is_invocable_r_v<INT1,COST,CRI,CRL>);CO int N = choice_stability_num.SZ();auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){int choice_stability_num_i = choice_stability_num[i];int choice_num = -1;INT1 c_min = 0;auto temp = AN;WH(++choice_num < choice_stability_num_i && c_min < cost_sum_bound){VE temp_next(cost_sum_bound + 1,exceptional);auto&& v_i = value(i,choice_num);auto&& c_i = cost(i,choice_num);AS(c_i >= 0);c_min += c_i;for(INT1 c = cost_sum_bound;c >= c_min;c--){auto& temp_c_i = temp[c - c_i];if(temp_c_i != exceptional){auto& temp_next_c = temp_next[c]= M.Product(temp_c_i,v_i);auto& AN_c = AN[c];AN_c = AN_c == exceptional?temp_next_c:max(AN_c,temp_next_c);}}temp = MO(temp_next);}if(choice_num == choice_stability_num_i){auto&& v_i = value(i,choice_num);auto&& c_i = cost(i,choice_num);AS(one < v_i?c_i > 0:c_i >= 0);CO INT1 c_max = c_i < cost_sum_bound?cost_sum_bound - c_i:0;for(INT1 c = c_min;c <= c_max;c++){auto& temp_c = temp[c];if(temp_c != exceptional){auto& temp_c_i = temp[c + c_i];auto temp_c_i_new = M.Product(temp_c,v_i);temp_c_i = temp_c_i == exceptional?MO(temp_c_i_new):max(temp_c_i,temp_c_i_new);auto& AN_c_i = AN[c + c_i];AN_c_i = AN_c_i == exceptional?temp_c_i:max(AN_c_i,temp_c_i);}}}}RE AN;}TE <TY INT1,TY VALUE,TY INT2,TY COST,TY INT3> IN VE<INT1> NegativeValueUnboundedChoiceMulticaseUnstableKnapsack(VALUE value,CO INT1& exceptional,COST cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_stability_num){RE AbstractNegativeValueUnboundedChoiceMulticaseUnstableKnapsack(AdditiveMonoid<INT1>(),value,exceptional,MO(cost),cost_sum_bound,choice_stability_num);}TE <TY U,TY COMM_MONOID,TY VALUE,TY INT1,TY COST,TY INT2> IN pair<U,INT1> AbstractNegativeValueUnboundedChoiceUnstableKnapsack(COMM_MONOID M,VALUE value,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_stability_num){pair<U,INT1> AN ={M.One(),0};auto value_max = AbstractUnboundedChoiceMulticaseUnstableKnapsack(MO(M),MO(value),exceptional,MO(cost),cost_sum_bound,choice_stability_num);for(INT1 c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY VALUE,TY INT2,TY COST,TY INT3> IN pair<INT1,INT2> NegativeValueUnboundedChoiceUnstableKnapsack(VALUE value,CO INT1& exceptional,COST cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_stability_num){RE AbstractNegativeValueUnboundedChoiceUnstableKnapsack(AdditiveMonoid<ret_t<VALUE,int,ll>>(),MO(value),exceptional,MO(cost),cost_sum_bound,choice_stability_num);}

TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY U,TY N_MODULE,TY VALUE1,TY VALUE2,TY INT1,TY INT2,TY INT3>CL DependentItemData{PU:N_MODULE m_M;int m_N1;VALUE1 m_value1;VALUE2 m_value2;CO VE<INT1>* m_p_choice_stability_num1;CO VE<INT2>* m_p_dependence;CO VE<INT3>* m_p_init;CO VE<INT3>* m_p_diff;IN DependentItemData(N_MODULE M,int N1,VALUE1 value1,VALUE2 value2,CO VE<INT1>& choice_stability_num1,CO VE<INT2>& dependence,CO VE<INT3>& init,CO VE<INT3>& diff);U OP()(CRI i,CRL m);};
TE <TY U,TY N_MODULE,TY VALUE1,TY VALUE2,TY INT1,TY INT2,TY INT3> IN DependentItemData<U,N_MODULE,VALUE1,VALUE2,INT1,INT2,INT3>::DependentItemData(N_MODULE M,int N1,VALUE1 value1,VALUE2 value2,CO VE<INT1>& choice_stability_num1,CO VE<INT2>& dependence,CO VE<INT3>& init,CO VE<INT3>& diff):m_M(MO(M)),m_N1(MO(N1)),m_value1(MO(value1)),m_value2(MO(value2)),m_p_choice_stability_num1(&choice_stability_num1),m_p_dependence(&dependence),m_p_init(&init),m_p_diff(&diff){ST_AS(is_invocable_r_v<U,VALUE1,CRI,CRL> && is_invocable_r_v<U,VALUE2,CRI,CRL>);CO int N2 = m_p_dependence->SZ();AS(N2 == int(m_p_dependence->SZ())&& N2 == int(m_p_init->SZ())&& N2 == int(m_p_diff->SZ()));for(int i = 0;i < N2;i++){AS(0 <= dependence[i]&& dependence[i]< m_N1 && init[i]>= 0 && diff[i]>= 1);}}TE <TY U,TY N_MODULE,TY VALUE1,TY VALUE2,TY INT1,TY INT2,TY INT3>U DependentItemData<U,N_MODULE,VALUE1,VALUE2,INT1,INT2,INT3>::OP()(CRI i,CRL m){if(i < m_N1){RE m_value1(i,m);}CO int N2 = m_p_init->SZ();CO int i_shifted = i - m_N1;AS(i_shifted < N2);CRI j =(*m_p_dependence)[i_shifted];CO INT2& choice_stability_num1_j =(*m_p_choice_stability_num1)[j];CO INT3& init_i =(*m_p_init)[i_shifted];CO INT3& diff_i =(*m_p_diff)[i_shifted];CO ll n_min = m == 0?0:init_i +(m - 1)* diff_i;CO ll n_max = init_i + m * diff_i - 1;CO ll n_mid = min(max(n_min,ll(choice_stability_num1_j)),n_max + 1);U AN = m_M.Product(m_value2(i_shifted,m),m_M.PW(m_value1(j,choice_stability_num1_j),n_max - n_mid + 1));for(ll n = n_min;n < n_mid;n++){AN = m_M.Product(MO(AN),m_value1(j,n));}RE AN;}TE <TY N_MODULE,TY VALUE1,TY VALUE2,TY COST1,TY COST2,TY INT1,TY INT2,TY INT3>pair<DependentItemData<ret_t<VALUE1,int,ll>,N_MODULE,VALUE1,VALUE2,INT1,INT2,INT3>,DependentItemData<ret_t<COST1,int,ll>,Module<ll,ret_t<COST1,int,ll>>,COST1,COST2,INT1,INT2,INT3>> GetDependentItemData(N_MODULE M,VALUE1 value1,VALUE2 value2,COST1 cost1,COST2 cost2,VE<INT1>& choice_stability_num1,CO VE<INT1>& choice_stability_num2,CO VE<INT2>& dependence,CO VE<INT3>& init,CO VE<INT3>& diff){CO int N1 = choice_stability_num1.SZ();CO int N2 = choice_stability_num2.SZ();US U = ret_t<VALUE1,int,ll>;US INT = ret_t<COST1,int,ll>;ST_AS(!is_same_v<INT,int> && !is_same_v<INT,uint>);DependentItemData<U,N_MODULE,VALUE1,VALUE2,INT1,INT2,INT3> value{MO(M),N1,MO(value1),MO(value2),choice_stability_num1,dependence,init,diff};DependentItemData<INT,Module<ll,INT>,COST1,COST2,INT1,INT2,INT3> cost{Module<ll,INT>(),N1,MO(cost1),MO(cost2),choice_stability_num1,dependence,init,diff};for(int i = 0;i < N2;i++){choice_stability_num1.push_back(max((choice_stability_num1[dependence[i]]- init[i]+ diff[i]- 1)/ diff[i]+ 1,choice_stability_num2[i]));}RE{MO(value),MO(cost)};}TE <TY U,TY N_MODULE,TY VALUE1,TY VALUE2,TY INT1,TY COST1,TY COST2,TY INT2,TY INT3,TY INT4> IN VE<U> AbstractNegativeValueUnboundedChoiceMulticaseUnstableDependentKnapsack(N_MODULE M,VALUE1 value1,VALUE2 value2,CO U& exceptional,COST1 cost1,COST2 cost2,CO INT1& cost_sum_bound,VE<INT2>& choice_stability_num1,CO VE<INT2>& choice_stability_num2,CO VE<INT3>& dependence,CO VE<INT4>& init,CO VE<INT4>& diff){auto[value,cost]= GetDependentItemData(M,MO(value1),MO(value2),MO(cost1),MO(cost2),choice_stability_num1,choice_stability_num2,dependence,init,diff);RE AbstractNegativeValueUnboundedChoiceMulticaseUnstableKnapsack(MO(M),MO(value),exceptional,MO(cost),cost_sum_bound,choice_stability_num1);}TE <TY INT1,TY VALUE1,TY VALUE2,TY INT2,TY COST1,TY COST2,TY INT3,TY INT4,TY INT5> IN VE<INT1> NegativeValueUnboundedChoiceMulticaseUnstableDependentKnapsack(VALUE1 value1,VALUE2 value2,CO INT1& exceptional,COST1 cost1,COST2 cost2,CO INT2& cost_sum_bound,VE<INT3>& choice_stability_num1,CO VE<INT3>& choice_stability_num2,CO VE<INT4>& dependence,CO VE<INT5>& init,CO VE<INT5>& diff){RE AbstractNegativeValueUnboundedChoiceMulticaseUnstableDependentKnapsack(Module<ll,ret_t<VALUE1,int,ll>>(),MO(value1),MO(value2),exceptional,MO(cost1),MO(cost2),cost_sum_bound,choice_stability_num1,choice_stability_num2,dependence,init,diff);}TE <TY U,TY N_MODULE,TY VALUE1,TY VALUE2,TY INT1,TY COST1,TY COST2,TY INT2,TY INT3,TY INT4> IN pair<U,INT1> AbstractNegativeValueUnboundedChoiceUnstableDependentKnapsack(N_MODULE M,VALUE1 value1,VALUE2 value2,CO U& exceptional,COST1 cost1,COST2 cost2,CO INT1& cost_sum_bound,VE<INT2>& choice_stability_num1,CO VE<INT2>& choice_stability_num2,CO VE<INT3>& dependence,CO VE<INT4>& init,CO VE<INT4>& diff){pair<U,INT1> AN ={M.One(),0};auto value_max = AbstractNegativeValueUnboundedChoiceMulticaseUnstableDependentKnapsack(MO(M),MO(value1),MO(value2),exceptional,MO(cost1),MO(cost2),cost_sum_bound,choice_stability_num1,choice_stability_num2,dependence,init,diff);for(INT1 c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY VALUE1,TY VALUE2,TY INT2,TY COST1,TY COST2,TY INT3,TY INT4,TY INT5> IN pair<INT1,INT2> NegativeValueUnboundedChoiceUnstableDependentKnapsack(VALUE1 value1,VALUE2 value2,CO INT1& exceptional,COST1 cost1,COST2 cost2,CO INT2& cost_sum_bound,VE<INT3>& choice_stability_num1,CO VE<INT3>& choice_stability_num2,CO VE<INT4>& dependence,CO VE<INT5>& init,CO VE<INT5>& diff){RE AbstractNegativeValueUnboundedChoiceUnstableDependentKnapsack(Module<ll,ret_t<VALUE1,int,ll>>(),MO(value1),MO(value2),exceptional,MO(cost1),MO(cost2),cost_sum_bound,choice_stability_num1,choice_stability_num2,dependence,init,diff);}
#endif
