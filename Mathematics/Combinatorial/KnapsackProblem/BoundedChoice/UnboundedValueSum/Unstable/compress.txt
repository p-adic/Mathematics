#ifdef
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/BoundedChoice/NegativeValue/UnstableCost/a_Body.hpp"
#else
TE <TY U,TY N_MODULE,TY INT1,TY INT2>U AbstractValueBoundedChoiceValueSumBound(N_MODULE M,CO VE<U>& value,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){CO int N = value.SZ();U AN0 = M.One(),AN1 = AN0;for(int i = 0;i < N;i++){AN0 = max(AN0,value[i]);AN1 = M.Product(MO(AN1),M.PW(value[i],int(choice_num_bound[i])));}RE max(M.PW(MO(AN0),int(cost_sum_bound)),AN1);}TE <TY INT1,TY INT2,TY INT3> IN INT1 BoundedChoiceValueSumBound(CO VE<INT1>& value,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractValueBoundedChoiceValueSumBound(Module<int,INT1>(),value,cost_sum_bound,choice_num_bound);}

TE <TY U,TY COMM_MONOID,TY INT1,TY COST,TY INT2>VE<U> AbstractBoundedChoiceUnstableCostMulticaseNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){ST_AS(is_invocable_r_v<INT,COST,CRI,CRI> && is_invocable_v<CO VE<int>&,CRI>);CO int N = value.SZ();auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(!(value_i < one));ll choice_num_bound_i = choice_num_bound[i];AS(choice_num_bound_i <= choice_num_bound_max);int choice_num_bound_fixed_i = int(min(choice_num_bound_i,ll(cost_sum_bound + 1)));INT c_min = 0;auto temp = AN;for(ll choice_num = 0;choice_num < choice_num_bound_fixed_i && c_min < cost_sum_bound;choice_num++){auto&& c_i = cost(i,choice_num);AS(c_i >= 1);c_min += c_i;for(INT c = cost_sum_bound;c >= c_min;c--){auto& AN_c = AN[c];auto& temp_c_i = temp[c - c_i];if(temp_c_i != exceptional){auto& temp_c = temp[c]= M.Product(temp_c_i,value_i);AN_c = AN_c == exceptional?temp_c:max(AN_c,temp_c);}}}}RE AN;}TE <TY INT1,TY INT2,TY COST,TY INT3> IN VE<INT1> BoundedChoiceUnstableCostMulticaseNegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,COST cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractBoundedChoiceUnstableCostMulticaseNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,exceptional,MO(cost),cost_sum_bound,choice_num_bound);}TE <TY U,TY COMM_MONOID,TY INT1,TY COST,TY INT2> IN pair<U,INT1> AbstractBoundedChoiceUnstableCostNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,COST cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){pair<U,INT1> AN ={M.One(),0};auto value_max = AbstractBoundedChoiceUnstableCostMulticaseNegativeValueKnapsack(MO(M),value,value_sum_bound,exceptional,MO(cost),cost_sum_bound,choice_num_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2,TY COST,TY INT3> IN pair<INT1,INT2> BoundedChoiceUnstableCostNegativeValueKnapsack(CO VE<INT2>& value,CO INT1& value_sum_bound,CO INT1& exceptional,COST cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractBoundedChoiceUnstableCostNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,exceptional,MO(cost),cost_sum_bound,choice_num_bound);}
#endif

