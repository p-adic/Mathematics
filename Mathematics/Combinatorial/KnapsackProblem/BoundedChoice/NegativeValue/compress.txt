#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/BoundedChoice/NegativeValue/a_Body.hpp"
#else
TE <TY INT> CE INT Log(CO INT& N){INT AN = 0;if(N > 0){WH((N - 1)>> AN > 0){AN++;}}RE AN;}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_bound < one1));CO U2& one2 = M2.One();AS(!(cost_sum_bound < one2));pair<U1,U2> AN ={one1,one2};if(N == 1){if(!(cost_sum_bound < cost[0])&& !(value_sum_bound < value[0])){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<U2,U1>> sum_left(PW_left,{one2,one1});for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = M2.Product(sum_left_s_minus.first,cost[i]);sum_left_s.second = M1.Product(sum_left_s_minus.second,value[i]);}CO int PW_right = 1 << N_half_right;VE<pair<U2,U1>> sum_right(PW_right,{one2,one1});for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = M2.Product(sum_right_s_minus.first,cost[i]);sum_right_s.second = M1.Product(sum_right_s_minus.second,value[i]);}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];if(!(cost_sum_bound < sum_left_s.first)&& !(value_sum_bound < sum_left_s.second)){BS2(t,0,PW_right - 1,!(value_sum_bound < M1.Product(sum_left_s.second,sum_right[t].second))&& !(cost_sum_bound < M2.Product(sum_left_s.first,sum_right[t].first))?0:1,0);if(!(M1.Product(sum_left_s.second,sum_right[t].second)< AN.first)){auto& value_max = sum_right[t].second;BS1(u,0,t,sum_right[u].second,value_max);AS(sum_right[u].second == value_max);pair<U1,U2> temp ={M1.Product(sum_left_s.second,value_max),M2.Product(sum_left_s.first,sum_right[u].first)};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractMulticaseNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();AS(!(value_sum_bound < one));VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(cost_i >= 0);for(INT c = cost_sum_bound;c >= cost_i;c--){auto temp = M.Product(AN[c - cost_i],value_i);if(!(value_sum_bound < temp)){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> MulticaseNegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractMulticaseNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,exceptional,cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueKnapsackFewCosts(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractMulticaseNegativeValueKnapsack(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}
TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();RE Log(ll(cost_sum_bound))< ll(N >> 1)?AbstractNegativeValeKnapsackFewCosts(MO(M),value,value_sum_bound,exceptional,cost,cost_sum_bound):AbstractNegativeKnapsack(MO(M),value,value_sum_bound,cost,cost_sum_bound);}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,value_sum_bound,exceptional,cost,cost_sum_bound);}

TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY U,TY N_MODULE,TY INT1,TY INT2>U AbstractValueBoundedChoiceValueSumBound(N_MODULE M,CO VE<U>& value,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){CO int N = value.SZ();U AN0 = M.One(),AN1 = AN0;for(int i = 0;i < N;i++){AN0 = max(AN0,value[i]);AN1 = M.Product(MO(AN1),M.PW(value[i],int(choice_num_bound[i])));}RE max(M.PW(MO(AN0),int(cost_sum_bound)),AN1);}TE <TY INT1,TY INT2,TY INT3> IN INT1 BoundedChoiceValueSumBound(CO VE<INT1>& value,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractValueBoundedChoiceValueSumBound(Module<int,INT1>(),value,cost_sum_bound,choice_num_bound);}
TE <TY U1,TY N_MODULE1,TY U2,TY N_MODULE2,TY INT> VO SetIteratedItem(N_MODULE1 M1,N_MODULE2 M2,CRI N,CO VE<U1>& value,VE<U1>& value_new,CO VE<U2>& cost,VE<U2>& cost_new,CO VE<INT>& choice_num_bound){ST_AS(!is_same_v<U1,int> && !is_same_v<U1,uint>);ST_AS(!is_same_v<U2,int> && !is_same_v<U2,uint>);for(int i = 0;i < N;i++){auto value_i = value[i];auto cost_i = cost[i];ll m = choice_num_bound[i];ll p = 1;WH(p <= m){m -= p;value_new.push_back(value_i);cost_new.push_back(cost_i);value_i = M1.Product(value_i,value_i);cost_i = M2.Product(cost_i,cost_i);p <<= 1;}if(m > 0){value_new.push_back(M1.PW(value[i],m));cost_new.push_back(M2.PW(cost[i],m));}}RE;}

TE <TY U,TY N_MODULE,TY INT1,TY INT2> IN VE<U> AbstractBoundedChoiceMulticaseNegativeValueKnapsack(N_MODULE M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT1>& cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){VE<U> value_new;VE<INT1> cost_new;SetIteratedItem(M,Module<int,INT1>(),N,value,value_new,cost,cost_new,choice_num_bound);RE AbstractMulticaseNegativeValueKnapsack(MO(M),value_new,value_sum_bound,exceptional,cost_new,cost_sum_bound);}TE <TY INT1,TY INT2,TY INT3> IN VE<INT1> BoundedChoiceMulticaseNegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,CO VE<INT1>& cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractBoundedChoiceMulticaseNegativeValueKnapsack(AdditiveGroup<INT1>(),value,value_sum_bound,exceptional,cost,cost_sum_bound,choice_num_bound);}TE <TY U,TY N_MODULE,TY INT1,TY INT2> IN pair<U,INT1> AbstractBoundedChoiceNegativeValueKnapsack(N_MODULE M,CO VE<U>& value,CO U& value_sum_bound,CO U& exceptional,CO VE<INT1>& cost,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){VE<U> value_new;VE<INT1> cost_new;SetIteratedItem(M,Module<int,INT1>(),N,value,value_new,cost,cost_new,choice_num_bound);RE AbstractNegativeValueKnapsack(MO(M),value_new,value_sum_bound,exceptional,cost_new,cost_sum_bound);}TE <TY INT1,TY INT2,TY INT3> IN pair<INT1,INT2> BoundedChoiceNegativeValueKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractBoundedChoiceNegativeValueKnapsack(MODULE<int,INT1>(),value,value_sum_bound,exceptional,cost,cost_sum_bound,choice_num_bound);}
#endif

