#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/BoundedChoice/a_Body.hpp"
#else
TE <TY INT> CE INT Log(CO INT& N){INT AN = 0;if(N > 0){WH((N - 1)>> AN > 0){AN++;}}RE AN;}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeBoundedValueSumKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_bound < one1));CO U2& one2 = M2.One();AS(!(cost_sum_bound < one2));pair<U1,U2> AN ={one1,one2};if(N == 1){if(!(cost_sum_bound < cost[0])&& !(value_sum_bound < value[0])){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<U2,U1>> sum_left(PW_left,{one2,one1});for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = M2.Product(sum_left_s_minus.first,cost[i]);sum_left_s.second = M1.Product(sum_left_s_minus.second,value[i]);}CO int PW_right = 1 << N_half_right;VE<pair<U2,U1>> sum_right(PW_right,{one2,one1});for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = M2.Product(sum_right_s_minus.first,cost[i]);sum_right_s.second = M1.Product(sum_right_s_minus.second,value[i]);}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];if(!(cost_sum_bound < sum_left_s.first)&& !(value_sum_bound < sum_left_s.second)){BS2(t,0,PW_right - 1,!(value_sum_bound < M1.Product(sum_left_s.second,sum_right[t].second))&& !(cost_sum_bound < M2.Product(sum_left_s.first,sum_right[t].first))?0:1,0);if(!(M1.Product(sum_left_s.second,sum_right[t].second)< AN.first)){auto& value_max = sum_right[t].second;BS1(u,0,t,sum_right[u].second,value_max);AS(sum_right[u].second == value_max);pair<U1,U2> temp ={M1.Product(sum_left_s.second,value_max),M2.Product(sum_left_s.first,sum_right[u].first)};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeBoundedValueSumKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeBoundedValueSumKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}

TE <TY INT,TY U,TY COMM_MONOID>VE<U> AbstractNegativeCostBoundedValueSumValuewiseKnapsack(COMM_MONOID M,CO VE<INT>& value,CO INT& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_lbound,CO U& exceptional){AS(value_sum_bound >= 0);CO int N = value.SZ();AS(int(cost.SZ())== N);VE cost_min(value_sum_bound + 1,exceptional);CO U& one = M.One();AS(!(one < cost_sum_lbound));cost_min[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(value_i >= 0);auto& cost_i = cost[i];for(INT v = value_sum_bound,v_plus = v + 1;v_plus > value_i;v--,v_plus--){auto& cost_min_v_i = cost_min[v - value_i];if(cost_min_v_i != exceptional){auto temp = M.Product(cost_min[v - value_i],cost_i);if(!(temp < cost_sum_lbound)){auto& cost_min_v = cost_min[v];cost_min_v = cost_min_v == exceptional?MO(temp):min(cost_min_v,temp);}}}}RE cost_min;}TE <TY INT1,TY INT2> IN VE<INT2> NegativeCostBoundedValueSumValuewiseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_lbound,CO INT2& exceptional){RE AbstractNegativeCostBoundedValueSumValuewiseKnapsack(AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_lbound,exceptional);}

TE <TY INT,TY U,TY COMM_MONOID> IN pair<INT,U> AbstractNegativeCostBoundedValueSumKnapsackFewValues(COMM_MONOID M,CO VE<INT>& value,CO INT& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_bound,CO U& exceptional){pair<INT,U> AN ={0,M.One()};auto cost_min = AbstractNegativeCostBoundedValueSumValuewiseKnapsack(MO(M),value,value_sum_bound,cost,exceptional,exceptional);for(INT v = 0;v <= value_sum_bound;v++){auto& c_v = cost_min[v];c_v == exceptional || cost_sum_bound < c_v?AN:AN ={v,MO(c_v)};}RE AN;}TE <TY INT,TY U,TY COMM_MONOID> IN pair<INT,U> AbstractNegativeCostBoundedValueSumKnapsack(COMM_MONOID M,CO VE<INT>& value,CO INT& value_sum_bound,CO VE<U>& cost,CO U& cost_sum_bound,CO U& exceptional){CO int N = value.SZ();RE Log(ll(value_sum_bound))< ll(N >> 1)?AbstractNegativeCostBoundedValueSumKnapsackFewValues(MO(M),value,value_sum_bound,cost,cost_sum_bound,exceptional):AbstractNegativeBoundedValueSumKnapsack(AdditiveMonoid<INT>(),MO(M),value,value_sum_bound,cost,cost_sum_bound);}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeCostBoundedValueSumKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO INT2& exceptional){RE AbstractNegativeCostBoundedValueSumKnapsack(AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound,exceptional);}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractValueCostwiseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];AS(!(value_i < one));auto& cost_i = cost[i];AS(cost_i >= 0);for(INT c = cost_sum_bound;c >= cost_i;c--){auto temp = M.Product(AN[c - cost_i],value_i);AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> CostwiseKnapsack(CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractValueCostwiseKnapsack(AdditiveMonoid<INT1>(),value,INT1(-1),cost,cost_sum_bound);}

TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractValueKnapsackFewCosts(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractValueCostwiseKnapsack(MO(M),value,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();RE Log(ll(cost_sum_bound))< ll(N >> 1)?AbstractValueKnapsackFewCosts(MO(M),value,exceptional,cost,cost_sum_bound):AbstractNegativeBoundedValueSumKnapsack(M,AdditiveMonoid<INT>(),value,AbstractValueSumBound(M,value),cost,cost_sum_bound);}TE <TY INT1,TY INT2> IN pair<INT1,INT2> Knapsack(CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound){CO INT1 value_sum_bound = ValueSumBound(value);RE ll(cost_sum_bound)< ll(value_sum_bound)?AbstractValueKnapsack(AdditiveMonoid<INT1>(),value,INT1(-1),cost,cost_sum_bound):NegativeCostBoundedValueSumKnapsack(value,value_sum_bound,cost,cost_sum_bound,INT2(-1));}

TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY U,TY N_MODULE,TY INT1,TY INT2>U AbstractValueBoundedChoiceValueSumBound(N_MODULE M,CO VE<U>& value,CO INT1& cost_sum_bound,CO VE<INT2>& choice_num_bound){CO int N = value.SZ();U AN0 = M.One(),AN1 = AN0;for(int i = 0;i < N;i++){AN0 = max(AN0,value[i]);AN1 = M.Product(MO(AN1),M.PW(value[i],int(choice_num_bound[i])));}RE max(M.PW(MO(AN0),int(cost_sum_bound)),AN1);}TE <TY INT1,TY INT2,TY INT3> IN INT1 BoundedChoiceValueSumBound(CO VE<INT1>& value,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){RE AbstractValueBoundedChoiceValueSumBound(Module<int,INT1>(),value,cost_sum_bound,choice_num_bound);}

TE <TY U1,TY N_MODULE1,TY U2,TY N_MODULE2,TY INT>VO SetIteratedItem(N_MODULE1 M1,N_MODULE2 M2,CRI N,CO VE<U1>& value,VE<U1>& value_new,CO VE<U2>& cost,VE<U2>& cost_new,CO VE<INT>& choice_num_bound){ST_AS(!is_same_v<U1,int> && !is_same_v<U1,uint>);ST_AS(!is_same_v<U2,int> && !is_same_v<U2,uint>);for(int i = 0;i < N;i++){auto value_i = value[i];auto cost_i = cost[i];ll m = choice_num_bound[i];ll p = 1;WH(p <= m){m -= p;value_new.push_back(value_i);cost_new.push_back(cost_i);value_i = M1.Product(value_i,value_i);cost_i = M2.Product(cost_i,cost_i);p <<= 1;}if(m > 0){value_new.push_back(M1.PW(value[i],m));cost_new.push_back(M2.PW(cost[i],m));}}RE;}TE <TY INT1,TY INT2,TY INT3> IN pair<INT1,INT2> BoundedChoiceKnapsackFewItems(CRI N,CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){VE<INT1> value_new;VE<INT2> cost_new;SetIteratedItem(Module<int,INT1>(),Module<int,INT2>(),N,value,value_new,cost,cost_new,MO(choice_num_bound));RE Knapsack(value_new,cost_new,cost_sum_bound);}TE <TY INT1,TY INT2,TY INT3>pair<INT1,INT2> BoundedChoiceKnapsackFewValues(CRI N,CO VE<INT1>& value,CO INT1& value_bound,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){CO INT1 value_sum_range = min(value_sum_bound,value_bound * value_bound * INT1(N));VE<INT1> value_new{};VE<INT2> cost_new{};VE<int> choice_num_bound_new(N);for(int i = 0;i < N;i++){AS(value[i]>= 0);choice_num_bound_new[i]= value[i]> 0?int(min(ll(choice_num_bound[i]),ll(value_bound))):0;}SetIteratedItem(Module<int,INT1>(),Module<int,INT2>(),N,value,value_new,cost,cost_new,choice_num_bound_new);auto cost_min = NegativeCostBoundedValueSumValuewiseKnapsack(value_new,value_sum_range,cost_new,INT2(0),INT2(-1));pair<INT1,INT2> AN ={0,0};VE<pair<double,int>> item(N);for(int i = 0;i < N;i++){item[i]={double(cost[i])/ value[i],i};value[i]> 0?choice_num_bound_new[i]= choice_num_bound[i]- choice_num_bound_new[i]:0;}sort(item.BE(),item.EN());for(INT1 v = 0;v <= value_sum_range;v++){auto& c_v = cost_min[v];if(c_v != -1 && c_v <= cost_sum_bound){ll value_rest = value_sum_bound - v;ll cost_rest = cost_sum_bound - c_v;for(int j = 0;j < N;j++){CRI i = item[j].second;ll num = choice_num_bound_new[i];num = min(num,value_rest / ll(value[i]));cost[i]> 0?num = min(num,cost_rest / ll(cost[i])):num;value_rest -= ll(value[i])* num;cost_rest -= ll(cost[i])* num;}pair<INT1,INT2> temp ={value_sum_bound - value_rest,cost_sum_bound - cost_rest};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}RE AN;}TE <TY INT1,TY INT2,TY INT3> IN pair<INT1,INT2> BoundedChoiceKnapsack(CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CO VE<INT3>& choice_num_bound){CO int N = value.SZ();CO INT1 value_sum_bound = BoundedChoiceValueSumBound(value,cost_sum_bound,choice_num_bound);INT1 v_max = 0;ll cn_max = 0;for(int i = 0;i < N;i++){v_max = max(v_max,value[i]);value[i]> 0?cn_max = max(cn_max,min(ll(choice_num_bound[i]),value_sum_bound)):cn_max;}CO ll log_N = Log(N),log_v_max = Log(ll(v_max)),log_cn_max = Log(cn_max);RE log_N + min(Log(min(ll(cost_sum_bound),ll(value_sum_bound))),log_cn_max +(N >> 1))+ Log(log_cn_max)<(log_N << 1)+(log_v_max << 1)+ Log(log_v_max)?BoundedChoiceKnapsackFewItems(N,value,cost,cost_sum_bound,choice_num_bound):BoundedChoiceKnapsackFewValues(N,value,v_max,value_sum_bound,cost,cost_sum_bound,choice_num_bound);}
#endif
