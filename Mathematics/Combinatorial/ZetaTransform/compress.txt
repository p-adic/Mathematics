#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Algebra/Monoid/Semirng/Ring/Algebra/a_Body.hpp"
#else
TE <TY R,TY U>CL VirtualRSet:VI PU UnderlyingSet<U>{PU:VI U Action(CO R& r,U u)= 0;IN U PW(U u,CO R& r);IN U ScalarProduct(CO R& r,U u);};TE <TY U,TY MAGMA>CL RegularRSet:VI PU VirtualRSet<U,U>,PU MAGMA{PU:IN RegularRSet(MAGMA magma);IN U Action(CO U& r,U u);};TE <TY MAGMA> RegularRSet(MAGMA magma)-> RegularRSet<inner_t<MAGMA>,MAGMA>;TE <TY R,TY U,TY O_U>CL AbstractRSet:VI PU VirtualRSet<R,U>{PU:O_U m_o_U;IN AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U);IN U Action(CO R& r,U u);};TE <TY R,TY U,TY O_U,TY GROUP>CL AbstractModule:PU AbstractRSet<R,U,O_U>,PU GROUP{PU:IN AbstractModule(CO R& dummy,O_U o_U,GROUP M);};TE <TY R,TY O_U,TY GROUP> AbstractModule(CO R& dummy,O_U o_U,GROUP M)-> AbstractModule<R,inner_t<GROUP>,O_U,GROUP>;TE <TY R,TY U>CL Module:VI PU VirtualRSet<R,U>,PU AdditiveGroup<U>{PU:IN U Action(CO R& r,U u);};
TE <TY R,TY MAGMA> IN RegularRSet<R,MAGMA>::RegularRSet(MAGMA magma):MAGMA(MO(magma)){}TE <TY R,TY U,TY O_U> IN AbstractRSet<R,U,O_U>::AbstractRSet(CO R& dummy0,CO U& dummy1,O_U o_U):m_o_U(MO(o_U)){ST_AS(is_invocable_r_v<U,O_U,R,U>);}TE <TY R,TY U,TY O_U,TY GROUP> IN AbstractModule<R,U,O_U,GROUP>::AbstractModule(CO R& dummy,O_U o_U,GROUP M):AbstractRSet<R,U,O_U>(dummy,M.One(),MO(o_U)),GROUP(MO(M)){ST_AS(is_same_v<U,inner_t<GROUP>>);}TE <TY U,TY MAGMA> IN U RegularRSet<U,MAGMA>::Action(CO U& r,U u){RE TH->Product(r,MO(u));}TE <TY R,TY U,TY O_U> IN U AbstractRSet<R,U,O_U>::Action(CO R& r,U u){RE m_o_U(r,MO(u));}TE <TY R,TY U> IN U Module<R,U>::Action(CO R& r,U u){RE MO(u *= r);}TE <TY R,TY U> IN U VirtualRSet<R,U>::PW(U u,CO R& r){RE Action(r,MO(u));}TE <TY R,TY U> IN U VirtualRSet<R,U>::ScalarProduct(CO R& r,U u){RE Action(r,MO(u));}

TE <TY U,TY MONOID,TY SEMIGROUP>CL VirtualSemirng{PU:VI U Sum(CO U& u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(CO U& u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY U,TY MONOID,TY SEMIGROUP>CL AbstractSemirng:VI PU VirtualSemirng<U,MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(CO U& u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(CO U& u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY U>CL Semirng:PU AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY U,TY MONOID,TY SEMIGROUP> IN AbstractSemirng<U,MONOID,SEMIGROUP>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Sum(CO U& u0,CO U& u1){RE m_R0.Sum(u0,u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN CO U& AbstractSemirng<U,MONOID,SEMIGROUP>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Product(CO U& u0,CO U& u1){RE m_R1.Product(u0,u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN MONOID& AbstractSemirng<U,MONOID,SEMIGROUP>::AdditiveMonoid()NE{RE m_R0;}TE <TY U,TY MONOID,TY SEMIGROUP> IN SEMIGROUP& AbstractSemirng<U,MONOID,SEMIGROUP>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY U,TY GROUP,TY MONOID>CL VirtualRing:VI PU VirtualSemirng<U,GROUP,MONOID>{PU:VI U Inverse(CO U& u)= 0;VI CO U& One()CO NE = 0;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY U,TY GROUP,TY MONOID>CL AbstractRing:VI PU VirtualRing<U,GROUP,MONOID>,PU AbstractSemirng<U,GROUP,MONOID>{PU:IN AbstractRing(GROUP R0,MONOID R1);IN U Inverse(CO U& u);IN CO U& One()CO NE;};TE <TY U = ll>CL Ring:PU AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(CO U& one_U);};
TE <TY U,TY GROUP,TY MONOID> IN AbstractRing<U,GROUP,MONOID>::AbstractRing(GROUP R0,MONOID R1):AbstractSemirng<U,GROUP,MONOID>(MO(R0),MO(R1)){}TE <TY U> IN Ring<U>::Ring(CO U& one_U):AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(one_U)){}TE <TY U,TY GROUP,TY MONOID> IN U AbstractRing<U,GROUP,MONOID>::Inverse(CO U& u){RE TH->m_R0.Inverse(u);}TE <TY U,TY GROUP,TY MONOID> IN CO U& AbstractRing<U,GROUP,MONOID>::One()CO NE{RE TH->m_R1.One();}TE <TY U,TY GROUP,TY MONOID> IN GROUP& VirtualRing<U,GROUP,MONOID>::AdditiveGroup()NE{RE TH->AdditiveMonoid();}TE <TY U,TY GROUP,TY MONOID> IN MONOID& VirtualRing<U,GROUP,MONOID>::MultiplicativeMonoid()NE{RE TH->MultiplicativeSemigroup();}

TE <TY R,TY U>CL Algebra:VI PU VirtualRSet<R,U>,PU Ring<U>{PU:IN Algebra(U one);US Ring<U>::type;IN U Action(CO R& r,U u);IN U PW(U u,CO R& r)= 0;};
TE <TY R,TY U> IN Algebra<R,U>::Algebra(U one):Ring<U>(MO(one)){}TE <TY R,TY U> IN U Algebra<R,U>::Action(CO R& r,U u){RE MO(u *= r);}

TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>CL VirtualZetaTransform{PU:GRAPH m_G;GRAPH_INV m_G_inv;Z_ALG m_R;VE<U> m_val;IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R);IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed = false);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Add(CO T& t,CO U& u);IN VO TotalAdd(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);IN VO TotalMultiply(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);U OP[](CO T& t);IN U Get(CO T& t);IN CO U& InitialSegmentSum(CO T& t);TE <TY S,TY F_INV_MAX,TY RANGE> U InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s);TE <TY S,TY F_INV_MAX> IN CO U& InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s);VI int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG> VirtualZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG)-> VirtualZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG>;TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU>CL AbstractZetaTransform:PU VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>{PU:MU m_mu;TE <TY...Args> IN AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args);IN int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG,TY MU> AbstractZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG,MU)-> AbstractZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG,MU>;
TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(m_G.SZ(),m_R.Zero()){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);AS(m_G_inv.SZ()== m_G.SZ());}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(MO(a)){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);CRI SZ = m_G.SZ();AS(m_G_inv.SZ()== SZ && int(m_val.SZ())== SZ);if(!transformed){a = m_val;for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];auto&& sub_i = m_G.Edge(i);for(auto& j:sub_i){j == i?m_val_i:m_val_i = m_R.Sum(MO(m_val_i),a[j]);}}}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> TE <TY...Args> IN AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args):VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>(MO(G),MO(G_inv),MO(R),forward<Args>(args)...),m_mu(MO(mu)){ST_AS(is_invocable_r_v<int,MU,CO T&,CO T&>);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>TE <TY...Args> VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Initialise(Args&&... args){VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG> temp{m_G,m_G_inv,m_R,forward<Args>(args)...};m_val = MO(temp.m_val);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Add(CO T& t,CO U& u){auto&& sup = m_G_inv.Edge(t);for(auto& s:sup){U& m_val_i = m_val[m_G.Enumeration_inv(s)];m_val_i = m_R.Sum(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalAdd(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Sum(MO(m_val_i),m_R.ScalarProduct(m_G.Edge(m_G.Enumeration(i)).SZ(),u));}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = Sum(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalMultiply(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP[](CO T& t){auto&& sub = m_G.Edge(t);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s:sub){auto&& i = m_G.Enumeration_inv(s);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(s,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Get(CO T& t){RE OP[](t);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentSum(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(i < m_G.SZ());RE m_val[i];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX,TY RANGE>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s){ST_AS(is_invocable_r_v<T,F_INV_MAX,CO S&> && is_invocable_r_v<VE<T>,RANGE,CO S&>);auto&& t = f_inv_max(s);auto&& sub = range(s);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s_sub:sub){auto&& t_sub = f_inv_max(s_sub);auto&& i = m_G.Enumeration_inv(t_sub);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(t_sub,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s){RE m_val[m_G.Enumeration_inv(f_inv_max(s))];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>int VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Moevius(CO T& t0,CO T& t1){ST VE<unordered_map<int,int>> memory(m_G.SZ());auto&& i = m_G.Enumeration_inv(t0);auto&& j = m_G.Enumeration_inv(t1);unordered_map<int,int>& memory_t0 = memory[i];CO bool found = memory_t0.count(j)== 1;int& AN = memory_t0[j];if(! found){if(i == j){AN = 1;}else{AN = 0;auto&& sub = m_G.Edge(t1);for(auto& s:sub){s == t1?AN:AN -= Moevius(t0,s);}}}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> IN int AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::Moevius(CO T& t0,CO T& t1){RE m_mu(t0,t1);}
#endif
