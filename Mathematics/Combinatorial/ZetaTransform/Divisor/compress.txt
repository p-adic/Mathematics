#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/ZetaTransform/Divisor/a_Body.hpp"
#else
TE <TY U,TY MONOID,TY SEMIGROUP>CL VirtualSemirng{PU:VI U Sum(U u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(U u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY U,TY MONOID,TY SEMIGROUP>CL AbstractSemirng:VI PU VirtualSemirng<U,MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(U u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(U u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY MONOID,TY SEMIGROUP> AbstractSemirng(MONOID R0,SEMIGROUP R1)-> AbstractSemirng<inner_t<MONOID>,MONOID,SEMIGROUP>;TE <TY U>CL Semirng:PU AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY U,TY MONOID,TY SEMIGROUP> IN AbstractSemirng<U,MONOID,SEMIGROUP>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Sum(U u0,CO U& u1){RE m_R0.Sum(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN CO U& AbstractSemirng<U,MONOID,SEMIGROUP>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Product(U u0,CO U& u1){RE m_R1.Product(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN MONOID& AbstractSemirng<U,MONOID,SEMIGROUP>::AdditiveMonoid()NE{RE m_R0;}TE <TY U,TY MONOID,TY SEMIGROUP> IN SEMIGROUP& AbstractSemirng<U,MONOID,SEMIGROUP>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY U,TY GROUP,TY MONOID>CL VirtualRing:VI PU VirtualSemirng<U,GROUP,MONOID>{PU:VI U Inverse(CO U& u)= 0;VI CO U& One()CO NE = 0;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY U,TY GROUP,TY MONOID>CL AbstractRing:VI PU VirtualRing<U,GROUP,MONOID>,PU AbstractSemirng<U,GROUP,MONOID>{PU:IN AbstractRing(GROUP R0,MONOID R1);IN U Inverse(CO U& u);IN CO U& One()CO NE;};TE <TY U = ll>CL Ring:PU AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(CO U& one_U);};
TE <TY U,TY GROUP,TY MONOID> IN AbstractRing<U,GROUP,MONOID>::AbstractRing(GROUP R0,MONOID R1):AbstractSemirng<U,GROUP,MONOID>(MO(R0),MO(R1)){}TE <TY U> IN Ring<U>::Ring(CO U& one_U):AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(one_U)){}TE <TY U,TY GROUP,TY MONOID> IN U AbstractRing<U,GROUP,MONOID>::Inverse(CO U& u){RE TH->m_R0.Inverse(u);}TE <TY U,TY GROUP,TY MONOID> IN CO U& AbstractRing<U,GROUP,MONOID>::One()CO NE{RE TH->m_R1.One();}TE <TY U,TY GROUP,TY MONOID> IN GROUP& VirtualRing<U,GROUP,MONOID>::AdditiveGroup()NE{RE TH->AdditiveMonoid();}TE <TY U,TY GROUP,TY MONOID> IN MONOID& VirtualRing<U,GROUP,MONOID>::MultiplicativeMonoid()NE{RE TH->MultiplicativeSemigroup();}

TE <TY R,TY U>CL Algebra:VI PU VirtualRSet<R,U>,PU Ring<U>{PU:IN Algebra(U one);US Ring<U>::type;IN U Action(CO R& r,U u);IN U PW(U u,CO R& r)= delete;};
TE <TY R,TY U> IN Algebra<R,U>::Algebra(U one):Ring<U>(MO(one)){}TE <TY R,TY U> IN U Algebra<R,U>::Action(CO R& r,U u){RE MO(u *= r);}

TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>CL VirtualZetaTransform{PU:GRAPH m_G;GRAPH_INV m_G_inv;Z_ALG m_R;VE<U> m_val;IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R);IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed = false);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Add(CO T& t,CO U& u);IN VO TotalAdd(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);IN VO TotalMultiply(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);U OP[](CO T& t);IN U Get(CO T& t);IN CO U& InitialSegmentSum(CO T& t);TE <TY S,TY F_INV_MAX,TY RANGE> U InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s);TE <TY S,TY F_INV_MAX> IN CO U& InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s);VI int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG> VirtualZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG)-> VirtualZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG>;TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU>CL AbstractZetaTransform:PU VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>{PU:MU m_mu;TE <TY...Args> IN AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args);IN int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG,TY MU> AbstractZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG,MU)-> AbstractZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG,MU>;
TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(m_G.SZ(),m_R.Zero()){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);AS(m_G_inv.SZ()== m_G.SZ());}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(MO(a)){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);CRI SZ = m_G.SZ();AS(m_G_inv.SZ()== SZ && int(m_val.SZ())== SZ);if(!transformed){a = m_val;for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];auto&& sub_i = m_G.Edge(i);for(auto& j:sub_i){j == i?m_val_i:m_val_i = m_R.Sum(MO(m_val_i),a[j]);}}}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> TE <TY...Args> IN AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args):VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>(MO(G),MO(G_inv),MO(R),forward<Args>(args)...),m_mu(MO(mu)){ST_AS(is_invocable_r_v<int,MU,CO T&,CO T&>);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>TE <TY...Args> VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Initialise(Args&&... args){VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG> temp{m_G,m_G_inv,m_R,forward<Args>(args)...};m_val = MO(temp.m_val);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Add(CO T& t,CO U& u){auto&& sup = m_G_inv.Edge(t);for(auto& s:sup){U& m_val_i = m_val[m_G.Enumeration_inv(s)];m_val_i = m_R.Sum(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalAdd(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Sum(MO(m_val_i),m_R.ScalarProduct(m_G.Edge(m_G.Enumeration(i)).SZ(),u));}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = Sum(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalMultiply(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP[](CO T& t){auto&& sub = m_G.Edge(t);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s:sub){auto&& i = m_G.Enumeration_inv(s);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(s,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Get(CO T& t){RE OP[](t);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentSum(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(i < m_G.SZ());RE m_val[i];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX,TY RANGE>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s){ST_AS(is_invocable_r_v<T,F_INV_MAX,CO S&> && is_invocable_r_v<VE<T>,RANGE,CO S&>);auto&& t = f_inv_max(s);auto&& sub = range(s);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s_sub:sub){auto&& t_sub = f_inv_max(s_sub);auto&& i = m_G.Enumeration_inv(t_sub);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(t_sub,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s){RE m_val[m_G.Enumeration_inv(f_inv_max(s))];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>int VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Moevius(CO T& t0,CO T& t1){ST VE<unordered_map<int,int>> memory(m_G.SZ());auto&& i = m_G.Enumeration_inv(t0);auto&& j = m_G.Enumeration_inv(t1);unordered_map<int,int>& memory_t0 = memory[i];CO bool found = memory_t0.count(j)== 1;int& AN = memory_t0[j];if(! found){if(i == j){AN = 1;}else{AN = 0;auto&& sub = m_G.Edge(t1);for(auto& s:sub){s == t1?AN:AN -= Moevius(t0,s);}}}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> IN int AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::Moevius(CO T& t0,CO T& t1){RE m_mu(t0,t1);}

TE <TY INT,INT val_limit>CL LeastDivisor{PU:INT m_val[val_limit];CE LeastDivisor()NE;IN CO INT& OP[](CRI i)CO;CE CO INT& Get(CRI i)CO;};
TE <TY INT,INT val_limit> CE LeastDivisor<INT,val_limit>::LeastDivisor()NE:m_val{}{for(int d = 2;d < val_limit;d++){if(m_val[d]== 0){for(int n = d;n < val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}TE <TY INT,INT val_limit> IN CO INT& LeastDivisor<INT,val_limit>::OP[](CRI i)CO{AS(0 <= i && i < val_limit);RE m_val[i];}TE <TY INT,INT val_limit> CE CO INT& LeastDivisor<INT,val_limit>::Get(CRI i)CO{RE m_val[i];}

TE <TY INT> INT CountDivisorBody(VE<INT>& EX)NE{CO int LE = EX.SZ();INT AN = 1;for(int i = 0;i < LE;i++){AN *= ++EX[i];}RE AN;}TE <TY INT> VE<INT> EnumerateDivisorBody(CO VE<INT>& P,VE<INT>& EX){CO int LE = P.SZ();VE<INT> AN(CountDivisorBody(EX),1);int SZ = 1;for(int i = 0;i < LE;i++){CO INT& P_i = P[i];CRI EX_i = EX[i];INT PW = 1;int j_shift = 0;for(int e = 1;e < EX_i;e++){PW *= P_i;j_shift += SZ;for(int j = 0;j < SZ;j++){AN[j + j_shift]= AN[j]* PW;}}SZ *= EX_i;}RE AN;}TE <TY INT1,INT1 val_limit,TY INT2>VE<INT2> EnumerateDivisor(CO LeastDivisor<INT1,val_limit>& ld,INT2 n){VE<INT2> P{},EX{};WH(n > 1){auto& p = ld[n];P.push_back(p);INT2 e = 1;WH((n /= p)% p == 0){e++;}EX.push_back(e);}RE EnumerateDivisorBody(P,EX);}

TE <TY INT,INT val_limit>CL MoeviusFunction{PU:INT m_val[val_limit];CE MoeviusFunction(CO LeastDivisor<INT,val_limit>& ld)NE;IN CO INT& OP()(CRI n)CO;};
TE <TY INT,INT val_limit> CE MoeviusFunction<INT,val_limit>::MoeviusFunction(CO LeastDivisor<INT,val_limit>& ld)NE:m_val{0,1}{for(int i = 2;i < val_limit;i++){auto& p = ld[i];CO int j = i / p;m_val[i]= j % p == 0?0:-m_val[j];}}TE <TY INT,INT val_limit> IN CO INT& MoeviusFunction<INT,val_limit>::OP()(CRI n)CO{AS(0 <= n && n < val_limit);RE m_val[n];}

TE <TY MU>CL DivisorMoeviusFunction{PU:CO MU* m_p_mu;CE DivisorMoeviusFunction(CO MU& mu);IN int OP()(CRI t0,CRI t1);};TE <TY MU>CL MultipleMoeviusFunction{PU:CO MU* m_p_mu;CE MultipleMoeviusFunction(CO MU& mu);IN int OP()(CRI t0,CRI t1);};TE <TY LD>CL DivisorEdge{PU:CO LD* m_p_ld;IN DivisorEdge(CO LD& ld);IN VE<int> OP()(CRI t);};CL MultipleEdge{PU:int m_SZ;IN MultipleEdge(CRI SZ);IN VE<int> OP()(CRI t);};TE <TY LD,TY MU,TY U,TY Z_ALG>CL AbstractDivisorZetaTransform:PU AbstractZetaTransform<int,Graph<DivisorEdge<LD>>,Graph<MultipleEdge>,U,Z_ALG,DivisorMoeviusFunction<MU>>{PU:MU m_mu;IN AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ = 0);IN AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed = false);IN AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed);};TE <int val_limit,TY Z_ALG,TY...Args> AbstractDivisorZetaTransform(CO LeastDivisor<int,val_limit>&,Z_ALG,Args&&...)-> AbstractDivisorZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,inner_t<Z_ALG>,Z_ALG>;TE <int val_limit,TY U>CL DivisorZetaTransform:PU AbstractDivisorZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,U,Algebra<int,U>>{PU:TE <TY...Args> IN DivisorZetaTransform(CO LeastDivisor<int,val_limit>& ld,CO U& one,Args&&... args);};TE <TY LD,TY MU,TY U,TY Z_ALG>CL AbstractMultipleZetaTransform:PU AbstractZetaTransform<int,Graph<MultipleEdge>,Graph<DivisorEdge<LD>>,U,Z_ALG,MultipleMoeviusFunction<MU>>{PU:MU m_mu;IN AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ = 0);IN AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed = false);IN AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed);};TE <int val_limit,TY Z_ALG,TY...Args> AbstractMultipleZetaTransform(CO LeastDivisor<int,val_limit>&,Z_ALG,Args&&...)-> AbstractMultipleZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,inner_t<Z_ALG>,Z_ALG>;TE <int val_limit,TY U>CL MultipleZetaTransform:PU AbstractMultipleZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,U,Algebra<int,U>>{PU:TE <TY...Args> IN MultipleZetaTransform(CO LeastDivisor<int,val_limit>& ld,CO U& one,Args&&... args);};
TE <TY MU> CE DivisorMoeviusFunction<MU>::DivisorMoeviusFunction(CO MU& mu):m_p_mu(&mu){}TE <TY MU> CE MultipleMoeviusFunction<MU>::MultipleMoeviusFunction(CO MU& mu):m_p_mu(&mu){}TE <TY MU> IN int DivisorMoeviusFunction<MU>::OP()(CRI t0,CRI t1){RE(*m_p_mu)(t1 / t0);}TE <TY MU> IN int MultipleMoeviusFunction<MU>::OP()(CRI t0,CRI t1){RE(*m_p_mu)(t0 / t1);}TE <TY LD> IN DivisorEdge<LD>::DivisorEdge(CO LD& ld):m_p_ld(&ld){}IN MultipleEdge::MultipleEdge(CRI SZ):m_SZ(SZ){}TE <TY LD> IN VE<int> DivisorEdge<LD>::OP()(CRI t){AS(0 <= t);VE<int> AN{};RE t == 0?VE<int>(1):EnumerateDivisor(*m_p_ld,t);}IN VE<int> MultipleEdge::OP()(CRI t){AS(0 <= t && t < m_SZ);CO int SZ = t == 0?0:(m_SZ - 1)/ t;VE<int> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]= t *(i + 1);}RE AN;}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractDivisorZetaTransform<LD,MU,U,Z_ALG>::AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ):AbstractZetaTransform<int,Graph<DivisorEdge<LD>>,Graph<MultipleEdge>,U,Z_ALG,DivisorMoeviusFunction<MU>>(Graph(SZ,DivisorEdge(ld)),Graph(SZ,MultipleEdge(SZ)),MO(R),DivisorMoeviusFunction(m_mu)),m_mu(ld){}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractDivisorZetaTransform<LD,MU,U,Z_ALG>::AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed):AbstractDivisorZetaTransform(ld,MO(R),a.SZ(),a,transformed){}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractDivisorZetaTransform<LD,MU,U,Z_ALG>::AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed):AbstractZetaTransform<int,Graph<DivisorEdge<LD>>,Graph<MultipleEdge>,U,Z_ALG,DivisorMoeviusFunction<MU>>(Graph(SZ,DivisorEdge(ld)),Graph(SZ,MultipleEdge(SZ)),MO(R),DivisorMoeviusFunction(m_mu),MO(a),transformed),m_mu(ld){}TE <int val_limit,TY U> TE <TY...Args> IN DivisorZetaTransform<val_limit,U>::DivisorZetaTransform(CO LeastDivisor<int,val_limit>& ld,CO U& one,Args&&... args):AbstractDivisorZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,U,Algebra<int,U>>(ld,Algebra<int,U>(one),forward<Args>(args)...){}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractMultipleZetaTransform<LD,MU,U,Z_ALG>::AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ):AbstractZetaTransform<int,Graph<MultipleEdge>,Graph<DivisorEdge<LD>>,U,Z_ALG,MultipleMoeviusFunction<MU>>(Graph(SZ,MultipleEdge(SZ)),Graph(SZ,DivisorEdge(ld)),MO(R),MultipleMoeviusFunction(m_mu)),m_mu(ld){}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractMultipleZetaTransform<LD,MU,U,Z_ALG>::AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed):AbstractMultipleZetaTransform(ld,MO(R),a.SZ(),a,transformed){}TE <TY LD,TY MU,TY U,TY Z_ALG> IN AbstractMultipleZetaTransform<LD,MU,U,Z_ALG>::AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed):AbstractZetaTransform<int,Graph<MultipleEdge>,Graph<DivisorEdge<LD>>,U,Z_ALG,MultipleMoeviusFunction<MU>>(Graph(SZ,MultipleEdge(ld)),Graph(SZ,DivisorEdge(ld)),MO(R),MultipleMoeviusFunction(m_mu),MO(a),transformed),m_mu(ld){}TE <int val_limit,TY U> TE <TY...Args> IN MultipleZetaTransform<val_limit,U>::MultipleZetaTransform(CO LeastDivisor<int,val_limit>& ld,CO U& one,Args&&... args):AbstractMultipleZetaTransform<LeastDivisor<int,val_limit>,MoeviusFunction<int,val_limit>,U,Algebra<int,U>>(ld,Algebra<int,U>(one),forward<Args>(args)...){}
#endif

