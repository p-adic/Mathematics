#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/ZetaTransform/Divisor/a_Body.hpp"
#else
TE <TY PE> auto CheckPE(CO PE& pe)-> decltype(pe.IsComposite(0),true_type());TE <TY...> false_type CheckPE(...);TE <TY T>CE bool IsPE = decltype(CheckPE(declval<T>()))();

TE <int val_limit>CL LeastDivisor{PU:int m_val[val_limit];CE LeastDivisor()NE;IN CRI OP[](CRI i)CO;CE CRI Get(CRI i)CO;};
TE <int val_limit> CE LeastDivisor<val_limit>::LeastDivisor()NE:m_val{}{for(int d = 2;d < val_limit;d++){if(m_val[d]== 0){for(int n = d;n < val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}TE <int val_limit> IN CRI LeastDivisor<val_limit>::OP[](CRI i)CO{AS(0 <= i && i < val_limit);RE m_val[i];}TE <int val_limit> CE CRI LeastDivisor<val_limit>::Get(CRI i)CO{RE m_val[i];}
CL HeapLeastDivisor{PU:int m_val_limit;VE<int> m_val;IN HeapLeastDivisor(CRI val_limit)NE;IN CRI OP[](CRI i)CO;IN CRI Get(CRI i)CO;};
IN HeapLeastDivisor::HeapLeastDivisor(CRI val_limit)NE:m_val_limit(val_limit),m_val(m_val_limit){for(int d = 2;d < m_val_limit;d++){if(m_val[d]== 0){for(int n = d;n < m_val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}IN CRI HeapLeastDivisor::OP[](CRI i)CO{AS(0 <= i && i < m_val_limit);RE m_val[i];}IN CRI HeapLeastDivisor::Get(CRI i)CO{RE m_val[i];}

TE <TY LD,TY INT>auto PrimeFactorisation(CO LD& ld,INT n)-> enable_if_t<!IsPE<LD>,pair<VE<int>,VE<int>>>{VE<int> P{};VE<int> E{};if(n > 1){P.push_back(ld[n]);E.push_back(1);n /= ld[n];}WH(n > 1){if(P.back()!= ld[n]){P.push_back(ld[n]);E.push_back(1);}else{E.back()++;}n /= ld[n];}RE{MO(P),MO(E)};}

TE <TY INT> INT CountDivisorBody(VE<int>& E)NE{CO int LE = E.SZ();INT AN = 1;for(int i = 0;i < LE;i++){AN *= ++E[i];}RE AN;}TE <TY PE,TY INT>INT CountDivisor(CO PE& pe,INT n)NE{auto[P,E]= PrimeFactorisation(pe,MO(n));RE CountDivisorBody<INT>(E);}

TE <TY INT> VE<INT> EnumerateDivisorBody(CO VE<INT>& P,VE<int>& E){CO int le = P.SZ();VE AN(CountDivisorBody<INT>(E),INT(1));int SZ = 1;for(int i = 0;i < le;i++){auto& P_i = P[i];auto& E_i = E[i];INT q = 1;int j_shift = 0;for(int e = 1;e < E_i;e++){q *= P_i;j_shift += SZ;for(int j = 0;j < SZ;j++){AN[j + j_shift]= AN[j]* q;}}SZ *= E_i;}RE AN;}TE <TY LD,TY INT>auto EnumerateDivisor(CO LD& ld,INT n)-> enable_if_t<!IsPE<LD>,VE<INT>>{VE<INT> P{};VE<int> E{};WH(n > 1){auto& p = ld[n];int e = 1;WH((n /= p)% p == 0){e++;}P.push_back(p);E.push_back(e);}RE EnumerateDivisorBody(P,E);}

TE <TY LD,TY INT>VE<INT> TotalMoeviusFunction(CO LD& ld,CO INT& n_max){VE<INT> AN(n_max + 1,1);AN[0]= 0;for(int i = 2;i <= n_max;i++){auto& p = ld[i];CO int j = i / p;AN[i]= j % p == 0?0:-AN[j];}RE AN;}

TE <TY U,TY MONOID,TY SEMIGROUP>CL VirtualSemirng{PU:VI U Sum(U u0,CO U& u1)= 0;VI CO U& Zero()CO NE = 0;VI U Product(U u0,CO U& u1)= 0;VI MONOID& AdditiveMonoid()NE = 0;VI SEMIGROUP& MultiplicativeSemigroup()NE = 0;US type = U;};TE <TY U,TY MONOID,TY SEMIGROUP>CL AbstractSemirng:VI PU VirtualSemirng<U,MONOID,SEMIGROUP>{PU:MONOID m_R0;SEMIGROUP m_R1;IN AbstractSemirng(MONOID R0,SEMIGROUP R1);IN U Sum(U u0,CO U& u1);IN CO U& Zero()CO NE;IN U Product(U u0,CO U& u1);IN MONOID& AdditiveMonoid()NE;IN SEMIGROUP& MultiplicativeSemigroup()NE;};TE <TY MONOID,TY SEMIGROUP> AbstractSemirng(MONOID R0,SEMIGROUP R1)-> AbstractSemirng<inner_t<MONOID>,MONOID,SEMIGROUP>;TE <TY U>CL Semirng:PU AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>{PU:IN Semirng();};
TE <TY U,TY MONOID,TY SEMIGROUP> IN AbstractSemirng<U,MONOID,SEMIGROUP>::AbstractSemirng(MONOID R0,SEMIGROUP R1):m_R0(MO(R0)),m_R1(MO(R1)){}TE <TY U> IN Semirng<U>::Semirng():AbstractSemirng<U,AdditiveMonoid<U>,MultiplicativeMagma<U>>(AdditiveMonoid<U>(),MultiplicativeMagma()){}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Sum(U u0,CO U& u1){RE m_R0.Sum(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN CO U& AbstractSemirng<U,MONOID,SEMIGROUP>::Zero()CO NE{RE m_R0.Zero();}TE <TY U,TY MONOID,TY SEMIGROUP> IN U AbstractSemirng<U,MONOID,SEMIGROUP>::Product(U u0,CO U& u1){RE m_R1.Product(MO(u0),u1);}TE <TY U,TY MONOID,TY SEMIGROUP> IN MONOID& AbstractSemirng<U,MONOID,SEMIGROUP>::AdditiveMonoid()NE{RE m_R0;}TE <TY U,TY MONOID,TY SEMIGROUP> IN SEMIGROUP& AbstractSemirng<U,MONOID,SEMIGROUP>::MultiplicativeSemigroup()NE{RE m_R1;}

TE <TY U,TY GROUP,TY MONOID>CL VirtualRing:VI PU VirtualSemirng<U,GROUP,MONOID>{PU:VI U Inverse(CO U& u)= 0;VI CO U& One()CO NE = 0;IN GROUP& AdditiveGroup()NE;IN MONOID& MultiplicativeMonoid()NE;};TE <TY U,TY GROUP,TY MONOID>CL AbstractRing:VI PU VirtualRing<U,GROUP,MONOID>,PU AbstractSemirng<U,GROUP,MONOID>{PU:IN AbstractRing(GROUP R0,MONOID R1);IN U Inverse(CO U& u);IN CO U& One()CO NE;};TE <TY U = ll>CL Ring:PU AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>{PU:IN Ring(CO U& one_U);};
TE <TY U,TY GROUP,TY MONOID> IN AbstractRing<U,GROUP,MONOID>::AbstractRing(GROUP R0,MONOID R1):AbstractSemirng<U,GROUP,MONOID>(MO(R0),MO(R1)){}TE <TY U> IN Ring<U>::Ring(CO U& one_U):AbstractRing<U,AdditiveGroup<U>,MultiplicativeMonoid<U>>(AdditiveGroup<U>(),MultiplicativeMonoid<U>(one_U)){}TE <TY U,TY GROUP,TY MONOID> IN U AbstractRing<U,GROUP,MONOID>::Inverse(CO U& u){RE TH->m_R0.Inverse(u);}TE <TY U,TY GROUP,TY MONOID> IN CO U& AbstractRing<U,GROUP,MONOID>::One()CO NE{RE TH->m_R1.One();}TE <TY U,TY GROUP,TY MONOID> IN GROUP& VirtualRing<U,GROUP,MONOID>::AdditiveGroup()NE{RE TH->AdditiveMonoid();}TE <TY U,TY GROUP,TY MONOID> IN MONOID& VirtualRing<U,GROUP,MONOID>::MultiplicativeMonoid()NE{RE TH->MultiplicativeSemigroup();}

TE <TY R,TY U>CL Algebra:VI PU VirtualRSet<R,U>,PU Ring<U>{PU:IN Algebra(U one);US Ring<U>::type;IN U Action(CO R& r,U u);IN U PW(U u,CO R& r)= delete;};
TE <TY R,TY U> IN Algebra<R,U>::Algebra(U one):Ring<U>(MO(one)){}TE <TY R,TY U> IN U Algebra<R,U>::Action(CO R& r,U u){RE MO(u *= r);}

TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>CL VirtualZetaTransform{PU:GRAPH m_G;GRAPH_INV m_G_inv;Z_ALG m_R;VE<U> m_val;IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R);IN VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed = false);TE <TY...Args> IN VO Initialise(Args&&... args);IN VO Add(CO T& t,CO U& u);IN VO TotalAdd(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);IN VO TotalMultiply(CO U& u);IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a);U OP[](CO T& t);IN U Get(CO T& t);IN CO U& InitialSegmentSum(CO T& t);TE <TY S,TY F_INV_MAX,TY RANGE> U InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s);TE <TY S,TY F_INV_MAX> IN CO U& InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s);VI int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG> VirtualZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG)-> VirtualZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG>;TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU>CL AbstractZetaTransform:PU VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>{PU:MU m_mu;TE <TY...Args> IN AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args);IN int Moevius(CO T& t0,CO T& t1);};TE <TY GRAPH,TY GRAPH_INV,TY Z_ALG,TY MU> AbstractZetaTransform(GRAPH&,GRAPH_INV&,Z_ALG,MU)-> AbstractZetaTransform<inner_t<GRAPH>,GRAPH,GRAPH_INV,inner_t<Z_ALG>,Z_ALG,MU>;
TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(m_G.SZ(),m_R.Zero()){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);AS(m_G_inv.SZ()== m_G.SZ());}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::VirtualZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,VE<U> a,CO bool& transformed):m_G(MO(G)),m_G_inv(MO(G_inv)),m_R(MO(R)),m_val(MO(a)){ST_AS(is_same_v<T,inner_t<GRAPH>> && is_same_v<T,inner_t<GRAPH_INV>> && is_same_v<U,inner_t<Z_ALG>>);CRI SZ = m_G.SZ();AS(m_G_inv.SZ()== SZ && int(m_val.SZ())== SZ);if(!transformed){a = m_val;for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];auto&& sub_i = m_G.Edge(i);for(auto& j:sub_i){j == i?m_val_i:m_val_i = m_R.Sum(MO(m_val_i),a[j]);}}}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> TE <TY...Args> IN AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::AbstractZetaTransform(GRAPH G,GRAPH_INV G_inv,Z_ALG R,MU mu,Args&&... args):VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>(MO(G),MO(G_inv),MO(R),forward<Args>(args)...),m_mu(MO(mu)){ST_AS(is_invocable_r_v<int,MU,CO T&,CO T&>);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>TE <TY...Args> VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Initialise(Args&&... args){VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG> temp{m_G,m_G_inv,m_R,forward<Args>(args)...};m_val = MO(temp.m_val);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Add(CO T& t,CO U& u){auto&& sup = m_G_inv.Edge(t);for(auto& s:sup){U& m_val_i = m_val[m_G.Enumeration_inv(s)];m_val_i = m_R.Sum(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalAdd(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Sum(MO(m_val_i),m_R.ScalarProduct(m_G.Edge(m_G.Enumeration(i)).SZ(),u));}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP+=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = Sum(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::TotalMultiply(CO U& u){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),u);}}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP*=(CO VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>& a){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){U& m_val_i = m_val[i];m_val_i = m_R.Product(MO(m_val_i),a.m_val[i]);}RE *TH;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::OP[](CO T& t){auto&& sub = m_G.Edge(t);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s:sub){auto&& i = m_G.Enumeration_inv(s);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(s,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Get(CO T& t){RE OP[](t);}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentSum(CO T& t){auto&& i = m_G.Enumeration_inv(t);AS(i < m_G.SZ());RE m_val[i];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX,TY RANGE>U VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InverseImageSum(F_INV_MAX&& f_inv_max,RANGE&& range,CO S& s){ST_AS(is_invocable_r_v<T,F_INV_MAX,CO S&> && is_invocable_r_v<VE<T>,RANGE,CO S&>);auto&& t = f_inv_max(s);auto&& sub = range(s);U AN = m_R.Zero();CRI SZ = m_G.SZ();for(auto& s_sub:sub){auto&& t_sub = f_inv_max(s_sub);auto&& i = m_G.Enumeration_inv(t_sub);AS(i < SZ);AN = m_R.Sum(MO(AN),m_R.ScalarProduct(Moevius(t_sub,t),m_val[i]));}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG> TE <TY S,TY F_INV_MAX> IN CO U& VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::InitialSegmentInverseImageSum(F_INV_MAX&& f_inv_max,CO S& s){RE m_val[m_G.Enumeration_inv(f_inv_max(s))];}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG>int VirtualZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG>::Moevius(CO T& t0,CO T& t1){ST VE<unordered_map<int,int>> memory(m_G.SZ());auto&& i = m_G.Enumeration_inv(t0);auto&& j = m_G.Enumeration_inv(t1);unordered_map<int,int>& memory_t0 = memory[i];CO bool found = memory_t0.count(j)== 1;int& AN = memory_t0[j];if(! found){if(i == j){AN = 1;}else{AN = 0;auto&& sub = m_G.Edge(t1);for(auto& s:sub){s == t1?AN:AN -= Moevius(t0,s);}}}RE AN;}TE <TY T,TY GRAPH,TY GRAPH_INV,TY U,TY Z_ALG,TY MU> IN int AbstractZetaTransform<T,GRAPH,GRAPH_INV,U,Z_ALG,MU>::Moevius(CO T& t0,CO T& t1){RE m_mu(t0,t1);}

TE <TY LD>CL DivisorMoeviusFunction{PU:VE<int> m_val;IN DivisorMoeviusFunction(CO LD& ld,CRI n_max);IN int OP()(CRI t0,CRI t1);};TE <TY LD>CL MultipleMoeviusFunction{PU:VE<int> m_val;IN MultipleMoeviusFunction(CO LD& ld,CRI n_max);IN int OP()(CRI t0,CRI t1);};TE <TY LD>CL DivisorEdge{PU:CO LD* m_p_ld;IN DivisorEdge(CO LD& ld);IN VE<int> OP()(CRI t);};CL MultipleEdge{PU:int m_SZ;IN MultipleEdge(CRI SZ);IN VE<int> OP()(CRI t);};TE <TY LD,TY U,TY Z_ALG>CL AbstractDivisorZetaTransform:PU AbstractZetaTransform<int,Graph<DivisorEdge<LD>>,Graph<MultipleEdge>,U,Z_ALG,DivisorMoeviusFunction<LD>>{PU:IN AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed = false);IN AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed);};TE <TY LD,TY Z_ALG,TY...Args> AbstractDivisorZetaTransform(CO LD&,Z_ALG,Args&&...)-> AbstractDivisorZetaTransform<LD,inner_t<Z_ALG>,Z_ALG>;TE <TY LD,TY U>CL DivisorZetaTransform:PU AbstractDivisorZetaTransform<LD,U,Algebra<int,U>>{PU:IN DivisorZetaTransform(CO LD& ld,CO U& one,CRI SZ);IN DivisorZetaTransform(CO LD& ld,CO U& one,VE<U> a,CO bool& transformed = false);};TE <TY LD,TY U,TY Z_ALG>CL AbstractMultipleZetaTransform:PU AbstractZetaTransform<int,Graph<MultipleEdge>,Graph<DivisorEdge<LD>>,U,Z_ALG,MultipleMoeviusFunction<LD>>{PU:IN AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed = false);IN AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed);};TE <TY LD,TY Z_ALG,TY...Args> AbstractMultipleZetaTransform(CO LD&,Z_ALG,Args&&...)-> AbstractMultipleZetaTransform<LD,inner_t<Z_ALG>,Z_ALG>;TE <TY LD,TY U>CL MultipleZetaTransform:PU AbstractMultipleZetaTransform<LD,U,Algebra<int,U>>{PU:IN MultipleZetaTransform(CO LD& ld,CO U& one,CRI SZ);IN MultipleZetaTransform(CO LD& ld,CO U& one,VE<U> a,CO bool& transformed = false);};
TE <TY LD> DivisorMoeviusFunction<LD>::DivisorMoeviusFunction(CO LD& ld,CRI n_max):m_val(TotalMoeviusFunction(ld,n_max)){}TE <TY LD> MultipleMoeviusFunction<LD>::MultipleMoeviusFunction(CO LD& ld,CRI n_max):m_val(TotalMoeviusFunction(ld,n_max)){}TE <TY LD> IN int DivisorMoeviusFunction<LD>::OP()(CRI t0,CRI t1){RE m_val[t1 / t0];}TE <TY LD> IN int MultipleMoeviusFunction<LD>::OP()(CRI t0,CRI t1){RE m_val[t0 / t1];}TE <TY LD> IN DivisorEdge<LD>::DivisorEdge(CO LD& ld):m_p_ld(&ld){}IN MultipleEdge::MultipleEdge(CRI SZ):m_SZ(SZ){}TE <TY LD> IN VE<int> DivisorEdge<LD>::OP()(CRI t){AS(0 <= t);VE<int> AN{};RE t == 0?VE<int>(1):EnumerateDivisor(*m_p_ld,t);}IN VE<int> MultipleEdge::OP()(CRI t){AS(0 <= t && t < m_SZ);CO int SZ = t == 0?0:(m_SZ - 1)/ t;VE<int> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]= t *(i + 1);}RE AN;}TE <TY LD,TY U,TY Z_ALG> IN AbstractDivisorZetaTransform<LD,U,Z_ALG>::AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed):AbstractDivisorZetaTransform(ld,MO(R),a.SZ(),a,transformed){}TE <TY LD,TY U,TY Z_ALG> IN AbstractDivisorZetaTransform<LD,U,Z_ALG>::AbstractDivisorZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed):AbstractZetaTransform<int,Graph<DivisorEdge<LD>>,Graph<MultipleEdge>,U,Z_ALG,DivisorMoeviusFunction<LD>>(Graph(SZ,DivisorEdge(ld)),Graph(SZ,MultipleEdge(SZ)),MO(R),DivisorMoeviusFunction(ld,SZ - 1),MO(a),transformed){}TE <TY LD,TY U> IN DivisorZetaTransform<LD,U>::DivisorZetaTransform(CO LD& ld,CO U& one,CRI SZ):AbstractDivisorZetaTransform<LD,U,Algebra<int,U>>(ld,Algebra<int,U>(one),VE<U>(SZ),true){}TE <TY LD,TY U> IN DivisorZetaTransform<LD,U>::DivisorZetaTransform(CO LD& ld,CO U& one,VE<U> a,CO bool& transformed):AbstractDivisorZetaTransform<LD,U,Algebra<int,U>>(ld,Algebra<int,U>(one),MO(a),transformed){}TE <TY LD,TY U,TY Z_ALG> IN AbstractMultipleZetaTransform<LD,U,Z_ALG>::AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,VE<U> a,CO bool& transformed):AbstractMultipleZetaTransform(ld,MO(R),a.SZ(),a,transformed){}TE <TY LD,TY U,TY Z_ALG> IN AbstractMultipleZetaTransform<LD,U,Z_ALG>::AbstractMultipleZetaTransform(CO LD& ld,Z_ALG R,CRI SZ,VE<U>& a,CO bool& transformed):AbstractZetaTransform<int,Graph<MultipleEdge>,Graph<DivisorEdge<LD>>,U,Z_ALG,MultipleMoeviusFunction<LD>>(Graph(SZ,MultipleEdge(SZ)),Graph(SZ,DivisorEdge(ld)),MO(R),MultipleMoeviusFunction(ld,SZ - 1),MO(a),transformed){}TE <TY LD,TY U> IN MultipleZetaTransform<LD,U>::MultipleZetaTransform(CO LD& ld,CO U& one,CRI SZ):AbstractMultipleZetaTransform<LD,U,Algebra<int,U>>(ld,Algebra<int,U>(one),VE<U>(SZ),true){}TE <TY LD,TY U> IN MultipleZetaTransform<LD,U>::MultipleZetaTransform(CO LD& ld,CO U& one,VE<U> a,CO bool& transformed):AbstractMultipleZetaTransform<LD,U,Algebra<int,U>>(ld,Algebra<int,U>(one),MO(a),transformed){}
#endif

