TE <ll M>CL Mod{PR:ll m_n;ll m_inv;PU:IN Mod();IN Mod(CO ll& n);IN Mod(CO Mod<M>& n);IN Mod<M>& OP=(CO ll& n);IN Mod<M>& OP=(CO Mod<M>& n);IN Mod<M>& OP+=(CO ll& n);IN Mod<M>& OP+=(CO Mod<M>& n);IN Mod<M>& OP-=(CO ll& n);IN Mod<M>& OP-=(CO Mod<M>& n);IN Mod<M>& OP*=(CO ll& n);IN Mod<M>& OP*=(CO Mod<M>& n);IN Mod<M>& OP/=(CO ll& n);IN Mod<M>& OP/=(CO Mod<M>& n);IN Mod<M>& OP%=(CO ll& n);IN Mod<M>& OP%=(CO Mod<M>& n);IN Mod<M> OP-() CO;IN Mod<M>& OP++();IN Mod<M>& OP++(int);IN Mod<M>& OP--();IN Mod<M>& OP--(int);IN CO ll& Represent() CO;void Invert();bool CheckInvertible();bool IsSmallerThan(CO ll& n) CO;bool IsBiggerThan(CO ll& n) CO;IN void swap(Mod<M>& n);};TE <ll M> IN bool OP==(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP==(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP==(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP==(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP!=(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP!=(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP!=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP!=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP<(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP<(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP<(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP<=(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP<=(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP<=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP<=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP>(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>=(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN bool OP>=(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN bool OP>=(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP+(CO Mod<M>& n0,CO ll& n1);TE <ll M> Mod<M> OP+(CO ll& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP+(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN Mod<M> OP-(CO Mod<M>& n0,CO ll& n1);TE <ll M> Mod<M> OP-(CO ll& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP-(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP*(CO Mod<M>& n0,CO ll& n1);TE <ll M> Mod<M> OP*(CO ll& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP*(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP/(CO Mod<M>& n0,CO ll& n1);TE <ll M> Mod<M> OP/(CO ll& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP/(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> Mod<M> OP%(CO Mod<M>& n0,CO ll& n1);TE <ll M> IN Mod<M> OP%(CO ll& n0,CO Mod<M>& n1);TE <ll M> IN Mod<M> OP%(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> Mod<M> Inverse(CO Mod<M>& n);TE <ll M> Mod<M> Power(CO Mod<M>& n,CO ll& p,CO string& method = "normal");TE <> IN Mod<2> Power(CO Mod<2>& n,CO ll& p,CO string& method);TE <ll M> IN Mod<M> Power(CO Mod<M>& n,CO Mod<M>& p,CO string& method = "normal");TE <> IN Mod<2> Power(CO Mod<2>& n,CO Mod<2>& p,CO string& method);TE <TY T> IN T Square(CO T& t);TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t);TE <ll M> IN void swap(Mod<M>& n0,Mod<M>& n1);TE <ll M> IN string to_string(CO Mod<M>& n);TE<ll M,class Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n);
TE <TY INT> IN INT Residue(CO INT& n,CO INT& M) {RE n >= 0 ? n % M : M - (- n - 1) % M - 1;}void LazyEvaluationOfModularInverse(CO ll& M,CO ll& n,ll& m){CE CO ll border = 1000000;if(n > border){CO ll n_minus = M - n;if(n_minus <= border){LazyEvaluationOfModularInverse(M,n_minus,m);m = M - m;RE;} else {m = 1;ll exponent = M - 2;ll power_n = n;WH(exponent != 0){if(exponent % 2 == 1){(m *= power_n) %= M;}(power_n *= power_n) %= M;exponent /= 2;}RE;}}ST LI<ll> memory_M{};ST LI<VE<ll> > memory_inverse{};auto I_M = memory_M.begin(),end_M = memory_M.end();auto I_inverse = memory_inverse.begin();VE<ll>* p_inverse = nullptr;WH(I_M != end_M && p_inverse == nullptr){if(*I_M == M){p_inverse = &(*I_inverse);}I_M++;I_inverse++;}if(p_inverse == nullptr){memory_M.push_front(M);memory_inverse.push_front(VE<ll>());p_inverse = &(memory_inverse.front());p_inverse->push_back(M);}CO ll SZ = p_inverse->SZ();for(ll i = SZ;i <= n;i++){p_inverse->push_back(0);}ll& n_inv = (*p_inverse)[n];if(n_inv != 0){m = n_inv;RE;}CO ll M_abs = M >= 0 ? M : -M;CO ll n_sub = M_abs % n;ll n_sub_inv = (*p_inverse)[n_sub];if(n_sub_inv == 0){LazyEvaluationOfModularInverse(M,n_sub,n_sub_inv);}if(n_sub_inv != M){n_inv = M_abs - ((n_sub_inv * (M_abs / n)) % M_abs);m = n_inv;RE;}for(ll i = 1;i < M_abs;i++){if((n * i) % M_abs == 1){n_inv = i;m = n_inv;RE;}}n_inv = M;m = n_inv;RE;}TE <ll M> IN Mod<M>::Mod() : m_n(0),m_inv(M){}TE <ll M> IN Mod<M>::Mod(CO ll& n) : m_n(Residue<ll>(n,M)),m_inv(0){}TE <ll M> IN Mod<M>::Mod(CO Mod<M>& n) : m_n(n.m_n),m_inv(n.m_inv){}TE <ll M> IN Mod<M>& Mod<M>::OP=(CO ll& n) {m_n = Residue<ll>(n,M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP=(CO Mod<M>& n) {m_n = n.m_n;m_inv = n.m_inv;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP+=(CO ll& n) {m_n = Residue<ll>(m_n + Residue<ll>(n,M),M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP+=(CO Mod<M>& n) {m_n = Residue<ll>(m_n + n.m_n,M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP-=(CO ll& n) {m_n = Residue<ll>(m_n - Residue<ll>(n,M),M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP-=(CO Mod<M>& n) {m_n = Residue<ll>(m_n - n.m_n,M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP*=(CO ll& n) {m_n = Residue<ll>(m_n * Residue<ll>(n,M),M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP*=(CO Mod<M>& n) {m_n = Residue<ll>(m_n * n.m_n,M);m_inv = (m_inv == M || n.m_inv == M) ? M : Residue<ll>(m_inv * n.m_inv,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP/=(CO ll& n) {RE OP/=(Mod<M>(n));}TE <ll M> IN Mod<M>& Mod<M>::OP/=(CO Mod<M>& n) {RE OP*=(Inverse(n));}TE <ll M> IN Mod<M>& Mod<M>::OP%=(CO ll& n) {m_n %= Residue<ll>(n,M);m_inv = 0;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP%=(CO Mod<M>& n) {m_n %= n.m_n;m_inv = 0;RE *this;}TE <ll M> IN Mod<M> Mod<M>::OP-() CO {RE Mod<M>(0).OP-=(*this);}TE <ll M> IN Mod<M>& Mod<M>::OP++() {RE OP+=(1);}TE <ll M> IN Mod<M>& Mod<M>::OP++(int) {RE OP++();}TE <ll M> IN Mod<M>& Mod<M>::OP--() {RE OP-=(1);}TE <ll M> IN Mod<M>& Mod<M>::OP--(int) {RE OP--();}TE <ll M> IN CO ll& Mod<M>::Represent() CO {RE m_n;}TE <ll M>void Mod<M>::Invert() {if(CheckInvertible()){ll i = m_inv;m_inv = m_n;m_n = i;} else {m_n = M;m_inv = M;}RE;}TE <ll M>bool Mod<M>::CheckInvertible() {if(m_inv == 0){LazyEvaluationOfModularInverse(M,m_n,m_inv);}RE m_inv != M;}TE <ll M> IN bool Mod<M>::IsSmallerThan(CO ll& n) CO {RE m_n < Residue<ll>(n,M);}TE <ll M> IN bool Mod<M>::IsBiggerThan(CO ll& n) CO {RE m_n > Residue<ll>(n,M);}TE <ll M> IN void Mod<M>::swap(Mod<M>& n) {std::swap(m_n,n.m_n);std::swap(m_inv,n.m_inv);}TE <ll M> IN bool OP==(CO Mod<M>& n0,CO ll& n1) {RE n0 == Mod<M>(n1);}TE <ll M> IN bool OP==(CO ll& n0,CO Mod<M>& n1) {RE Mod<M>(n0) == n0;}TE <ll M> IN bool OP==(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0.Represent() == n1.Represent();}TE <ll M> IN bool OP!=(CO Mod<M>& n0,CO ll& n1) {RE !(n0 == n1);}TE <ll M> IN bool OP!=(CO ll& n0,CO Mod<M>& n1) {RE !(n0 == n1);}TE <ll M> IN bool OP!=(CO Mod<M>& n0,CO Mod<M>& n1) {RE !(n0 == n1);}TE <ll M> IN bool OP<(CO Mod<M>& n0,CO ll& n1) {RE n0.IsSmallerThan(n1);}TE <ll M> IN bool OP<(CO ll& n0,CO Mod<M>& n1) {RE n1.IsBiggerThan(n0);}TE <ll M> IN bool OP<(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0.Represent() < n1.Represent();}TE <ll M> IN bool OP<=(CO Mod<M>& n0,CO ll& n1) {RE !(n1 < n0);}TE <ll M> IN bool OP<=(CO ll& n0,CO Mod<M>& n1) {RE !(n1 < n0);}TE <ll M> IN bool OP<=(CO Mod<M>& n0,CO Mod<M>& n1) {RE !(n1 < n0);}TE <ll M> IN bool OP>(CO Mod<M>& n0,CO ll& n1) {RE n1 < n0;}TE <ll M> IN bool OP>(CO ll& n0,CO Mod<M>& n1) {RE n1 < n0;}TE <ll M> IN bool OP>(CO Mod<M>& n0,CO Mod<M>& n1) {RE n1 < n0;}TE <ll M> IN bool OP>=(CO Mod<M>& n0,CO ll& n1) {RE !(n0 < n1);}TE <ll M> IN bool OP>=(CO ll& n0,CO Mod<M>& n1) {RE !(n0 < n1);}TE <ll M> IN bool OP>=(CO Mod<M>& n0,CO Mod<M>& n1) {RE !(n0 < n1);}TE <ll M>Mod<M> OP+(CO Mod<M>& n0,CO ll& n1) {auto n = n0;n += n1;RE n;}TE <ll M> IN Mod<M> OP+(CO ll& n0,CO Mod<M>& n1) {RE n1 + n0;}TE <ll M> IN Mod<M> OP+(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0 + n1.Represent();}TE <ll M> IN Mod<M> OP-(CO Mod<M>& n0,CO ll& n1) {RE n0 + (-n1);}TE <ll M> IN Mod<M> OP-(CO ll& n0,CO Mod<M>& n1) {RE Mod<M>(n0 - n1.Represent());}TE <ll M> IN Mod<M> OP-(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0 - n1.Represent();}TE <ll M>Mod<M> OP*(CO Mod<M>& n0,CO ll& n1) {auto n = n0;n *= n1;RE n;}TE <ll M> IN Mod<M> OP*(CO ll& n0,CO Mod<M>& n1) {RE n1 * n0;}TE <ll M>Mod<M> OP*(CO Mod<M>& n0,CO Mod<M>& n1) {auto n = n0;n *= n1;RE n;}TE <ll M> IN Mod<M> OP/(CO Mod<M>& n0,CO ll& n1) {RE n0 / Mod<M>(n1);}TE <ll M> IN Mod<M> OP/(CO ll& n0,CO Mod<M>& n1) {RE Mod<M>(n0) / n1;}TE <ll M>Mod<M> OP/(CO Mod<M>& n0,CO Mod<M>& n1){auto n = n0;n /= n1;RE n;}TE <ll M>Mod<M> OP%(CO Mod<M>& n0,CO ll& n1){auto n = n0;n %= n1;RE n;}TE <ll M> IN Mod<M> OP%(CO ll& n0,CO Mod<M>& n1) {RE Mod<M>(n0) % n1.Represent();}TE <ll M> IN Mod<M> OP%(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0 % n1.Represent();}TE <ll M>Mod<M> Inverse(CO Mod<M>& n){auto n_copy = n;n_copy.Invert();RE n_copy;}TE <ll M>Mod<M> Power(CO Mod<M>& n,CO ll& p,CO string& method){if(p >= 0){RE Power<Mod<M>,ll>(n,p,1,true,true,method);}RE Inverse(Power<M>(n,-p,method));}TE <> IN Mod<2> Power(CO Mod<2>& n,CO ll& p,CO string& method) {RE p == 0 ? 1 : n;}TE <ll M> IN Mod<M> Power(CO Mod<M>& n,CO Mod<M>& p,CO string& method) {RE Power<Mod<M>,ll>(n,p.Represent(),method);}TE <> IN Mod<2> Power(CO Mod<2>& n,CO Mod<2>& p,CO string& method) {RE p == 0 ? 1 : n;}TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t) {RE t;}TE <ll M> IN string to_string(CO Mod<M>& n) {RE to_string(n.Represent()) + " + MZ";}TE <ll M> IN void swap(Mod<M>& n0,Mod<M>& n1) {n0.swap( n1 );}TE<ll M,class Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n) {RE os << n.Represent();}
