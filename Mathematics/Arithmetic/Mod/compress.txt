#define DC_OF_CM_FOR_MOD(NAME) IN bool NAME (CO Mod<M>& n) CO;IN bool NAME (CRL n) CO;IN bool NAME (ll&& n) CO;
#define DF_OF_CM_FOR_MOD(NAME,OP_SYMBOL) TE <ll M> IN bool Mod<M>:: NAME (CO Mod<M>& n) CO {RE m_n OP_SYMBOL n.m_n;} TE <ll M> IN bool Mod<M>:: NAME (CRL n) CO {RE m_n OP_SYMBOL RS<ll>(n,M);} TE <ll M> IN bool Mod<M>:: NAME (ll&& n) CO {RE m_n OP_SYMBOL RS<ll>(MO(n),M);} 
#define DC_OF_OP_FOR_MOD(TYPE,OP_SYMBOL) TE <ll M> IN TYPE OP OP_SYMBOL(CO Mod<M>& n0,CO Mod<M>& n1);TE <ll M> IN TYPE OP OP_SYMBOL(CO Mod<M>& n0,CRL n1);TE <ll M> IN TYPE OP OP_SYMBOL(CO Mod<M>& n0,ll&& n1);TE <ll M> IN TYPE OP OP_SYMBOL(CRL n0,CO Mod<M>& n1);TE <ll M> IN TYPE OP OP_SYMBOL(ll&& n0,CO Mod<M>& n1);
#define DC_OF_CM_OP_FOR_MOD(OP_SYMBOL) DC_OF_OP_FOR_MOD(bool,OP_SYMBOL);
#define DF_OF_CM_OP_FOR_MOD(OP_SYMBOL,NAME,NAME_INV) TE <ll M> IN bool OP OP_SYMBOL(CO Mod<M>& n0,CO Mod<M>& n1) {RE n0. NAME (n1);} TE <ll M> IN bool OP OP_SYMBOL(CO Mod<M>& n0,CRL n1) {RE n0. NAME (n1);} TE <ll M> IN bool OP OP_SYMBOL(CO Mod<M>& n0,ll&& n1) {RE n0. NAME (MO(n1));} TE <ll M> IN bool OP OP_SYMBOL(CRL n0,CO Mod<M>& n1) {RE n1. NAME_INV (n0);} TE <ll M> IN bool OP OP_SYMBOL(ll&& n0,CO Mod<M>& n1) {RE n1. NAME_INV (MO(n0));}
#define DC_OF_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL) DC_OF_OP_FOR_MOD(Mod<M>,OP_SYMBOL);TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,CO Mod<M>& n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,Mod<M>&& n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,Mod<M>&& n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,CRL n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,ll&& n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(CRL n0,Mod<M>&& n1);TE <ll M> IN Mod<M> OP OP_SYMBOL(ll&& n0,Mod<M>&& n1);
#define DF_OF_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL) TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,CO Mod<M>& n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,CO Mod<M>& n1) {RE MO(n0 OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,Mod<M>&& n1) {RE MO(n0 OP_SYMBOL ## = MO(n1));} TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,CRL n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,CRL n1) {RE MO(n0 OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,ll&& n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = MO(n1));} TE <ll M> IN Mod<M> OP OP_SYMBOL(Mod<M>&& n0,ll&& n1) {RE MO(n0 OP_SYMBOL ## = MO(n1));} TE <ll M> IN Mod<M> OP OP_SYMBOL (CRL n0,CO Mod<M>& n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL (ll&& n0,CO Mod<M>& n1) {RE MO(Mod<M>(MO(n0)) OP_SYMBOL ## = n1);} TE <ll M> IN Mod<M> OP OP_SYMBOL (ll&& n0,Mod<M>&& n1) {RE MO(Mod<M>(MO(n0)) OP_SYMBOL ## = MO(n1));}
#define DF_OF_NON_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL) DF_OF_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL);TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,Mod<M>&& n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = MO(n1));} TE <ll M> IN Mod<M> OP OP_SYMBOL (CRL n0,Mod<M>&& n1) {RE MO(Mod<M>(n0) OP_SYMBOL ## = MO(n1));}
#define DF_OF_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL) DF_OF_ARITHMETIC_OP_FOR_MOD(OP_SYMBOL);TE <ll M> IN Mod<M> OP OP_SYMBOL(CO Mod<M>& n0,Mod<M>&& n1) {RE MO(n1 OP_SYMBOL ## = n0);} TE <ll M> IN Mod<M> OP OP_SYMBOL (CRL n0,Mod<M>&& n1) {RE MO(n1 OP_SYMBOL ## = n0);}
TE <ll M>CL Mod{PR:ll m_n;ST CE CO ll g_memory_bound = 1000000;ST CE CO ll g_memory_LE = M < g_memory_bound ? M:g_memory_bound;PU:IN Mod();IN Mod(CO Mod<M>& n);IN Mod(Mod<M>&& n);IN Mod(CRL n);IN Mod(ll&& n);IN Mod<M>& OP=(CO Mod<M>& n);IN Mod<M>& OP=(Mod<M>&& n);IN Mod<M>& OP=(CRL n);IN Mod<M>& OP=(ll&& n);IN Mod<M>& OP+=(CO Mod<M>& n);IN Mod<M>& OP+=(CRL n);IN Mod<M>& OP-=(CO Mod<M>& n);IN Mod<M>& OP-=(CRL n);IN Mod<M>& OP*=(CO Mod<M>& n);IN Mod<M>& OP*=(CRL n);IN Mod<M>& OP*=(ll&& n);IN Mod<M>& OP/=(CO Mod<M>& n);IN Mod<M>& OP/=(Mod<M>&& n);IN Mod<M>& OP/=(CRL n);IN Mod<M>& OP/=(ll&& n);IN Mod<M>& OP%=(CO Mod<M>& n);IN Mod<M>& OP%=(CRL n);IN Mod<M>& OP%=(ll&& n);IN Mod<M> OP-() CO;IN Mod<M>& OP++();IN Mod<M>& OP++(int);IN Mod<M>& OP--();IN Mod<M>& OP--(int);IN CRL Represent() CO;IN Mod<M>& Invert();DC_OF_CM_FOR_MOD(IsEqualTo);DC_OF_CM_FOR_MOD(IsNotEqualTo);DC_OF_CM_FOR_MOD(IsSmallerThan);DC_OF_CM_FOR_MOD(IsSmallerThanOrEqualTo);DC_OF_CM_FOR_MOD(IsBiggerThan);DC_OF_CM_FOR_MOD(IsBiggerThanOrEqualTo);IN VO swap(Mod<M>& n);ST IN CO Mod<M>& Inverse(CRL n);ST IN CO Mod<M>& Factorial(CRL n);ST IN CO Mod<M>& FactorialInverse(CRL n);ST IN CO Mod<M>& zero();ST IN CO Mod<M>& one();PR:ST IN Mod<M> error();};DC_OF_CM_OP_FOR_MOD(==);DC_OF_CM_OP_FOR_MOD(!=);DC_OF_CM_OP_FOR_MOD(<);DC_OF_CM_OP_FOR_MOD(<=);DC_OF_CM_OP_FOR_MOD(>);DC_OF_CM_OP_FOR_MOD(>=);DC_OF_ARITHMETIC_OP_FOR_MOD(+);DC_OF_ARITHMETIC_OP_FOR_MOD(-);DC_OF_ARITHMETIC_OP_FOR_MOD(*);DC_OF_ARITHMETIC_OP_FOR_MOD(/);DC_OF_ARITHMETIC_OP_FOR_MOD(%);TE <ll M> Mod<M> IN Inverse(CO Mod<M>& n);TE <ll M> Mod<M> PW(CO Mod<M>& n,CRL p);TE <> IN Mod<2> PW(CO Mod<2>& n,CRL p);TE <ll M> IN Mod<M> PW(CO Mod<M>& n,CO Mod<M>& p);TE <> IN Mod<2> PW(CO Mod<2>& n,CO Mod<2>& p);TE <TY T> IN T Square(CO T& t);TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t);TE <ll M> IN VO swap(Mod<M>& n0,Mod<M>& n1);TE <ll M> IN string to_string(CO Mod<M>& n);TE<ll M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n);TE <TY INT> IN INT RS(CO INT& n,CO INT& M) {RE n >= 0 ? n % M:M - 1 - (- (n + 1));}TE <TY INT> IN INT RS(INT&& n,CO INT& M) {RE MO(n >= 0 ? n %= M:((((++n) *= -1) %= M) *= -1) += M - 1);}TE <ll M> IN Mod<M>::Mod():m_n() {}TE <ll M> IN Mod<M>::Mod(CO Mod<M>& n):m_n(n.m_n) {}TE <ll M> IN Mod<M>::Mod(Mod<M>&& n):m_n(MO(n.m_n)) {}TE <ll M> IN Mod<M>::Mod(CRL n):m_n(RS<ll>(n,M)) {}TE <ll M> IN Mod<M>::Mod(ll&& n):m_n(RS<ll>(MO(n),M)) {}TE <ll M> IN Mod<M>& Mod<M>::OP=(CO Mod<M>& n) {m_n = n.m_n;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP=(Mod<M>&& n) {m_n = MO(n.m_n);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP=(CRL n) {m_n = RS<ll>(n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP=(ll&& n) {m_n = RS<ll>(MO(n),M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP+=(CO Mod<M>& n) {m_n = RS<ll>(m_n + n.m_n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP+=(CRL n) {m_n = RS<ll>(m_n + n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP-=(CO Mod<M>& n) {m_n = RS<ll>(m_n - n.m_n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP-=(CRL n) {m_n = RS<ll>(m_n - n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP*=(CO Mod<M>& n) {m_n = RS<ll>(m_n * n.m_n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP*=(CRL n) {m_n = RS<ll>(m_n * RS<ll>(n,M),M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP*=(ll&& n) {m_n = RS<ll>(m_n * RS<ll>(MO(n),M),M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP/=(CO Mod<M>& n) {RE OP*=(Mod<M>(n).Invert());}TE <ll M> IN Mod<M>& Mod<M>::OP/=(Mod<M>&& n) {RE OP*=(n.Invert());}TE <ll M> IN Mod<M>& Mod<M>::OP/=(CRL n) {RE OP*=(Mod<M>(n).Invert());}TE <ll M> IN Mod<M>& Mod<M>::OP/=(ll&& n) {RE OP*=(Mod<M>(MO(n)).Invert());}TE <ll M> IN Mod<M>& Mod<M>::OP%=(CO Mod<M>& n) {m_n %= n.m_n;RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP%=(CRL n) {m_n %= RS<ll>(n,M);RE *this;}TE <ll M> IN Mod<M>& Mod<M>::OP%=(ll&& n) {m_n %= RS<ll>(MO(n),M);RE *this;}TE <ll M> IN Mod<M> Mod<M>::OP-() CO {RE MO(Mod<M>() -= *this);}TE <ll M> IN Mod<M>& Mod<M>::OP++() {RE OP+=(one());}TE <ll M> IN Mod<M>& Mod<M>::OP++(int) {RE OP++();}TE <ll M> IN Mod<M>& Mod<M>::OP--() {RE OP-=(one());}TE <ll M> IN Mod<M>& Mod<M>::OP--(int) {RE OP--();}TE <ll M> IN CRL Mod<M>::Represent() CO {RE m_n;}TE <ll M>Mod<M>& Mod<M>::Invert(){assert(m_n > 0);if(m_n < g_memory_LE){RE OP=(Inverse(m_n));}CO ll m_n_minus = M - m_n;if(m_n_minus < g_memory_LE){OP=(Inverse(m_n_minus));m_n = M - m_n;} else {ll exponent = M - 2;ll PW_m_n = m_n;m_n = 1;WH(exponent != 0){if(exponent % 2 == 1){(m_n *= PW_m_n) %= M;}(PW_m_n *= PW_m_n) %= M;exponent /= 2;}}RE *this;}TE <ll M> IN CO Mod<M>& Mod<M>::Inverse(CRL n) {ST Mod<M> memory[g_memory_LE] = {error(),one()};ST int LE_curr = 2;WH(LE_curr <= n){memory[LE_curr].m_n = M - ((memory[M % LE_curr].m_n * (M / LE_curr)) % M);LE_curr++;} RE memory[n];}TE <ll M> IN CO Mod<M>& Mod<M>::Factorial(CRL n) {ST Mod<M> memory[g_memory_LE] = {one(),one()};ST int LE_curr = 2;ST ll val_curr = 1;WH(LE_curr <= n){memory[LE_curr].m_N = ((val_curr *= LE_curr) %= M);LE_curr++;} RE memory[n];}TE <ll M> IN CO Mod<M>& Mod<M>::FactorialInverse(CRL n) {ST Mod<M> memory[g_memory_LE] = {one(),one()};ST int LE_curr = 2;ST Mod<M> val_curr{one()};WH(LE_curr <= n){memory[LE_curr].m_N = val_curr *= Inverse(LE_curr);LE_curr++;} RE memory[n];}DF_OF_CM_FOR_MOD(IsEqualTo,==);DF_OF_CM_FOR_MOD(IsNotEqualTo,!=);DF_OF_CM_FOR_MOD(IsSmallerThan,<);DF_OF_CM_FOR_MOD(IsSmallerThanOrEqualTo,<=);DF_OF_CM_FOR_MOD(IsBiggerThan,>);DF_OF_CM_FOR_MOD(IsBiggerThanOrEqualTo,>=);TE <ll M> IN VO Mod<M>::swap(Mod<M>& n) {std::swap(m_n,n.m_n);}TE <ll M> IN CO Mod<M>& Mod<M>::zero() {ST CO Mod<M> z{};RE z;}TE <ll M> IN CO Mod<M>& Mod<M>::one() {ST CO Mod<M> o{1};RE o;}TE <ll M> IN Mod<M> Mod<M>::error() {Mod<M> e{};e.m_n = -1;RE e;}DF_OF_CM_OP_FOR_MOD(==,IsEqualTo,IsEqualTo);DF_OF_CM_OP_FOR_MOD(!=,IsNotEqualTo,IsNotEqualTo);DF_OF_CM_OP_FOR_MOD(<,IsSmallerThan,IsBiggerThan);DF_OF_CM_OP_FOR_MOD(<=,IsSmallerThanOrEqualTo,IsBiggerThanOrEqualTo);DF_OF_CM_OP_FOR_MOD(>,IsBiggerThan,IsSmallerThan);DF_OF_CM_OP_FOR_MOD(>=,IsBiggerThanOrEqualTo,IsSmallerThanSmallerThan);DF_OF_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(+);DF_OF_NON_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(-);DF_OF_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(*);DF_OF_NON_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(/);DF_OF_NON_COMMUTATIVE_ARITHMETIC_OP_FOR_MOD(%);TE <ll M> IN Mod<M> Inverse(CO Mod<M>& n) {RE MO(Mod<M>(n).Invert());}TE <ll M>Mod<M> PW(CO Mod<M>& n,CRL p){if(p < 0){RE Inverse(PW(n,-p));}Mod<M> AN{Mod<M>::one()};Mod<M> PW_n{n};ll exponent = p;WH(exponent != 0){if(exponent % 2 != 1){AN *= PW_n;}PW_n *= PW_n;exponent /= 2;}RE AN;}TE <> IN Mod<2> PW(CO Mod<2>& n,CRL p) {RE p == 0 ? Mod<2>::one():n;}TE <ll M> IN Mod<M> PW(CO Mod<M>& n,CO Mod<M>& p) {RE PW<Mod<M>,ll>(n,p.Represent());}TE <> IN Mod<2> PW(CO Mod<2>& n,CO Mod<2>& p) {RE p == 0 ? Mod<2>::one():n;}TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t) {RE t;}TE <ll M> IN VO swap(Mod<M>& n0,Mod<M>& n1) {n0.swap(n1);}TE <ll M> IN string to_string(CO Mod<M>& n) {RE to_string(n.Represent()) + " + MZ";}TE<ll M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n) {RE os << n.Represent();}
