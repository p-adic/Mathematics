TE <TY INT1,TY INT2> IN INT1& RS(INT1& n,CO INT2& M) NE{RE n >= 0?n %= M:((((++n) *= -1) %= M) *= -1) += M - 1;}TE <TY INT1,TY INT2> IN INT1 RS(INT1&& n,CO INT2& M) NE{RE MO(RS(n,M));}TE <TY INT1,TY INT2> IN INT1 RS(CO INT1& n,CO INT2& M) NE{RE RS(MO(INT1(n)),M);}
#define SFINAE_TYPE_FOR_MOD(TYPE)  TY enable_if<is_constructible<int,decay_t<T> >::value,TYPE>::type
#define DC_OF_CM_FOR_MOD(FUNC) IN bool OP FUNC(CO Mod<M>& n) CO NE
#define DC_OF_AR_FOR_MOD(FUNC) IN Mod<M> OP FUNC(CO Mod<M>& n) CO NE;TE <TY T> IN SFINAE_TYPE_FOR_MOD(Mod<M>) OP FUNC(T&& n) CO NE;
#define DF_OF_CM_FOR_MOD(FUNC) TE <int M> IN bool Mod<M>::OP FUNC(CO Mod<M>& n) CO NE{RE m_n FUNC n.m_n;}
#define DF_OF_AR_FOR_MOD(FUNC,FORMULA) TE <int M> IN Mod<M> Mod<M>::OP FUNC(CO Mod<M>& n) CO NE{RE MO(Mod<M>(*TH) FUNC ## = n);}TE <int M> TE <TY T> IN SFINAE_TYPE_FOR_MOD(Mod<M>) Mod<M>::OP FUNC(T&& n) CO NE{RE FORMULA;}TE <int M,TY T> IN SFINAE_TYPE_FOR_MOD(Mod<M>) OP FUNC(T&& n0,CO Mod<M>& n1) NE{RE MO(Mod<M>(forward<T>(n0)) FUNC ## = n1);}
US ull = unsigned long long;TE <int M>CL Mod{PU:int m_n;IN Mod() NE;IN Mod(CO Mod<M>& n) NE;IN Mod(Mod<M>& n) NE;IN Mod(Mod<M>&& n) NE;TE <TY T> IN Mod(T& n,SFINAE_TYPE_FOR_MOD(int) dummy = 0) NE;TE <TY T> IN Mod(T&& n,SFINAE_TYPE_FOR_MOD(int) dummy = 0) NE;IN Mod<M>& OP=(CO Mod<M>& n) NE;IN Mod<M>& OP+=(CO Mod<M>& n) NE;IN Mod<M>& OP-=(CO Mod<M>& n) NE;IN Mod<M>& OP*=(CO Mod<M>& n) NE;IN Mod<M>& OP/=(CO Mod<M>& n);IN Mod<M>& OP++() NE;IN Mod<M> OP++(int) NE;IN Mod<M>& OP--() NE;IN Mod<M> OP--(int) NE;DC_OF_CM_FOR_MOD(==);DC_OF_CM_FOR_MOD(!=);DC_OF_CM_FOR_MOD(<);DC_OF_CM_FOR_MOD(<=);DC_OF_CM_FOR_MOD(>);DC_OF_CM_FOR_MOD(>=);DC_OF_AR_FOR_MOD(+);DC_OF_AR_FOR_MOD(-);DC_OF_AR_FOR_MOD(*);DC_OF_AR_FOR_MOD(/);IN Mod<M> OP-() CO NE;IN Mod<M>& SignInvert() NE;IN Mod<M>& Invert();TE <TY T> IN Mod<M>& PositivePW(T&& EX) NE;TE <TY T> IN Mod<M>& PW(T&& EX);IN CO int& Represent() CO NE;IN VO swap(Mod<M>& n) NE;ST IN CO Mod<M>& Inverse(CO int& n) NE;ST IN CO Mod<M>& Factorial(CO int& n) NE;ST IN CO Mod<M>& FactorialInverse(CO int& n) NE;ST IN CO Mod<M>& zero() NE;ST IN CO Mod<M>& one() NE;ST IN CE int BinaryDigitUpperBound() NE;ST IN CE ll MNBasePW(ll&& EX) NE;ST CE int g_M_minus = M - 1;ST CE int g_M_minus_2 = M - 2;ST CE int g_M_minus_2_neg = 2 - M;ST CE CO int g_MN_digit = 32;ST CE CO ll g_MN_base = ll(1) << g_MN_digit;ST CE CO UI g_MN_base_minus = UI(g_MN_base - 1);ST CE CO UI g_MN_M_neg_inverse = UI((g_MN_base - MNBasePW((ll(1) << (g_MN_digit - 1)) - 1)) & g_MN_base_minus);ST CE CO UI g_MN_base_square = UI((((g_MN_base % M) * (g_MN_base % M)) % M) & g_MN_base_minus);ST CE CO int g_memory_bound = 1000000;ST CE CO int g_memory_LE = M < g_memory_bound?M:g_memory_bound;ST IN int MNForm(CO int& n) NE;ST IN ll& MNReduction(ll& n) NE;ST IN int MNMU(CO int& n0,CO int& n1) NE;ST IN VO Normalise(int& n) NE;TE <TY T> IN Mod<M>& Ref(T&& n) NE;};TE <int M> Mod<M> IN Inverse(CO Mod<M>& n);TE <int M,TY T> IN Mod<M> PW(CO Mod<M>& n,CO T& EX);TE <TY T> IN Mod<2> PW(CO Mod<2>& n,CO T& p);TE <TY T> IN T Square(CO T& t);TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t);TE <int M> IN VO swap(Mod<M>& n0,Mod<M>& n1) NE;TE <int M> IN string to_string(CO Mod<M>& n) NE;TE<int M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n);
TE <int M> IN CE int Mod<M>::BinaryDigitUpperBound() NE{int AN = 0;int PW = 1;WH(M > PW){AN++;PW <<= 1;}assert(AN < 32);RE AN;}TE <int M> IN CE ll Mod<M>::MNBasePW(int&& EX) NE{ull prod = 1;ull PW = M;WH(EX != 0 ){(EX & 1) == 1?(prod *= power) &= g_MN_base_minus:prod;EX >>= 1;(power *= power) &= g_MN_base_minus;}RE ll(MO(prod));}TE <int M> IN int Mod<M>::MNForm(CO int& n) NE{ll n_copy = n;RE int(MO(MNReduction(n_copy *= g_MN_base_square)));}TE <int M> IN ll& Mod<M>::MNReduction(ll& n) NE{ll n_copy = n & g_MN_base_minus;RE ((n += ((n_copy *= g_MN_M_neg_inverse) &= g_MN_base_minus) *= M) >>= g_MN_digit) < M?n:n -= M;}TE <int M> IN int Mod<M>::MNMU(CO int& n0,CO int& n1) NE{ll n0_copy = n0;RE int(MO(MNReduction(MNReduction(n0_copy *= n1) *= g_MN_base_square)));}TE <int M> IN int& Mod<M>::Normalise(int& n) NE{RE n < 0?n += M:n;}TE <int M> IN Mod<M>::Mod() NE:m_n(){}TE <int M> IN Mod<M>::Mod(CO Mod<M>& n) NE:m_n(n.m_n){}TE <int M> IN Mod<M>::Mod(Mod<M>& n) NE:m_n(n.m_n){}TE <int M> IN Mod<M>::Mod(Mod<M>&& n) NE:m_n(MO(n.m_n)){}TE <int M> TE<TY T> IN Mod<M>::Mod(T& n,SFINAE_TYPE_FOR_MOD(int) dummy) NE:m_n(RS(decay_t<T>(n),M)){}TE <int M> TE<TY T> IN Mod<M>::Mod(T&& n,SFINAE_TYPE_FOR_MOD(int) dummy) NE:m_n(RS(forward<T>(n),M)){}TE <int M> IN Mod<M>& Mod<M>::OP=(CO Mod<M>& n) NE{RE Ref(m_n = n.m_n);}TE <int M> IN Mod<M>& Mod<M>::OP+=(CO Mod<M>& n) NE{RE Ref(Normalise(m_n += n.m_n - M));}TE <int M> IN Mod<M>& Mod<M>::OP-=(CO Mod<M>& n) NE{RE Ref(Normalise(m_n -= n.m_n));}TE <int M> IN Mod<M>& Mod<M>::OP*=(CO Mod<M>& n) NE{Ref(m_n = MNMU(m_n,n.m_n));}TE <int M> IN Mod<M>& Mod<M>::OP/=(CO Mod<M>& n){RE OP*=(Mod<M>(n).Invert());}TE <int M> TE <TY T> IN Mod<M>& Mod<M>::Ref(T&& n ) NE{RE *TH;}TE <int M> IN Mod<M>& Mod<M>::OP++() NE{RE Ref(m_n < g_M_minus?++m_n:m_n = 0);}TE <int M> IN Mod<M> Mod<M>::OP++(int) NE{Mod<M> n{*TH};OP++();RE n;}TE <int M> IN Mod<M>& Mod<M>::OP--() NE{RE Ref(m_n == 0?m_n = g_M_minus:--m_n);}TE <int M> IN Mod<M> Mod<M>::OP--(int) NE{Mod<M> n{*TH};OP--();RE n;}DF_OF_CM_FOR_MOD(==);DF_OF_CM_FOR_MOD(!=);DF_OF_CM_FOR_MOD(>);DF_OF_CM_FOR_MOD(>=);DF_OF_CM_FOR_MOD(<);DF_OF_CM_FOR_MOD(<=);DF_OF_AR_FOR_MOD(+,Mod<M>(forward<T>(n)) += *TH);DF_OF_AR_FOR_MOD(-,Mod<M>(forward<T>(n)).SignInvert() += *TH);DF_OF_AR_FOR_MOD(*,Mod<M>(forward<T>(n)) *= *TH);DF_OF_AR_FOR_MOD(/,Mod<M>(forward<T>(n)).Invert() *= *TH);TE <int M> IN Mod<M> Mod<M>::OP-() CO NE{RE MO(Mod<M>(*TH).SignInvert());}TE <int M> IN Mod<M>& Mod<M>::SignInvert() NE{RE Ref(m_n > 0?m_n = M - m_n:m_n);}TE <int M> IN Mod<M>& Mod<M>::Invert(){assert(m_n > 0);int m_n_neg; RE m_n < g_memory_LE?Ref(m_n = Inverse(m_n).m_n):(m_n_neg = M - m_n < g_memory_LE)?Ref(m_n = M - Inverse(m_n_neg).m_n):PositivePW(int(g_M_minus_2));}TE <> IN Mod<2>& Mod<2>::Invert(){assert(m_n > 0);RE *TH;}TE <> TE <TY T> IN Mod<2>& Mod<2>::PositivePW(T&& EX) NE{RE *TH;}TE <int M> TE <TY T> IN Mod<M>& Mod<M>::PositivePW(T&& EX) NE{ll prod = g_MN_base;ll PW = MNForm(m_n);WH(EX != 0){(EX & 1) == 1?MNReduction(prod *= PW):prod;EX >>= 1;MNReduction(PW *= PW);}RE Ref(m_n = int(MO(MNReduction(prod))));}TE <int M> TE <TY T> IN Mod<M>& Mod<M>::PW(T&& EX){bool neg = EX < 0;assert(!neg || m_n != 0);neg?EX *= g_M_minus_2_neg:EX;RE m_n == 0?*TH:(EX %= g_M_minus) == 0?Ref(m_n = 1):PositivePW(forward<T>(EX));}TE <int M> IN CO Mod<M>& Mod<M>::Inverse(CO int& n) NE{ST Mod<M> memory[g_memory_LE] ={zero(),one()};ST int LE_curr = 2;WH(LE_curr <= n){memory[LE_curr].m_n = M - MNMU(memory[M % LE_curr].m_n,M / LE_curr);LE_curr++;}RE memory[n];}TE <int M> IN CO Mod<M>& Mod<M>::Factorial(CO int& n) NE{ST Mod<M> memory[g_memory_LE] = {one(),one()};ST int LE_curr = 2;ST ll val_curr = g_MN_base;ll val_copy;WH(LE_curr <= n){memory[LE_curr].m_n = int(MO(MNReduction(val_copy = MNReduction(val_curr *= MNForm(LE_curr)))));LE_curr++;}RE memory[n];}TE <int M> IN CO Mod<M>& Mod<M>::FactorialInverse(CO int& n ) NE{ST Mod<M> memory[g_memory_LE] = {one(),one()}; ST int LE_curr = 2;ST ll val_curr = g_MN_base;ll val_copy;WH(LE_curr <= n){memory[LE_curr].m_n = int(MO(MNReduction(val_copy = MNReduction(val_curr *= MNForm(Inverse(LE_curr).m_n)))));LE_curr++;}RE memory[n];}TE <int M> IN CO int& Mod<M>::Represent() CO NE{RE m_n;}TE <int M> IN VO Mod<M>::swap(Mod<M>& n) NE{std::swap(m_n,n.m_n);}TE <int M> IN CO Mod<M>& Mod<M>::zero() NE{ST CO Mod<M> z{};RE z;}TE <int M> IN CO Mod<M>& Mod<M>::one() NE{ST CO Mod<M> o{1};RE o;}TE <int M> IN Mod<M> Inverse(CO Mod<M>& n){RE MO(Mod<M>(n).Invert());}TE <int M,TY T> IN Mod<M> PW(CO Mod<M>& n,CO T& EX){RE MO(Mod<M>(n).PW(T(EX)));}TE <TY T> IN Mod<2> PW(CO Mod<2>& n,CO T& EX){RE EX == 0?Mod<2>::one():n;}TE <> IN Mod<2> Square<Mod<2> >(CO Mod<2>& t){RE t;}TE <int M> IN VO swap(Mod<M>& n0,Mod<M>& n1) NE{n0.swap(n1);}TE <int M> IN string to_string(CO Mod<M>& n) NE{RE to_string(n.Represent()) + " + MZ";}TE<int M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n){RE os << n.Represent();}
