#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/ConstexprModulo/Montgomery/a_Body.hpp"
#else
#define RP Represent
#define DeRP Derepresent
#define MN Montgomery
CEXPR(int,P,998244353);
TE <uint M,TY INT> CE INT RS(INT n)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < INT(M)?n:n %= M);}
#define DC_OF_CM_FOR_MN(OPR)CE bool OP OPR(CO MN<M>& n)CO NE
#define DC_OF_AR_FOR_MN(OPR,EX)IN MN<M> OP OPR(MN<M> n)CO EX;
#define DF_OF_CM_FOR_MN(OPR)TE <uint M> CE bool MN<M>::OP OPR(CO MN<M>& n)CO NE{RE m_n OPR n.m_n;}
#define DF_OF_AR_FOR_MN(OPR,EX,LEFT,OPR2)TE <uint M> IN MN<M> MN<M>::OP OPR(MN<M> n)CO EX{RE MO(LEFT OPR2 ## = *TH);}TE <uint M,TY T> IN MN<M> OP OPR(T n0,CO MN<M>& n1)EX{RE MO(MN<M>(MO(n0))OPR ## = n1);}
TE <uint M>CL MN{PU:uint m_n;CE MN()NE;CE MN(CO MN<M>& n)NE;CE MN(MN<M>&& n)NE;TE <TY T> CE MN(T n)NE;CE MN<M>& OP=(MN<M> n)NE;CE MN<M>& OP+=(CO MN<M>& n)NE;CE MN<M>& OP-=(CO MN<M>& n)NE;CE MN<M>& OP*=(CO MN<M>& n)NE;IN MN<M>& OP/=(MN<M> n);TE <TY INT> CE MN<M>& OP<<=(INT n);TE <TY INT> CE MN<M>& OP>>=(INT n);CE MN<M>& OP++()NE;CE MN<M> OP++(int)NE;CE MN<M>& OP--()NE;CE MN<M> OP--(int)NE;DC_OF_CM_FOR_MN(==);DC_OF_CM_FOR_MN(!=);DC_OF_AR_FOR_MN(+,NE);DC_OF_AR_FOR_MN(-,NE);DC_OF_AR_FOR_MN(*,NE);DC_OF_AR_FOR_MN(/,);TE <TY INT> CE MN<M> OP^(INT EX)CO;TE <TY INT> CE MN<M> OP<<(INT n)CO;TE <TY INT> CE MN<M> OP>>(INT n)CO;CE MN<M> OP-()CO NE;CE MN<M>& SignInvert()NE;CE MN<M>& Invert();TE <TY INT> CE MN<M>& Power(INT EX);CE VO swap(MN<M>& n)NE;CE uint RP()CO NE;ST CE MN<M> DeRP(CRUI n)NE;ST IN CO MN<M>& Inverse(CRUI n);ST IN CO MN<M>& Factorial(CRUI n);ST IN CO MN<M>& FactorialInverse(CRUI n);ST IN MN<M> Combination(CRUI n,CRUI i);ST IN CO MN<M>& zero()NE;ST IN CO MN<M>& one()NE;ST IN CO MN<M>& two()NE;ST CE uint GetModulo()NE;ST CE uint Form(CRUI n)NE;ST CE ull& Reduction(ull& n)NE;ST CE ull& ReducedMU(ull& n,CRUI m)NE;ST CE uint BaseSquareTruncation(uint& n)NE;TE <TY INT> CE MN<M>& PositivePower(INT EX)NE;TE <TY INT> CE MN<M>& NonNegativePower(INT EX)NE;TE <TY T> CE MN<M>& Ref(T&& n)NE;ST CE uint& Normalise(uint& n)NE;};
US MP = MN<P>;
TE <uint M>CL COantsForMN{PU:COantsForMN()= delete;ST CE CO bool g_even =((M & 1)== 0);ST CE CO uint g_memory_bound =
#ifdef DEBUG
1e3;
#else
1e6;
#endif
ST CE CO uint g_memory_LE = M < g_memory_bound?M:g_memory_bound;ST CE uint g_M_minus_2 = M - 2;ST CE uint g_M_minus_2_neg = 2 - M;ST CE ull MNBasePW(ull&& EX)NE;ST CE CO int g_MN_digit = 32;ST CE CO ull g_MN_base = ull(1)<< g_MN_digit;ST CE CO uint g_MN_base_minus = uint(g_MN_base - 1);ST CE CO uint g_MN_digit_half =(g_MN_digit + 1)>> 1;ST CE CO uint g_MN_base_sqrt_minus =(1 << g_MN_digit_half)- 1;ST CE CO uint g_MN_M_neg_inverse = uint((g_MN_base - MNBasePW((ull(1)<<(g_MN_digit - 1))- 1))& g_MN_base_minus);ST CE CO uint g_MN_base_mod = uint(g_MN_base % M);ST CE CO uint g_MN_base_square_mod = uint(((g_MN_base % M)*(g_MN_base % M))% M);};
TE <uint M> CE ull COantsForMN<M>::MNBasePW(ull&& EX)NE{ull prod = 1;ull PW = M;WH(EX != 0){(EX & 1)== 1?(prod *= PW)&= g_MN_base_minus:prod;EX >>= 1;(PW *= PW)&= g_MN_base_minus;}RE prod;}
TE <uint M> CE MN<M>::MN()NE:m_n(){ST_AS(!COantsForMN<M>::g_even);}TE <uint M> CE MN<M>::MN(CO MN<M>& n)NE:m_n(n.m_n){}TE <uint M> CE MN<M>::MN(MN<M>&& n)NE:m_n(MO(n.m_n)){}TE <uint M> TE <TY T> CE MN<M>::MN(T n)NE:m_n(Form(Residue<M>(MO(n)))){ST_AS(!COantsForMN<M>::g_even && is_COructible_v<uint,decay_t<T> >);}TE <uint M> CE MN<M>& MN<M>::OP=(MN<M> n)NE{RE Ref(m_n = MO(n.m_n));}TE <uint M> CE MN<M>& MN<M>::OP+=(CO MN<M>& n)NE{RE Ref(Normalise(m_n += n.m_n));}TE <uint M> CE MN<M>& MN<M>::OP-=(CO MN<M>& n)NE{RE Ref(m_n < n.m_n?(m_n += M)-= n.m_n:m_n -= n.m_n);}TE <uint M> CE MN<M>& MN<M>::OP*=(CO MN<M>& n)NE{ull m_n_copy = m_n;RE Ref(m_n = MO(ReducedMU(m_n_copy,n.m_n)));}TE <uint M> IN MN<M>& MN<M>::OP/=(MN<M> n){RE OP*=(MN<M>(n).Invert());}TE <uint M> TE <TY INT> CE MN<M>& MN<M>::OP<<=(INT n){RE AS(n >= 0);RE *TH *= MN<M>(two()).NonNegativePower(MO(n));}TE <uint M> TE <TY INT> CE MN<M>& MN<M>::OP>>=(INT n){AS(n >=0);WH(n-- > 0){((m_n & 1)== 0?m_n:m_n += M)>>= 1;}RE *TH;}TE <uint M> CE MN<M>& MN<M>::OP++()NE{RE Ref(Normalise(m_n += COantsForMN<M>::g_MN_base_mod));}TE <uint M> CE MN<M> MN<M>::OP++(int)NE{MN<M> n{*TH};OP++();RE n;}TE <uint M> CE MN<M>& MN<M>::OP--()NE{RE Ref((m_n < COantsForMN<M>::g_MN_base_mod?m_n += M:m_n)-= COantsForMN<M>::g_MN_base_mod);}TE <uint M> CE MN<M> MN<M>::OP--(int)NE{MN<M> n{*TH};OP--();RE n;}DF_OF_CM_FOR_MN(==);DF_OF_CM_FOR_MN(!=);DF_OF_AR_FOR_MN(+,NE,n,+);DF_OF_AR_FOR_MN(-,NE,n.SignInvert(),+);DF_OF_AR_FOR_MN(*,NE,n,*);DF_OF_AR_FOR_MN(/,,n.Invert(),*);TE <uint M> TE <TY INT> CE MN<M> MN<M>::OP^(INT EX)CO{RE MO(MN<M>(*TH).Power(MO(EX)));}TE <uint M> TE <TY INT> CE MN<M> MN<M>::OP<<(INT n)CO{RE MO(MN<M>(*TH)<<= MO(n));}TE <uint M> TE <TY INT> CE MN<M> MN<M>::OP>>(INT n)CO{RE MO(MN<M>(*TH)>>= MO(n));}TE <uint M> CE MN<M> MN<M>::OP-()CO NE{RE MO(MN<M>(*TH).SignInvert());}TE <uint M> CE MN<M>& MN<M>::SignInvert()NE{RE Ref(m_n > 0?m_n = M - m_n:m_n);}TE <uint M> CE MN<M>& MN<M>::Invert(){AS(m_n != 0);RE PositivePower(uint(COantsForMN<M>::g_M_minus_2));}TE <uint M> TE <TY INT> CE MN<M>& MN<M>::PositivePower(INT EX)NE{MN<M> pw{*TH};(--EX)%= COantsForMN<M>::g_M_minus_2;WH(EX != 0){(EX & 1)== 1?*TH *= pw:*TH;EX >>= 1;pw *= pw;}RE *TH;}TE <uint M> TE <TY INT> CE MN<M>& MN<M>::NonNegativePower(INT EX)NE{RE EX == 0?Ref(m_n = COantsForMN<M>::g_MN_base_mod):PositivePower(MO(EX));}TE <uint M> TE <TY INT> CE MN<M>& MN<M>::Power(INT EX){bool neg = EX < 0;AS(!(neg && m_n == 0));RE neg?PositivePower(MO(EX *= COantsForMN<M>::g_M_minus_2_neg)):NonNegativePower(MO(EX));}TE <uint M> CE VO MN<M>::swap(MN<M>& n)NE{std::swap(m_n,n.m_n);}TE <uint M> CE uint MN<M>::RP()CO NE{ull m_n_copy = m_n;RE MO(Reduction(m_n_copy));}TE <uint M> CE MN<M> MN<M>::DeRP(CRUI n)NE{MN<M> n_copy{};n_copy.m_n = Form(n);RE n_copy;}TE <uint M> IN CO MN<M>& MN<M>::Inverse(CRUI n){AS(n < COantsForMN<M>::g_memory_le);ST uint memory0[COantsForMN<M>::g_memory_le]={0,1};ST MN<M> memory1[COantsForMN<M>::g_memory_le]={zero(),one()};ST uint le_curr = 2;WH(le_curr <= n){memory1[le_curr].m_n = Form(memory0[le_curr]= M - memory0[M % le_curr]* ull(M / le_curr)% M);le_curr++;}RE memory1[n];}TE <uint M> IN CO MN<M>& MN<M>::Factorial(CRUI n){if(M <= n){RE zero();}ST VE<Mod<M>> memory ={one(),one()};ST uint le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* le_curr);le_curr++;}RE memory[n];}TE <uint M> IN CO MN<M>& MN<M>::FactorialInverse(CRUI n){ST VE<Mod<M>> memory ={one(),one()};ST uint le_curr = 2;WH(le_curr <= n){memory.push_back(memory[le_curr - 1]* Inverse(le_curr));le_curr++;}RE memory[n];}TE <uint M> IN MN<M> MN<M>::Combination(CRUI n,CRUI i){RE i <= n?Factorial(n)* FactorialInverse(i)* FactorialInverse(n - i):zero();}TE <uint M> IN CO MN<M>& MN<M>::zero()NE{ST CE CO MN<M> z{};RE z;}TE <uint M> IN CO MN<M>& MN<M>::one()NE{ST CE CO MN<M> o{1};RE o;}TE <uint M> IN CO MN<M>& MN<M>::two()NE{ST CE CO MN<M> t{2};RE t;}TE <uint M> CE uint MN<M>::GetModulo()NE{RE M;}TE <uint M> CE uint MN<M>::Form(CRUI n)NE{ull n_copy = n;RE uint(MO(Reduction(n_copy *= COantsForMN<M>::g_MN_base_square_mod)));}TE <uint M> CE ull& MN<M>::Reduction(ull& n)NE{ull n_sub = n & COantsForMN<M>::g_MN_base_minus;RE((n +=((n_sub *= COantsForMN<M>::g_MN_M_neg_inverse)&= COantsForMN<M>::g_MN_base_minus)*= M)>>= COantsForMN<M>::g_MN_digit)< M?n:n -= M;}TE <uint M> CE ull& MN<M>::ReducedMU(ull& n,CRUI m)NE{RE Reduction(n *= m);}TE <uint M> CE uint MN<M>::BaseSquareTruncation(uint& n)NE{CO uint n_u = n >> COantsForMN<M>::g_MN_digit_half;n &= COantsForMN<M>::g_MN_base_sqrt_minus;RE n_u;}TE <uint M> TE <TY T> CE MN<M>& MN<M>::Ref(T&& n)NE{RE *TH;}TE <uint M> CE uint& MN<M>::Normalise(uint& n)NE{RE n < M?n:n -= M;}TE <uint M> CE MN<M> Inverse(CO MN<M>& n){RE MO(MN<M>(n).Invert());}TE <uint M,TY INT> CE MN<M> Power(MN<M> n,INT EX){RE MO(n.Power(MO(EX)));}TE <uint M> CE VO swap(MN<M>& n0,MN<M>& n1)NE{n0.swap(n1);}TE <uint M> IN string to_string(CO MN<M>& n)NE{RE to_string(n.RP())+ to_string(M)+ "Z";}TE <uint M,CL Traits> IN IS& OP>>(IS& is,MN<M>& n){ll m;is >> m;n = m;RE is;}TE<uint M,CL Traits> IN OS& OP<<(OS& os,CO MN<M>& n){RE os << n.RP();}

TE <uint M> DC_OF_HASH_FOR_MOD(MN<M>); TE <uint M> DF_OF_HASH_FOR_MOD(MOD<M>);
#endif
