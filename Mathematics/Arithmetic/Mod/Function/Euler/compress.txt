TE <TY INT,INT val_limit,int LE_max = val_limit>CL PrimeEnumeration{PU:INT m_val[LE_max];int m_LE;CE PrimeEnumeration();};TE <TY INT,INT val_limit,int LE_max>CE PrimeEnumeration<INT,val_limit,LE_max>::PrimeEnumeration():m_val(),m_LE(0){bool is_comp[val_limit] ={};for(INT i = 2;i < val_limit;i++){if(is_comp[i] == false){INT j = i;WH((j += i) < val_limit){is_comp[j] = true;}m_val[m_LE++] = i;if(m_LE >= LE_max){break;}}}}TE <TY INT,INT val_limit,int LE_max>VO SetPrimeFactorisation(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,CO INT& n,VE<INT>& P,VE<INT>& EX){INT n_copy = n;int i = 0;WH(i < prime.m_LE){CO INT& p = prime.m_val[i];if(p * p > n_copy){break;}if(n_copy % p == 0){P.push_back(p);EX.push_back(1);INT& EX_back = EX.back();n_copy /= p;WH(n_copy % p == 0){EX_back++;n_copy /= p;}}i++;}if(n_copy != 1){P.push_back(n_copy);EX.push_back(1);}RE;}
#define EULER_FUNCTION EX.clear();INT AN = n;CO INT SZ = P.SZ();for(INT i = 0;i < SZ;i++){AN -= AN / P[i];}RE AN;
TE <TY INT,INT val_limit,int LE_max>INT EulerFunction(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,CO INT& n,VE<INT>& P,VE<INT>& EX){SetPrimeFactorisation(prime,n,P,EX);EULER_FUNCTION;}TE <TY INT,INT val_limit,int LE_max>IN INT EulerFunction(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,CO INT& n){VE<INT> P{};VE<INT> EX{};RE EulerFunction(prime,n,P,EX);}TE <TY INT,INT val_limit,int LE_max,int SZ,TY INT2>VO MemoriseEulerFunction(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT2(&memory)[SZ]){ST INT quotient[SZ];for(int n = 1;n < SZ;n++){memory[n] = quotient[n] = n;}for(int i = 0;i < prime.m_LE;i++){CO INT& p_i = prime.m_val[i];int n = 0;WH((n += p_i)< SZ){INT2& memory_n = memory[n];INT& quotient_n = quotient[n];memory_n -= memory_n / p_i;WH((quotient_n /= p_i)% p_i == 0){}}}for(int n = val_limit;n < SZ;n++){CO INT& quotient_n = quotient[n];if(quotient_n != 1){INT2& memory_n = memory[n];memory_n -= memory_n / quotient_n;}}RE;}
