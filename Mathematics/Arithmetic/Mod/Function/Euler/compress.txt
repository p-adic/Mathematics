#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/Function/Euler/a_Body.hpp"
#else
// EulerFunction(CO PrimeEnumeration<INT1,val_limit,LE_max>& prime,CO INT2& n);
// TotalEulerFunction(CO PrimeEnumeration<INT1,val_limit,LE_max>& prime,CO INT2& n_max);
// が使用可能。val_limitは(nの上限の平方根+1)に設定すればよい。

TE <TY INT,INT val_limit,int LE_max = val_limit>CL PrimeEnumeration{PU:bool m_is_composite[val_limit];INT m_val[LE_max];int m_LE;CE PrimeEnumeration();IN CO INT& OP[](CRI i)CO;CE CO INT& Get(CRI i)CO;CE CO bool& IsComposite(CRI n)CO;CE CRI LE()CO NE;};
TE <TY INT,INT val_limit,int LE_max> CE PrimeEnumeration<INT,val_limit,LE_max>::PrimeEnumeration():m_is_composite(),m_val(),m_LE(0){for(INT i = 2;i < val_limit;i++){if(! m_is_composite[i]){if(i <=(val_limit - 1)/ i){for(INT j = i * i;j < val_limit;j += i){m_is_composite[j]= true;}}m_val[m_LE++]= i;if(m_LE >= LE_max){break;}}}}TE <TY INT,INT val_limit,int LE_max> IN CO INT& PrimeEnumeration<INT,val_limit,LE_max>::OP[](CRI i)CO{AS(0 <= i && i < m_LE);RE m_val[i];}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::Get(CRI i)CO{RE m_val[i];}TE <TY INT,INT val_limit,int LE_max> CE CO bool& PrimeEnumeration<INT,val_limit,LE_max>::IsComposite(CRI n)CO{RE m_is_composite[n];}TE <TY INT,INT val_limit,int LE_max> CE CRI PrimeEnumeration<INT,val_limit,LE_max>::LE()CO NE{RE m_LE;}

TE <TY INT1,INT1 val_limit,int LE_max,TY INT2>pair<VE<INT1>,VE<int>> PrimeFactorisation(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT2 n){VE<INT1> P{};VE<int> E{};CRI LE = pe.LE();for(int i = 0;i < LE;i++){CO INT1& p = pe[i];if(n % p == 0){int e = 1;WH((n /= p)% p == 0){e++;}P.push_back(p);E.push_back(e);}else if(n / p < p){break;}}if(n != 1){P.push_back(n);E.push_back(1);}RE{MO(P),MO(E)};}TE <TY INT1,INT1 val_limit,int LE_max,TY INT2>tuple<VE<INT1>,VE<int>,VE<INT2>> PrimePWFactorisation(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT2 n){VE<INT1> P{};VE<int> E{};VE<INT2> Q{};CRI LE = pe.LE();for(int i = 0;i < LE;i++){CO INT1& p = pe[i];if(n % p == 0){int e = 1;INT2 q = p;WH((n /= p)% p == 0){e++;q *= p;}P.push_back(p);E.push_back(e);Q.push_back(q);}else if(n / p < p){break;}}if(n != 1){P.push_back(n);E.push_back(1);Q.push_back(n);}RE{MO(P),MO(E),MO(Q)};}

TE <TY PF,TY INT>INT EulerFunction_Body(PF pf,CO INT& n){auto[P,E]= pf(n);INT AN = n;for(auto& p:P){AN -= AN / p;}RE{AN,MO(P),MO(E)};}TE <TY INT> IN INT EulerFunction(CO INT& n){RE EulerFunction_Body(PrimeFactorisation,n);}TE <TY INT1,INT1 val_limit,int LE_max,int SZ,TY INT2>VE<INT2> TotalEulerFunction(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,CO INT2& n_max){VE<INT2> AN(n_max + 1);for(INT2 n = 1;n <= n_max;n++){AN[n]= n;}auto quotient = AN;CRI LE = pe.LE();for(int i = 0;i < LE;i++){CO INT2& p_i = pe[i];INT2 n = 0;WH((n += p_i)<= n_max){INT2& AN_n = AN[n];INT2& quotient_n = quotient[n];AN_n -= AN_n / p_i;WH((quotient_n /= p_i)% p_i == 0){}}}for(INT2 n = val_limit;n <= n_max;n++){CO INT2& quotient_n = quotient[n];if(quotient_n != 1){INT2& AN_n = AN[n];AN_n -= AN_n / quotient_n;}}RE AN;}
#endif

