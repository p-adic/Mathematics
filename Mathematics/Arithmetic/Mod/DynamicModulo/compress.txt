#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Mod/DynamicModulo/Debug/a_Body.hpp"
#else
TE <TY INT1,TY INT2> CE INT1 RS(INT1 n,CO INT2& M)NE{RE MO(n < 0?((((++n)*= -1)%= M)*= -1)+= M - 1:n < M?n:n %= M);}

TE <int NUM> CL DynamicMods;TE <int NUM>CL COantsForDynamicMods{PU:COantsForDynamicMods()= delete;ST uint g_M;ST uint g_M_minus;ST int g_order_minus_1;ST int g_order_minus_1_neg;ST bool g_M_is_prime;};
TE <int NUM> uint COantsForDynamicMods<NUM>::g_M = 0;TE <int NUM> uint COantsForDynamicMods<NUM>::g_M_minus = -1;TE <int NUM> int COantsForDynamicMods<NUM>::g_order = 1;TE <int NUM> int COantsForDynamicMods<NUM>::g_order_minus_1 = 0;TE <int NUM> int COantsForDynamicMods<NUM>::g_order_minus_1_neg = 0;TE <int NUM> bool COantsForDynamicMods<NUM>::g_M_is_prime = false;

#define DC_OF_CM_FOR_DYNAMIC_MOD(OPR)IN bool OP OPR(CO DynamicMods<NUM>& n)CO NE
#define DC_OF_AR_FOR_DYNAMIC_MOD(OPR,EX)IN DynamicMods<NUM> OP OPR(DynamicMods<NUM> n)CO EX;
#define DF_OF_CM_FOR_DYNAMIC_MOD(OPR)TE <int NUM> IN bool DynamicMods<NUM>::OP OPR(CO DynamicMods<NUM>& n)CO NE{RE m_n OPR n.m_n;}
#define DF_OF_AR_FOR_DYNAMIC_MOD(OPR,EX,LEFT,OPR2)TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP OPR(DynamicMods<NUM> n)CO EX{RE MO(LEFT OPR2 ## = *TH);}TE <int NUM,TY T> IN DynamicMods<NUM> OP OPR(T n0,CO DynamicMods<NUM>& n1)EX{RE MO(DynamicMods<NUM>(MO(n0))OPR ## = n1);}
TE <int NUM>CL DynamicMods{PU:uint m_n;IN DynamicMods()NE;IN DynamicMods(CO DynamicMods<NUM>& n)NE;IN DynamicMods(DynamicMods<NUM>&& n)NE;TE <TY T> IN DynamicMods(T n)NE;IN DynamicMods<NUM>& OP=(DynamicMods<NUM> n)NE;IN DynamicMods<NUM>& OP+=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP-=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP*=(CO DynamicMods<NUM>& n)NE;IN DynamicMods<NUM>& OP/=(DynamicMods<NUM> n);TE <TY INT> IN DynamicMods<NUM>& OP<<=(INT n);TE <TY INT> IN DynamicMods<NUM>& OP>>=(INT n);IN DynamicMods<NUM>& OP++()NE;IN DynamicMods<NUM> OP++(int)NE;IN DynamicMods<NUM>& OP--()NE;IN DynamicMods<NUM> OP--(int)NE;DC_OF_CM_FOR_DYNAMIC_MOD(==);DC_OF_CM_FOR_DYNAMIC_MOD(!=);DC_OF_CM_FOR_DYNAMIC_MOD(<);DC_OF_CM_FOR_DYNAMIC_MOD(<=);DC_OF_CM_FOR_DYNAMIC_MOD(>);DC_OF_CM_FOR_DYNAMIC_MOD(>=);DC_OF_AR_FOR_DYNAMIC_MOD(+,NE);DC_OF_AR_FOR_DYNAMIC_MOD(-,NE);DC_OF_AR_FOR_DYNAMIC_MOD(*,NE);DC_OF_AR_FOR_DYNAMIC_MOD(/,);TE <TY INT> IN DynamicMods<NUM> OP^(INT EX)CO;TE <TY INT> IN DynamicMods<NUM> OP<<(INT n)CO;TE <TY INT> IN DynamicMods<NUM> OP>>(INT n)CO;IN DynamicMods<NUM> OP-()CO NE;IN DynamicMods<NUM>& SignInvert()NE;IN DynamicMods<NUM>& Invert();TE <TY INT> IN DynamicMods<NUM>& PW(INT EX);IN VO swap(DynamicMods<NUM>& n)NE;IN CRUI RP()CO NE;ST IN DynamicMods<NUM> DeRP(uint n)NE;ST IN CO DynamicMods<NUM>& Inverse(CRUI n);ST IN CO DynamicMods<NUM>& Factorial(CRUI n);ST IN CO DynamicMods<NUM>& FactorialInverse(CRUI n);ST IN DynamicMods<NUM> Combination(CRUI n,CRUI i);ST IN CO DynamicMods<NUM>& zero()NE;ST IN CO DynamicMods<NUM>& one()NE;ST IN CRUI GetModulo()NE;ST IN VO SetModulo(CRUI M,CRI order_minus_1 = -1)NE;TE <TY INT> IN DynamicMods<NUM>& PositivePW(INT EX)NE;TE <TY INT> IN DynamicMods<NUM>& NonNegativePW(INT EX)NE;US COants = COantsForDynamicMods<NUM>;};
US DynamicMod = DynamicMods<0>;
TE <int NUM> IN DynamicMods<NUM>::DynamicMods()NE:m_n(){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(CO DynamicMods<NUM>& n)NE:m_n(n.m_n){}TE <int NUM> IN DynamicMods<NUM>::DynamicMods(DynamicMods<NUM>&& n)NE:m_n(MO(n.m_n)){}TE <int NUM> TE <TY T> IN DynamicMods<NUM>::DynamicMods(T n)NE:m_n(RS(uint(MO(n)),COants::g_M)){ST_AS(is_COructible_v<uint,decay_t<T> >);}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP=(DynamicMods<NUM> n)NE{m_n = MO(n.m_n);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP+=(CO DynamicMods<NUM>& n)NE{(m_n += n.m_n)< COants::g_M?m_n:m_n -= COants::g_M;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP-=(CO DynamicMods<NUM>& n)NE{m_n < n.m_n?(m_n += COants::g_M)-= n.m_n:m_n -= n.m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP*=(CO DynamicMods<NUM>& n)NE{m_n = RS(MO(ull(m_n)* n.m_n),COants::g_M);RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP/=(DynamicMods<NUM> n){RE OP*=(n.Invert());}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::OP<<=(INT n){AS(n >= 0);RE *TH *= DynamicMods<NUM>(2).NonNegativePW(MO(n));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::OP>>=(INT n){AS(n >= 0);WH(n-- > 0){((m_n & 1)== 0?m_n:m_n += COants::g_M)>>= 1;}RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP++()NE{m_n < COants::g_M_minus?++m_n:m_n = 0;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP++(int)NE{DynamicMods<NUM> n{*TH};OP++();RE n;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::OP--()NE{m_n == 0?m_n = COants::g_M_minus:--m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP--(int)NE{DynamicMods<NUM> n{*TH};OP--();RE n;}DF_OF_CM_FOR_DYNAMIC_MOD(==);DF_OF_CM_FOR_DYNAMIC_MOD(!=);DF_OF_CM_FOR_DYNAMIC_MOD(>);DF_OF_CM_FOR_DYNAMIC_MOD(>=);DF_OF_CM_FOR_DYNAMIC_MOD(<);DF_OF_CM_FOR_DYNAMIC_MOD(<=);DF_OF_AR_FOR_DYNAMIC_MOD(+,NE,n,+);DF_OF_AR_FOR_DYNAMIC_MOD(-,NE,n.SignInvert(),+);DF_OF_AR_FOR_DYNAMIC_MOD(*,NE,n,*);DF_OF_AR_FOR_DYNAMIC_MOD(/,,n.Invert(),*);TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP^(INT EX)CO{RE MO(DynamicMods<NUM>(*TH).PW(MO(EX)));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP<<(INT n)CO{RE MO(DynamicMods<NUM>(*TH)<<= MO(n));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM> DynamicMods<NUM>::OP>>(INT n)CO{RE MO(DynamicMods<NUM>(*TH)>>= MO(n));}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::OP-()CO NE{RE MO(DynamicMods<NUM>(*TH).SignInvert());}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::SignInvert()NE{m_n > 0?m_n = COants::g_M - m_n:m_n;RE *TH;}TE <int NUM> IN DynamicMods<NUM>& DynamicMods<NUM>::Invert(){RE m_n <(COants::g_M_is_prime?1e6:3e4)?*TH = Inverse(m_n):NonNegativePW(COants::g_order_minus_1);}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::PositivePW(INT EX)NE{DynamicMods<NUM> PW{*TH};EX--;WH(EX != 0){(EX & 1)== 1?*TH *= PW:*TH;EX >>= 1;PW *= PW;}RE *TH;}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::NonNegativePW(INT EX)NE{RE EX == 0?(m_n = 1,*TH):PositivePW(MO(EX));}TE <int NUM> TE <TY INT> IN DynamicMods<NUM>& DynamicMods<NUM>::PW(INT EX){bool neg = EX < 0;RE neg?PositivePW(ll(MO(EX %= COants::g_order))* COants::g_order_minus_1_neg % COants::g_order):NonNegativePW(MO(EX));}TE <int NUM> IN VO DynamicMods<NUM>::swap(DynamicMods<NUM>& n)NE{std::swap(m_n,n.m_n);}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Inverse(CRUI n){ST VE<DynamicMods<NUM>> memory ={zero(),one()};ST uint LE_curr = 2;AS(COants::g_M == 1||(0 < n && n < COants::g_M));WH(LE_curr <= n){memory.push_back(COants::g_M_is_prime?DeRP(COants::g_M - memory[COants::g_M % LE_curr].m_n * ull(COants::g_M / LE_curr)% COants::g_M):DeRP(n).NonNegativePW(COants::g_order_minus_1));LE_curr++;}RE memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::Factorial(CRUI n){ST VE<DynamicMods<NUM>> memory ={one(),one()};ST uint LE_curr = 2;if(COants::g_M <= n){RE zero();}WH(LE_curr <= n && memory.back().m_n != 0){memory.push_back(memory.back()* DeRP(LE_curr));LE_curr++;}RE LE_curr <= n?memory.back():memory[n];}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::FactorialInverse(CRUI n){ST VE<DynamicMods<NUM>> memory ={one(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory.push_back(memory[LE_curr - 1]* Inverse(LE_curr));LE_curr++;}RE memory[n];}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::Combination(CRUI n,CRUI i){RE i <= n?Factorial(n)* FactorialInverse(i)* FactorialInverse(n - i):zero();}TE <int NUM> IN CRUI DynamicMods<NUM>::RP()CO NE{RE m_n;}TE <int NUM> IN DynamicMods<NUM> DynamicMods<NUM>::DeRP(uint n)NE{DynamicMods<NUM> n_copy{};n_copy.m_n = MO(n);RE n_copy;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::zero()NE{ST CO DynamicMods<NUM> z{};RE z;}TE <int NUM> IN CO DynamicMods<NUM>& DynamicMods<NUM>::one()NE{ST CO DynamicMods<NUM> o{1};RE o;}TE <int NUM> IN CRUI DynamicMods<NUM>::GetModulo()NE{RE COants::g_M;}TE <int NUM> IN VO DynamicMods<NUM>::SetModulo(CRUI M,CRI order_minus_1)NE{COants::g_M = M;COants::g_M_minus = M - 1;COants::g_order = order_minus_1 == -1?M - 1:order_minus_1+1;COants::g_order_minus_1 = COants::g_order-1;COants::g_order_minus_1_neg = -COants::g_order_minus_1;COants::g_M_is_prime = order_minus_1 == -1;}TE <int NUM> IN DynamicMods<NUM> Inverse(CO DynamicMods<NUM>& n){RE MO(DynamicMods<NUM>(n).Invert());}TE <int NUM,TY INT> IN DynamicMods<NUM> PW(DynamicMods<NUM> n,INT EX){RE MO(n.PW(MO(EX)));}TE <int NUM> IN VO swap(DynamicMods<NUM>& n0,DynamicMods<NUM>& n1)NE{n0.swap(n1);}TE <int NUM> IN string to_string(CO DynamicMods<NUM>& n)NE{RE to_string(n.RP())+ " + " + to_string(DynamicMods<NUM>::GetModulo())+ "Z";}TE <int NUM,CL Traits> IN IS& OP>>(IS& is,DynamicMods<NUM>& n){ll m;is >> m;n = m;RE is;}TE <int NUM,CL Traits> IN OS& OP<<(OS& os,CO DynamicMods<NUM>& n){RE os << n.RP();}
TE <int NUM> DC_OF_HASH( DynamicMods<NUM> );TE <int NUM> DF_OF_HASH_FOR_MOD( DynamicMods<NUM> );

TE <TY INT1,TY INT2>INT1 GCD(CO INT1& b_0,CO INT2& b_1){INT1 a_0 = b_0 < 0?-b_0:b_0;INT1 a_1 = b_1 < 0?-b_1:b_1;WH(a_1 != 0){swap(a_0 %= a_1,a_1);}RE a_0;}TE <TY INT1,TY INT2> IN INT1 LCM(CO INT1& b_0,CO INT2& b_1){RE(b_0 == 0 && b_1 == 0)?0:(b_0 / GCD(b_0,b_1))* b_1;}
#endif
