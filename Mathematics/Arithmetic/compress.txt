TE <TY INT1,TY INT2> IN INT1& RS(INT1& n,CO INT2& M)NE{RE n >= 0?n %= M:((((++n) *= -1) %= M) *= -1) += M - 1;}TE <TY INT1,TY INT2> IN CE INT1 RS(INT1&& n,CO INT2& M)NE{RE MO(n >= 0?n %= M:((((++n) *= -1) %= M) *= -1) += M - 1);}TE <TY INT1,TY INT2> IN CE INT1 RS(CO INT1& n,CO INT2& M)NE{RE RS(MO(INT1(n)),M);}TE <TY INT1,TY INT2> IN CE INT1 RS_CE(CO INT1& n,CO INT2& M)NE{RE n >= 0?n % M:M - 1 - ((- (n - 1)) % M);}

#define SFINAE_FOR_MOD(DEFAULT) TY T,enable_if_t<is_COructible<uint,decay_t<T> >::value>* DEFAULT
#define DC_OF_CM_FOR_MOD(FUNC) IN bool OP FUNC(CO Mod<M>& n) CO NE
#define DC_OF_AR_FOR_MOD(FUNC,FUNC_CE) IN Mod<M> OP FUNC(CO Mod<M>& n) CO NE;TE <SFINAE_FOR_MOD(= nullptr)> IN Mod<M> OP FUNC(T&& n) CO NE;IN CE Mod<M> FUNC_CE ## _CE(CO Mod<M>& n)NE
#define DF_OF_CM_FOR_MOD(FUNC) TE <uint M> IN bool Mod<M>::OP FUNC(CO Mod<M>& n) CO NE{RE m_n FUNC n.m_n;}
#define DF_OF_AR_FOR_MOD(FUNC,FORMULA,FUNC_CE,FORMULA_CE) TE <uint M> IN Mod<M> Mod<M>::OP FUNC(CO Mod<M>& n) CO NE{RE MO(Mod<M>(*TH) FUNC ## = n);}TE <uint M> TE <SFINAE_FOR_MOD()> IN Mod<M> Mod<M>::OP FUNC(T&& n) CO NE{RE FORMULA;}TE <uint M> IN CE Mod<M> Mod<M>::FUNC_CE ## _CE(CO Mod<M>& n)NE{RE DeRP(FORMULA_CE);}TE <uint M,SFINAE_FOR_MOD(= nullptr)> IN Mod<M> OP FUNC(T&& n0,CO Mod<M>& n1)NE{RE MO(Mod<M>(forward<T>(n0)) FUNC ## = n1);}

US ull = unsigned long long;TE <uint M>CL Mod{PU:uint m_n;PU:IN CE Mod()NE;IN CE Mod(CO Mod<M>& n)NE;IN CE Mod(Mod<M>& n)NE;IN CE Mod(Mod<M>&& n)NE;TE <SFINAE_FOR_MOD(= nullptr)> IN CE Mod(T& n)NE;TE <SFINAE_FOR_MOD(= nullptr)> IN CE Mod(T&& n)NE;IN CE Mod<M>& OP=(CO Mod<M>& n)NE;IN CE Mod<M>& OP+=(CO Mod<M>& n)NE;IN CE Mod<M>& OP-=(CO Mod<M>& n)NE;IN CE Mod<M>& OP*=(CO Mod<M>& n)NE;IN Mod<M>& OP/=(CO Mod<M>& n);IN CE Mod<M>& OP++()NE;IN CE Mod<M> OP++(int)NE;IN CE Mod<M>& OP--()NE;IN CE Mod<M> OP--(int)NE;DC_OF_CM_FOR_MOD(==);DC_OF_CM_FOR_MOD(!=);DC_OF_CM_FOR_MOD(<);DC_OF_CM_FOR_MOD(<=);DC_OF_CM_FOR_MOD(>);DC_OF_CM_FOR_MOD(>=);DC_OF_AR_FOR_MOD(+,Add);DC_OF_AR_FOR_MOD(-,Substract);DC_OF_AR_FOR_MOD(*,Multiply);DC_OF_AR_FOR_MOD(/,Devide);IN CE Mod<M> OP-() CO NE;IN CE Mod<M>& SignInvert()NE;IN Mod<M>& Invert();TE <TY T> IN CE Mod<M>& PositivePW(T&& EX)NE;TE <TY T> IN CE Mod<M>& PW(T&& EX);TE <TY T> IN CE Mod<M> NonNegativePW_CE(CO Mod<M>& repetitive_square,T&& EX)NE;IN CE CO uint& RP() CO NE;IN CE VO swap(Mod<M>& n)NE;ST IN CO Mod<M>& Inverse(CO uint& n)NE;ST IN CO Mod<M>& Factorial(CO uint& n)NE;ST IN CO Mod<M>& FactorialInverse(CO uint& n)NE;ST IN CO Mod<M>& zero()NE;ST IN CO Mod<M>& one()NE;ST IN CE Mod<M> DeRP(CO uint& n)NE;PU:ST IN CE uint MNForm(CO uint& n)NE;ST IN CE ull& MNReduction(ull& n)NE;ST IN CE uint MNMU(CO uint& n0,CO uint& n1)NE;ST IN CE uint& Normalise(uint& n)NE;TE <TY T> IN CE Mod<M>& Ref(T&& n)NE;};TE <uint M>CL COantsForMod{PU:ST IN CE int BinaryDigitUpperBound()NE;ST IN CE ull MNBasePW(ull&& EX)NE;ST CE uint g_M_minus = M - 1;ST CE uint g_M_minus_2 = M - 2;ST CE uint g_M_minus_2_neg = 2 - M;ST CE CO int g_MN_digit = BinaryDigitUpperBound();ST CE CO ull g_MN_base = ull(1) << g_MN_digit;ST CE CO uint g_MN_base_minus = uint(g_MN_base - 1);ST CE CO uint g_MN_M_neg_inverse = uint((g_MN_base - MNBasePW((ull(1) << (g_MN_digit - 1)) - 1)) & g_MN_base_minus);ST CE CO uint g_MN_base_square = uint((((g_MN_base % M) * (g_MN_base % M)) % M) & g_MN_base_minus);ST CE CO uint g_memory_bound = 1000000;ST CE CO uint g_memory_LE = M < g_memory_bound?M:g_memory_bound;};TE <TY T> IN CE T Square(CO T& t);


TE <uint M> IN CE int COantsForMod<M>::BinaryDigitUpperBound()NE{int AN = 0;uint PW = 1;WH(M > PW){AN++;PW <<= 1;}assert(AN < 32);RE AN;}TE <uint M> IN CE ull COantsForMod<M>::MNBasePW(ull&& EX)NE{ull prod = 1;ull PW = M;WH(EX != 0){(EX & 1) == 1?(prod *= PW) &= g_MN_base_minus:prod;EX >>= 1;(PW *= PW) &= g_MN_base_minus;}RE prod;}TE <uint M> IN CE uint Mod<M>::MNForm(CO uint& n)NE{ull n_copy = n;RE uint(MO(MNReduction(n_copy *= COantsForMod<M>::g_MN_base_square)));}TE <uint M> IN CE ull& Mod<M>::MNReduction(ull& n)NE{ull n_sub = n & COantsForMod<M>::g_MN_base_minus;RE ((n += ((n_sub *= COantsForMod<M>::g_MN_M_neg_inverse) &= COantsForMod<M>::g_MN_base_minus) *= M) >>= COantsForMod<M>::g_MN_digit) < M?n:n -= M;}TE <uint M> IN CE uint Mod<M>::MNMU(CO uint& n0,CO uint& n1)NE{ull n0_copy = n0;RE uint(MO(MNReduction(MNReduction(n0_copy *= n1) *= COantsForMod<M>::g_MN_base_square)));}TE <uint M> IN CE uint& Mod<M>::Normalise(uint& n)NE{RE n >= M?n -= M:n;}TE <uint M> TE <TY T> IN CE Mod<M>& Mod<M>::Ref(T&& n)NE{RE *TH;}TE <uint M> IN CE Mod<M>::Mod()NE:m_n(){}TE <uint M> IN CE Mod<M>::Mod(CO Mod<M>& n)NE:m_n(n.m_n){}TE <uint M> IN CE Mod<M>::Mod(Mod<M>& n)NE:m_n(n.m_n){}TE <uint M> IN CE Mod<M>::Mod(Mod<M>&& n)NE:m_n(MO(n.m_n)){}TE <uint M> TE <SFINAE_FOR_MOD()> IN CE Mod<M>::Mod(T& n)NE:m_n(RS(decay_t<T>(n),M)){}TE <uint M> TE <SFINAE_FOR_MOD()> IN CE Mod<M>::Mod(T&& n)NE:m_n(RS(forward<T>(n),M)){}TE <uint M> IN CE Mod<M>& Mod<M>::OP=(CO Mod<M>& n)NE{RE Ref(m_n = n.m_n);}TE <uint M> IN CE Mod<M>& Mod<M>::OP+=(CO Mod<M>& n)NE{RE Ref(Normalise(m_n += n.m_n));}TE <uint M> IN CE Mod<M>& Mod<M>::OP-=(CO Mod<M>& n)NE{RE Ref(Normalise(m_n += M - n.m_n));}TE <uint M> IN CE Mod<M>& Mod<M>::OP*=(CO Mod<M>& n)NE{RE Ref(m_n = MNMU(m_n,n.m_n));}TE <uint M> IN Mod<M>& Mod<M>::OP/=(CO Mod<M>& n){RE OP*=(Mod<M>(n).Invert());}TE <uint M> IN CE Mod<M>& Mod<M>::OP++()NE{RE Ref(m_n < COantsForMod<M>::g_M_minus?++m_n:m_n = 0);}TE <uint M> IN CE Mod<M> Mod<M>::OP++(int)NE{Mod<M> n{*TH};OP++();RE n;}TE <uint M> IN CE Mod<M>& Mod<M>::OP--()NE{RE Ref(m_n == 0?m_n = COantsForMod<M>::g_M_minus:--m_n);}TE <uint M> IN CE Mod<M> Mod<M>::OP--(int)NE{Mod<M> n{*TH};OP--();RE n;}DF_OF_CM_FOR_MOD(==);DF_OF_CM_FOR_MOD(!=);DF_OF_CM_FOR_MOD(>);DF_OF_CM_FOR_MOD(>=);DF_OF_CM_FOR_MOD(<);DF_OF_CM_FOR_MOD(<=);DF_OF_AR_FOR_MOD(+,Mod<M>(forward<T>(n)) += *TH,Add,uint(RS_CE(ull(m_n) + n.m_n,M)));DF_OF_AR_FOR_MOD(-,Mod<M>(forward<T>(n)).SignInvert() += *TH,Substract,uint(RS_CE(ull(m_n) + (M - n.m_n),M)));DF_OF_AR_FOR_MOD(*,Mod<M>(forward<T>(n)) *= *TH,Multiply,uint(RS_CE(ull(m_n) * n.m_n,M)));DF_OF_AR_FOR_MOD(/,Mod<M>(forward<T>(n)).Invert() *= *TH,Devide,Multiply_CE(Inverse_CE(n)).m_n);TE <uint M> IN CE Mod<M> Mod<M>::OP-() CO NE{RE MO(Mod<M>(*TH).SignInvert());}TE <uint M> IN CE Mod<M>& Mod<M>::SignInvert()NE{RE Ref(m_n > 0?m_n = M - m_n:m_n);}TE <uint M> IN Mod<M>& Mod<M>::Invert(){assert(m_n > 0);uint m_n_neg;RE m_n < COantsForMod<M>::g_memory_LE?Ref(m_n = Inverse(m_n).m_n):(m_n_neg = M - m_n < COantsForMod<M>::g_memory_LE)?Ref(m_n = M - Inverse(m_n_neg).m_n):PositivePW(uint(COantsForMod<M>::g_M_minus_2));}TE <> IN Mod<2>& Mod<2>::Invert(){assert(m_n == 0);RE *TH;}TE <uint M> TE <TY T> IN CE Mod<M>& Mod<M>::PositivePW(T&& EX)NE{ull prod = COantsForMod<M>::g_MN_base;ull PW = MNForm(m_n);WH(EX != 0){(EX & 1) == 1?MNReduction(prod *= PW):prod;EX >>= 1;MNReduction(PW *= PW);}RE Ref(m_n = uint(MO(MNReduction(prod))));}TE <> TE <TY T> IN CE Mod<2>& Mod<2>::PositivePW(T&& EX)NE{RE *TH;}TE <uint M> TE <TY T> IN CE Mod<M>& Mod<M>::PW(T&& EX){bool neg = EX < 0;assert(!(neg && m_n == 0));neg?EX *= COantsForMod<M>::g_M_minus_2_neg:EX;RE m_n == 0?*TH:(EX %= COantsForMod<M>::g_M_minus) == 0?Ref(m_n = 1):PositivePW(forward<T>(EX));}TE <uint M> TE <TY T> IN CE Mod<M> Mod<M>::NonNegativePW_CE(CO Mod<M>& repetitive_square,T&& EX)NE{Mod<M> repetitive_square_next{Multiply_CE(repetitive_square,repetitive_square)};Mod<M> one_CE{DeRP(1)};RE MO(EX == 0?one_CE:Multiply_CE(MO((EX & 1) == 1?repetitive_square:one_CE),NonNegativePW_CE(repetitive_square_next,EX >> 1)));}TE <uint M> IN CO Mod<M>& Mod<M>::Inverse(CO uint& n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={zero(),one()};ST uint LE_curr = 2;WH(LE_curr <= n){memory[LE_curr].m_n = M - MNMU(memory[M % LE_curr].m_n,M / LE_curr);LE_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::Factorial(CO uint& n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;ST ull val_curr = COantsForMod<M>::g_MN_base;ull val_copy;WH(LE_curr <= n){memory[LE_curr].m_n = uint(MO(MNReduction(val_copy = MNReduction(val_curr *= MNForm(LE_curr)))));LE_curr++;}RE memory[n];}TE <uint M> IN CO Mod<M>& Mod<M>::FactorialInverse(CO uint& n)NE{ST Mod<M> memory[COantsForMod<M>::g_memory_LE] ={one(),one()};ST uint LE_curr = 2;ST ull val_curr = COantsForMod<M>::g_MN_base;ull val_copy;WH(LE_curr <= n){memory[LE_curr].m_n = uint(MO(MNReduction(val_copy = MNReduction(val_curr *= MNForm(Inverse(LE_curr).m_n)))));LE_curr++;}RE memory[n];}TE <uint M> IN CE CO uint& Mod<M>::RP() CO NE{RE m_n;}TE <uint M> IN CE VO Mod<M>::swap(Mod<M>& n)NE{std::swap(m_n,n.m_n);}TE <uint M> IN CO Mod<M>& Mod<M>::zero()NE{ST CE CO Mod<M> z{};RE z;}TE <uint M> IN CO Mod<M>& Mod<M>::one()NE{ST CE CO Mod<M> o{DeRP(1)};RE o;}TE <uint M> IN CE Mod<M> Mod<M>::DeRP(CO uint& n)NE{Mod<M> n_copy{};n_copy.m_n = n;RE n_copy;}TE <uint M> IN Mod<M> Inverse(CO Mod<M>& n){RE MO(Mod<M>(n).Invert());}TE <uint M> IN CE Mod<M> Inverse_COrexpr(CO uint& n)NE{RE Mod<M>::NonNegativePW_CE(Mod<M>::DeRP(RS_CE(n,M)),M - 2);}TE <uint M,TY T> IN CE Mod<M> PW(CO Mod<M>& n,CO T& EX){RE MO(Mod<M>(n).PW(T(EX)));}TE <TY T> IN CE Mod<2> PW(CO Mod<2>& n,CO T& EX){RE EX == 0?Mod<2>::DeRP(1):n;}TE <> IN CE Mod<2> Square<Mod<2> >(CO Mod<2>& t){RE t;}TE <uint M> IN CE VO swap(Mod<M>& n0,Mod<M>& n1)NE{n0.swap(n1);}TE <uint M> IN string to_string(CO Mod<M>& n)NE{RE to_string(n.RP()) + " + MZ";}TE<uint M,CL Traits> IN basic_ostream<char,Traits>& OP<<(basic_ostream<char,Traits>& os,CO Mod<M>& n){RE os << n.RP();}
