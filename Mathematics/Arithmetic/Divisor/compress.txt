#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Divisor/a_Body.hpp"
#else
// nの素因数分解：PrimeFactorisation(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,CO INT2& n)
// nの約数数え上げ：CountDivisor(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT n)
// nの約数辞書順列挙１：EnumerateDivisor(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT n)
// nの約数辞書順列挙２：EnumerateDivisor(CO LeastDivisor<INT,val_limit>& ld,INT n)
// SZ_max未満の数の約数全列挙：TotalEnumerateDivisor(CRI SZ)

TE <TY INT,INT val_limit,int LE_max = val_limit>CL PrimeEnumeration{PU:bool m_is_composite[val_limit];INT m_val[LE_max];int m_LE;CE PrimeEnumeration();IN CO INT& OP[](CRI i)CO;CE CO INT& Get(CRI i)CO;CE CO bool& IsComposite(CRI n)CO;CE CRI LE()CO NE;};
TE <TY INT,INT val_limit,int LE_max> CE PrimeEnumeration<INT,val_limit,LE_max>::PrimeEnumeration():m_is_composite(),m_val(),m_LE(0){for(INT i = 2;i < val_limit;i++){if(! m_is_composite[i]){if(i <=(val_limit - 1)/ i){for(INT j = i * i;j < val_limit;j += i){m_is_composite[j]= true;}}m_val[m_LE++]= i;if(m_LE >= LE_max){break;}}}}TE <TY INT,INT val_limit,int LE_max> IN CO INT& PrimeEnumeration<INT,val_limit,LE_max>::OP[](CRI i)CO{AS(0 <= i && i < m_LE);RE m_val[i];}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::Get(CRI i)CO{RE m_val[i];}TE <TY INT,INT val_limit,int LE_max> CE CO bool& PrimeEnumeration<INT,val_limit,LE_max>::IsComposite(CRI n)CO{RE m_is_composite[n];}TE <TY INT,INT val_limit,int LE_max> CE CRI PrimeEnumeration<INT,val_limit,LE_max>::LE()CO NE{RE m_LE;}

TE <TY INT1,INT1 val_limit,int LE_max,TY INT2>pair<VE<INT1>,VE<int>> PrimeFactorisation(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT2 n){VE<INT1> P{};VE<int> E{};CRI LE = pe.LE();for(int i = 0;i < LE;i++){CO INT1& p = pe[i];if(n % p == 0){int e = 1;WH((n /= p)% p == 0){e++;}P.push_back(p);E.push_back(e);}else if(n / p < p){break;}}if(n != 1){P.push_back(n);E.push_back(1);}RE{MO(P),MO(E)};}

TE <TY INT,INT val_limit>CL LeastDivisor{PU:INT m_val[val_limit];CE LeastDivisor()NE;IN CO INT& OP[](CRI i)CO;CE CO INT& Get(CRI i)CO;};
TE <TY INT,INT val_limit> CE LeastDivisor<INT,val_limit>::LeastDivisor()NE:m_val{}{for(int d = 2;d < val_limit;d++){if(m_val[d]== 0){for(int n = d;n < val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}TE <TY INT,INT val_limit> IN CO INT& LeastDivisor<INT,val_limit>::OP[](CRI i)CO{AS(0 <= i && i < val_limit);RE m_val[i];}TE <TY INT,INT val_limit> CE CO INT& LeastDivisor<INT,val_limit>::Get(CRI i)CO{RE m_val[i];}

TE <TY INT> INT CountDivisorBody(VE<int>& E)NE{CO int LE = E.SZ();INT AN = 1;for(int i = 0;i < LE;i++){AN *= ++E[i];}RE AN;}TE <TY INT>INT CountDivisor(INT n)NE{auto[P,E]= PrimeFactorisation(MO(n));RE CountDivisorBody<INT>(E);}TE <TY INT,TY PE>INT CountDivisor(CO PE& pe,INT n)NE{auto[P,E]= PrimeFactorisation(pe,MO(n));RE CountDivisorBody<INT>(E);}TE <TY INT> VE<INT> EnumerateDivisorBody(CO VE<INT>& P,VE<int>& E){CO int LE = P.SZ();VE AN(CountDivisorBody<INT>(E),1);int SZ = 1;for(int i = 0;i < LE;i++){auto& P_i = P[i];auto& E_i = E[i];INT q = 1;int j_shift = 0;for(int e = 1;e < E_i;e++){q *= P_i;j_shift += SZ;for(int j = 0;j < SZ;j++){AN[j + j_shift]= AN[j]* q;}}SZ *= E_i;}RE AN;}TE <TY INT>VE<INT> EnumerateDivisor(INT n)NE{auto[P,E]= PrimeFactorisation(MO(n));RE EnumerateDivisorBody(P,E);}TE <TY INT1,INT1 val_limit,int LE_max,TY INT2>VE<INT2> EnumerateDivisor(CO PrimeEnumeration<INT1,val_limit,LE_max>& pe,INT2 n){auto[P,E]= PrimeFactorisation(pe,MO(n));RE EnumerateDivisorBody(P,E);}TE <TY INT1,INT1 val_limit,TY INT2>VE<INT2> EnumerateDivisor(CO LeastDivisor<INT1,val_limit>& ld,INT2 n){VE<INT2> P{};VE<int> E{};WH(n > 1){auto& p = ld[n];int e = 1;WH((n /= p)% p == 0){e++;}P.push_back(p);E.push_back(e);}RE EnumerateDivisorBody(P,E);}TE <TY INT>VE<VE<INT>> TotalEnumerateDivisor(CO INT& SZ)NE{VE<VE<INT>> AN(SZ);for(INT d = 1;d < SZ;d++){for(INT n = 0;n < SZ;n += d){AN[n].push_back(d);}}RE AN;}
#endif
