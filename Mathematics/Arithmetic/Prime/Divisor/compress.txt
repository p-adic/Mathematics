#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Arithmetic/Prime/Divisor/a_Body.hpp"
#else
// nの素因数分解：SetPrimeFactorisation(CO PE& prime,CO INT& n,VE<INT>& P,VE<INT>& EX)
// nの約数数え上げ：CountDivisor(CO PE& pe,INT n)
// SZ未満の数の最小素因数計算：GetLeastDivisor(CRI SZ)
// nの約数列挙１：EnumerateDivisor(CO PE& pe,INT n)
// nの約数列挙２：EnumerateDivisor(CO VE<INT1>& least_divisor,INT2 n)
// SZ_max未満の数の約数全列挙：TotalEnumerateDivisor(CRI SZ)
// nのメビウス関数MoeviusFunction(CO PE& pe,INT n)

TE <TY INT,INT val_limit,int LE_max = val_limit>CL PrimeEnumeration{PU:bool m_is_composite[val_limit];INT m_val[LE_max];int m_LE;CE PrimeEnumeration();CE CO INT& OP[](CRI n) CO;CE CO INT& Get(CRI n) CO;CE CO bool& IsComposite(CRI i) CO;CE CRI LE() CO NE;};
TE <TY INT,INT val_limit,int LE_max>CE PrimeEnumeration<INT,val_limit,LE_max>::PrimeEnumeration():m_is_composite(),m_val(),m_LE(0){for(INT i = 2;i < val_limit;i++){if(! m_is_composite[i]){for(INT j = i * i;j < val_limit;j +=i){m_is_composite[j] = true;}m_val[m_LE++] = i;if(m_LE >= LE_max){break;}}}}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::OP[](CRI n)CO{assert(n < m_LE);RE m_val[n];}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::Get(CRI n)CO{RE OP[](n);}TE <TY INT,INT val_limit,int LE_max> CE CO bool& PrimeEnumeration<INT,val_limit,LE_max>::IsComposite(CRI i)CO{assert(i < val_limit);RE m_is_composite[i];}TE <TY INT,INT val_limit,int LE_max> CE CRI PrimeEnumeration<INT,val_limit,LE_max>::LE()CO NE{RE m_LE;}

TE <TY INT,INT val_limit,int LE_max,TY INT1,TY INT2,TY INT3>VO SetPrimeFactorisation(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT1 n,VE<INT2>& P,VE<INT3>& EX){int i = 0;WH(i < prime.m_LE){CO INT2& p = prime[i];if(p * p > n){break;}if(n % p == 0){P.push_back(p);EX.push_back(1);INT3& EX_back = EX.back();n /= p;WH(n % p == 0){EX_back++;n /= p;}}i++;}if(n != 1){P.push_back(n);EX.push_back(1);}RE;}

TE <TY INT> INT CountDivisorBody(VE<INT>& EX)NE{CO int LE = EX.SZ();INT AN = 1;for(int i = 0;i < LE;i++){AN *= ++EX[i];}RE AN;}TE <TY INT,TY PE> INT CountDivisor(CO PE& pe,INT n)NE{VE<INT> P{},EX{};SetPrimeFactorisation(pe,n,P,EX);RE CountDivisorBody(EX);}TE <TY INT>VE<INT> GetLeastDivisor(CO INT& SZ)NE{VE<INT> AN(SZ,1);for(int d = 1;d < SZ;d++){if(AN[d]== 1){for(int n = d;n < SZ;n += d){INT& AN_n = AN[n];AN_n == 1?AN_n = d:AN_n;}}}RE AN;}TE <TY INT> VE<INT> EnumerateDivisorBody(CO VE<INT>& P,VE<INT>& EX){CO int LE = P.SZ();VE<INT> AN(CountDivisorBody(EX),1);int SZ = 1;for(int i = 0;i < LE;i++){CO INT& P_i = P[i];CRI EX_i = EX[i];INT PW = 1;int j_shift = 0;for(int e = 1;e < EX_i;e++){PW *= P_i;j_shift += SZ;for(int j = 0;j < SZ;j++){AN[j + j_shift]= AN[j]* PW;}}SZ *= EX_i;}RE AN;}TE <TY INT,TY PE>VE<INT> EnumerateDivisor(CO PE& pe,INT n)NE{VE<INT> P{},EX{};SetPrimeFactorisation(pe,MO(n),P,EX);RE EnumerateDivisorBody(P,EX);}TE <TY INT1,TY INT2>VE<INT2> EnumerateDivisor(CO VE<INT1>& least_divisor,INT2 n){VE<INT> P{},EX{};WH(n > 1){auto& p = least_divisor[n];P.push_back(p);INT e = 1;WH((n /= p)% p == 0){e++;}EX.push_back(e);}RE EnumerateDivisorBody(P,EX);}TE <TY INT>VE<VE<INT>> TotalEnumerateDivisor(CO INT& SZ)NE{VE<VE<INT>> AN(SZ);for(int d = 1;d < SZ;d++){for(int n = 0;n < SZ;n += d){AN[n].push_back(d);}}RE AN;}TE <TY INT,TY PE>int MoeviusFunction(CO PE& pe,INT n)NE{CRI LE = pe.LE();int AN = 1;int i = 0;WH(i < LE && n > 1){CRI p = pe[i++];if(n % p == 0){if((n /= p)% p == 0){RE 0;}AN *= -1;}}RE n == 1?AN:AN *= -1;}
#endif
