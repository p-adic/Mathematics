// nの素因数分解：SetPrimeFactorisation(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,CO INT& n,VE<INT>& P,VE<INT>& EX)
// nの約数数え上げ：CountDivisor(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n)
// nの約数列挙：EnumerateDivisor(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n)
// SZ_max未満の数の約数全列挙：MemoriseEnumerateDivisor(LI<int>(&memory)[SZ_max])
// nのメビウス関数MoeviusFunction(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n)

TE <TY INT,INT val_limit,int LE_max = val_limit>CL PrimeEnumeration{PU:bool m_is_composite[val_limit];INT m_val[LE_max];int m_LE;CE PrimeEnumeration();CE CO INT& OP[](CRI n) CO;CE CO INT& Get(CRI n) CO;CE CO bool& IsComposite(CRI i) CO;CE CRI LE() CO NE;};
TE <TY INT,INT val_limit,int LE_max>CE PrimeEnumeration<INT,val_limit,LE_max>::PrimeEnumeration():m_is_composite(),m_val(),m_LE(0){for(INT i = 2;i < val_limit;i++){if(! m_is_composite[i]){INT j = i;WH((j += i)< val_limit){m_is_composite[j] = true;}m_val[m_LE++] = i;if(m_LE >= LE_max){break;}}}}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::OP[](CRI n)CO{assert(n < m_LE);RE m_val[n];}TE <TY INT,INT val_limit,int LE_max> CE CO INT& PrimeEnumeration<INT,val_limit,LE_max>::Get(CRI n)CO{RE OP[](n);}TE <TY INT,INT val_limit,int LE_max> CE CO bool& PrimeEnumeration<INT,val_limit,LE_max>::IsComposite(CRI i)CO{assert(i < val_limit);RE m_is_composite[i];}TE <TY INT,INT val_limit,int LE_max> CE CRI PrimeEnumeration<INT,val_limit,LE_max>::LE()CO NE{RE m_LE;}
TE <TY INT,INT val_limit,int LE_max,TY INT1,TY INT2,TY INT3>VO SetPrimeFactorisation(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,CO INT1& n,VE<INT2>& P,VE<INT3>& EX){INT1 n_copy = n;int i = 0;WH(i < prime.m_LE){CO INT2& p = prime[i];if(p * p > n_copy){break;}if(n_copy % p == 0){P.push_back(p);EX.push_back(1);INT3& EX_back = EX.back();n_copy /= p;WH(n_copy % p == 0){EX_back++;n_copy /= p;}}i++;}if(n_copy != 1){P.push_back(n_copy);EX.push_back(1);}RE;}
TE <TY INT,INT val_limit,int LE_max>INT CountDivisor(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n) NE{VE<INT> P{};VE<INT> EX{};SetPrimeFactorisation(prime,n,P,EX);P.clear();CO int LE = EX.SZ();INT AN = 1;for(int i = 0;i < LE;i++){AN *= EX[i] + 1;}RE AN;}
TE <TY INT,INT val_limit,int LE_max>LI<INT> EnumerateDivisor(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n) NE{VE<INT> P{};VE<INT> EX{};SetPrimeFactorisation(prime,n,P,EX);CO int LE = P.SZ();LI<INT> divisor{};divisor.push_back(1);auto BE = divisor.BE(),EN = divisor.EN();for(int i = 0;i < LE;i++){CO INT& P_i = P[i];CRI EX_i = EX[i];LI<INT> temp{};INT PW = 1;for(int e = 1;e <= EX_i;e++){PW *= P_i;for(auto IT = BE;IT != EN;IT++){temp.push_back(*IT * PW);}}WH(! temp.empty()){divisor.push_back(temp.front());temp.pop_front();}}RE divisor;}
TE <int SZ_max> VO MemoriseEnumerateDivisor(LI<int>(&memory)[SZ_max])NE{for(int d = 1;d < SZ_max;d++){int n = 0;WH((n += d)< SZ_max){memory[n].push_back(d);}}RE;}
TE <TY INT,INT val_limit,int LE_max>int MoeviusFunction(CO PrimeEnumeration<INT,val_limit,LE_max>& prime,INT n)NE{int AN = 1;int i = 0;WH(i < prime.m_LE && n > 1){CRI p = prime[i++];if(n % p == 0){if((n /= p)% p == 0){RE 0;}AN *= -1;}}RE n == 1?AN:AN *= -1;}
