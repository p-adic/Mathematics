template <typename QUERY_1 , typename QUERY_2>
vector<MP> Answer( const int& N , const int& Q , const vector<T2<int>>& type_num , const QUERY_1& query_1 , const QUERY_2& query_2 )
{
  vector<MP> a{};
  // BIT t{ N };
  // IntervalMultiplyLazySqrtDecomposition t{ MultiplicativeMonoid<ll>( 1 ) , Module<ll,ll>() , N };
  FOR( q , 0 , Q ){
    auto& [type,num] = type_num[q];
    if( type == 1 ){
      auto& [l,r,x] = query_1[num];
      a.push_back( 0 );
    } else if( type == 2 ){
      auto& [l,r] = query_2[num];
      a.push_back( 0 );
    }
  }
  RE a;
}

IN VO Solve()
{
  CIN( int , N );
  CIN( int , Q );
  vector<int> type_num( Q );
  vector<vector<ll>> query_1{};
  vector<vector<ll>> query_2{};
  FOR( q , 0 , Q ){
    CIN( int , type );
    if( type == 1 ){
      CIN( ll , l , r , x ); --l; --r;
      type_num[q] = {type,query_1.size()};
      query_1.push_back( {l,r,x} );
    } else if( type == 2 ){
      CIN( ll , l , r ); --l; --r;
      type_num[q] = {type,query_2.size()};
      query_2.push_back( {l,r} );
    }
  }
  RUN( Answer( N , Q , type_num , query_1 , query_2 ) , a ){
    COUT( a );
  }
  // RETURN( Answer( N , Q , type_num , query_1 , query_2 ) );
}
REPEAT_MAIN(1);
