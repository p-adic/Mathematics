#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/SubSequence/AABSubsequenceCounter/a_Body.hpp"
#else
US AABCount = tuple<VE<int>,VE<VE<ll>>,ll>;TE <int n,int AltB>CL AABSubsequenceCounterOP{PU:ST AABCount Product(AABCount v0,CO AABCount& v1);};TE <int n = 26,int AltB = 0>CL AABSubsequenceCounter:PU AbstractMonoid<AABCount,AABCount(*)(AABCount,CO AABCount&)>{PU:IN AABSubsequenceCounter();};
TE <int n,int AltB>AABCount AABSubsequenceCounterOP<n,AltB>::Product(AABCount v0,CO AABCount& v1){ST_AS(n > 1);auto&[v0A,v0AB,v0AAB]= v0;if(v0A.empty()){RE v1;}auto&[v1A,v1AB,v1AAB]= v1;if(v1A.empty()){RE MO(v1);}if(v0A.SZ()== 1){CO int i = v0A[0];v0A = VE<int>(n);v0A[i]++;v0AB = VE(n,VE<ll>(n));}if(v1A.SZ()== 1){auto& j = v1A[0];for(int i = 0;i < n;i++){CO ll v0Ai = v0A[i];auto& v0ABi = v0AB[i];int j_min = 0,j_ulim = n;if CE(AltB == 1){j_min = i + 1;}else if CE(AltB == -1){j_ulim = i;}if(j_min <= j && j < j_ulim && j != i){v0AAB += v0ABi[i];}v0ABi[j]+= v0Ai;}v0A[j]++;}else{v0AAB += v1AAB;for(int i = 0;i < n;i++){CO ll v0Ai = v0A[i];auto& v0ABi = v0AB[i];auto& v0ABii = v0ABi[i];auto& v1ABi = v1AB[i];int j_min = 0,j_ulim = n;if CE(AltB == 1){j_min = i + 1;}else if CE(AltB == -1){j_ulim = i;}for(int j = j_min;j < i;j++){v0AAB += v0Ai * v1ABi[j]+ v0ABii * v1A[j];}for(int j = i + 1;j < j_ulim;j++){v0AAB += v0Ai * v1ABi[j]+ v0ABii * v1A[j];}for(int j = 0;j < n;j++){v0ABi[j]+= v1ABi[j]+ v0Ai * v1A[j];}v0A[i]+= v1A[i];}}RE MO(v0);}TE <int n,int AltB> IN AABSubsequenceCounter<n,AltB>::AABSubsequenceCounter():AbstractMonoid<AABCount,AABCount(*)(AABCount,CO AABCount&)>(AABSubsequenceCounterOP<n,AltB>::Product,AABCount{}){}TE <int n = 10> IN AABCount ToAABCount(CRI c){RE{{c},{},0};}TE <int n = 26> IN AABCount ToAABCount(CO char& c){RE ToAABCount<n>(CharToInt(c));}TE <int n,int AltB,TE <TY...> TY VEC,TY INT>AABCount ToAABCount(CO VEC<INT>& S){AABSubsequenceCounter<n,AltB> M{};AABCount AN{};for(auto& c:S){AN = M.Product(MO(AN),ToAABCount<n>(c));}RE AN;}
#endif
