#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/WalshHadamardTransform/a_Body.hpp"
#else
TE <TY T,TY INT>tuple<T,T,INT> AffineTraceProduct(CO VE<tuple<T,T,INT>>& f,CO INT& order){CO T m{order};T a{0},b{1};INT c = 0;for(auto&[a_i,b_i,c_i]:f){AS(0 <= c_i && c_i < order);a = a * b_i + a_i * b + a * a_i * m;b *= b_i;(c += c_i)< order?c:c -= order;}RE{MO(a),MO(b),c};}TE <TY T>VE<T> AffineShiftProduct(CO VE<tuple<T,T,int>>& f,CO int digit){AS(0 <= digit && digit < 30);CO int N = 1 << digit;AS(int(f.SZ())<= N);auto[a,b,c]= AffineTraceProduct(f,N);VE<T> AN(N);for(int j = 0;j < N;j++){AN[j]= N * a +((__builtin_popcount(c & j)& 1)== 0?b:-b);}RE AN;}TE <TY T>VE<T> WalshHadamardTransform(VE<T> f,CRI digit){AS(0 <= digit && digit < 30);CO int N = 1 << digit;AS(int(f.SZ())<= N);f.resize(N);for(int d = 0;d < digit;d++){CO int p = 1 << d,q = p << 1;for(int j = 0;j < N;j += q){AS(j <(j | p));for(int i = j;i <(j | p);i++){T temp = f[i];f[i]= temp + f[i|p];f[i|p]= temp - f[i|p];}}}RE MO(f);}TE <TY T>VE<T> InverseWalshHadamardTransform(VE<T> f,CRI digit){f = WalshHadamardTransform(MO(f),digit);CO int N = 1 << digit;CO T scale = T{1}/ N;for(int i = 0;i < N;i++){f[i]*= scale;}RE MO(f);}TE <TY COMM_SEMIGRP,TY T>VE<pair<T,T>> AbstractWalshHadamardTransform(COMM_SEMIGRP M,VE<pair<T,T>> f,CRI digit){ST_AS(is_same_v<inner_t<COMM_SEMIGRP>,T>);AS(0 <= digit && digit < 30);CO int N = 1<<digit;AS(int(f.SZ())<= N);CO T& one = M.One();f.resize(N,{one,one});for(int d = 0;d < digit;d++){CO int p = 1 << d,q = p << 1;for(int j = 0;j < N;j += q){AS(j <(j | p));for(int i = j;i <(j | p);i++){auto[a,b]= f[i];auto&[c,d]= f[i|p];f[i]={M.Product(a,c),M.Product(b,d)};f[i|p]={M.Product(MO(a),d),M.Product(MO(b),c)};;}}}RE MO(f);}TE <TY COMM_SEMIGRP,TY T>VE<pair<T,T>> AbstractTwistedWalshHadamardTransform(COMM_SEMIGRP M,VE<tuple<T,T,int>> f,CRI digit){ST_AS(is_same_v<inner_t<COMM_SEMIGRP>,T>);CO T& one = M.One();CO int N = 1 << digit;VE<pair<T,T>> g(N,{one,one});for(auto&[a,b,c]:f){AS(0 <= c && c < N);auto&[u,v]= g[c];u = M.Product(MO(u),a);v = M.Product(MO(v),b);}RE AbstractWalshHadamardTransform(MO(M),g,digit);}
#endif
