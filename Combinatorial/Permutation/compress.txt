#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/Permutation/a_Body.hpp"
#else
#define SFINAE_FOR_BIT_BS enable_if_t<is_invocable_r_v<bool,F,U,int>>*
TE <TY U,TY ABELIAN_GROUP>CL AbstractBIT{PU:ABELIAN_GROUP m_M;int m_SZ;VE<U> m_fenwick;int m_PW;IN AbstractBIT(ABELIAN_GROUP M,CRI SZ = 0);IN AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a);TE <TY...Args> IN VO Initialise(CO Args&... args);IN VO Set(CRI i,CO U& u);VO Add(CRI i,CO U& u);IN CRI SZ()CO NE;IN U OP[](CRI i);IN U Get(CRI i);IN CO U& LSBSegmentSum(CRI j)CO;U InitialSegmentSum(CRI i_final);IN U IntervalSum(CRI i_start,CRI i_final);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> int Search(CO F& f);TE <TY F,SFINAE_FOR_BIT_BS = nullptr> IN int Search(CRI i_start,CO F& f);IN int Search(CO U& u);IN int Search(CRI i_start,CO U& u);IN VO COruct();};TE <TY ABELIAN_GROUP,TY...Args> AbstractBIT(ABELIAN_GROUP M,CO Args&... args)-> AbstractBIT<inner_t<ABELIAN_GROUP>,ABELIAN_GROUP>;TE <TY U = ll>CL BIT:PU AbstractBIT<U,AdditiveGroup<U>>{PU:TE <TY...Args> IN BIT(CO Args&... args);};TE <TY U> BIT(CO VE<U>& a)-> BIT<U>;
TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CRI SZ):m_M(MO(M)),m_SZ(SZ),m_fenwick(m_SZ + 1,m_M.Zero()),m_pw(1){COruct();}TE <TY U,TY ABELIAN_GROUP> IN AbstractBIT<U,ABELIAN_GROUP>::AbstractBIT(ABELIAN_GROUP M,CO VE<U>& a):m_M(MO(M)),m_SZ(a.SZ()),m_fenwick(m_SZ + 1,m_M.Zero()),m_pw(1){COruct();for(int j = 1;j <= m_SZ;j++){int i = j - 1,i_lim = j -(j & -j);U& fenwick_j = m_fenwick[j]= a[i];WH(i > i_lim){fenwick_j = m_M.Sum(MO(fenwick_j),m_fenwick[i]);i -=(i & -i);}}}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::COruct(){ST_AS(is_same_v<U,inner_t<ABELIAN_GROUP>>);WH(m_pw < m_SZ){m_pw <<= 1;}}TE <TY U> TE <TY...Args> IN BIT<U>::BIT(CO Args&... args):AbstractBIT<U,AdditiveGroup<U>>(AdditiveGroup<U>(),args...){}TE <TY U,TY ABELIAN_GROUP> TE <TY...Args> IN VO AbstractBIT<U,ABELIAN_GROUP>::Initialise(CO Args&... args){AbstractBIT<U,ABELIAN_GROUP> temp{m_M,args...};m_SZ = temp.m_SZ;m_fenwick = MO(temp.m_fenwick);m_pw = temp.m_pw;}TE <TY U,TY ABELIAN_GROUP> IN VO AbstractBIT<U,ABELIAN_GROUP>::Set(CRI i,CO U& u){Add(i,m_M.Sum(m_M.Inverse(IntervalSum(i,i)),u));}TE <TY U,TY ABELIAN_GROUP>VO AbstractBIT<U,ABELIAN_GROUP>::Add(CRI i,CO U& u){if(i < 0){RE;}int j = i + 1;WH(j <= m_SZ){U& fenwick_j = m_fenwick[j];fenwick_j = m_M.Sum(MO(fenwick_j),u);j +=(j & -j);}RE;}TE <TY U,TY ABELIAN_GROUP> IN CRI AbstractBIT<U,ABELIAN_GROUP>::SZ()CO NE{RE m_SZ;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::OP[](CRI i){AS(0 <= i && i < m_SZ);RE IntervalSum(i,i);}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::Get(CRI i){RE OP[](i);}TE <TY U,TY ABELIAN_GROUP> IN CO U& AbstractBIT<U,ABELIAN_GROUP>::LSBSegmentSum(CRI j)CO{AS(0 < j && j <= m_SZ);RE m_fenwick[j];}TE <TY U,TY ABELIAN_GROUP>U AbstractBIT<U,ABELIAN_GROUP>::InitialSegmentSum(CRI i_final){U sum = m_M.Zero();int j = min(i_final + 1,m_SZ);WH(j > 0){sum = m_M.Sum(MO(sum),m_fenwick[j]);j -= j & -j;}RE sum;}TE <TY U,TY ABELIAN_GROUP> IN U AbstractBIT<U,ABELIAN_GROUP>::IntervalSum(CRI i_start,CRI i_final){RE m_M.Sum(m_M.Inverse(InitialSegmentSum(i_start - 1)),InitialSegmentSum(i_final));}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS>int AbstractBIT<U,ABELIAN_GROUP>::Search(CO F& f){int j = 0;int pw = m_pw;U sum = m_M.Zero();U sum_next = sum;WH(pw > 0){int j_next = j | pw;if(j_next <= m_SZ){sum_next = m_M.Sum(MO(sum_next),m_fenwick[j_next]);if(f(sum_next,j_next - 1)){sum_next = sum;}else{sum = sum_next;j = j_next;}}pw >>= 1;}RE j;}TE <TY U,TY ABELIAN_GROUP> TE <TY F,SFINAE_FOR_BIT_BS> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO F& f){CO U u_inv = m_M.Inverse(InitialSegmentSum(i_start - 1));RE max(i_start,Search([&](CO U& sum,CRI i){RE i_start <= i && f(m_M.Sum(u_inv,sum),i);}));}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CO U& u){RE Search([&](CO U& sum,CRI){RE !(sum < u);});}TE <TY U,TY ABELIAN_GROUP> IN int AbstractBIT<U,ABELIAN_GROUP>::Search(CRI i_start,CO U& u){RE max(i_start,Search(m_M.Sum(InitialSegmentSum(i_start - 1),u)));}TE <CL Traits,TY U,TY ABELIAN_GROUP> IN OS& OP<<(OS& os,AbstractBIT<U,ABELIAN_GROUP>& bit){auto&& SZ = bit.SZ();for(int i = 0;i < SZ;i++){(i == 0?os:os << " ")<< bit[i];}RE os;}

IN int GCD(){RE 0;}TE <TY INT1,TY...INT2>INT1 GCD(INT1 b_0,INT2... args){b_0 < 0?b_0 = -b_0:b_0;INT1 b_1 = GCD(MO(args)...);WH(b_1 != 0){swap(b_0 %= b_1,b_1);}RE MO(b_0);}TE <TY INT,TE <TY...> TY V>INT GCD(V<INT> a){INT AN = 0;for(auto& b:a){AN = GCD(MO(AN),MO(b));}RE AN;}IN int LCM(){RE 0;}TE <TY INT1,TY...INT2>INT1 LCM(INT1 b_0,INT2... args){b_0 < 0?b_0 = -b_0:b_0;INT1 b_1 = LCM(MO(args)...);RE b_1 == 0?b_0:b_0 / GCD(b_0,b_1)* b_1;}TE <TY INT,TE <TY...> TY V>INT LCM(V<INT> a){INT AN = 1;for(auto& b:a){AN = LCM(MO(AN),b);}RE AN;}

TE <TY INT,int SZ_max> IN bool NextPermutation(INT(&P)[SZ_max],CRI SZ){RE next_permutation(P,P + SZ);}TE <TY INT> IN bool NextPermutation(VE<INT>& P){RE next_permutation(P.BE(),P.EN());}TE <TY INT,int SZ_max> IN bool PreviousPermutation(INT(&P)[SZ_max],CRI SZ){RE prev_permutation(P,P + SZ);}TE <TY INT> IN bool PreviousPermutation(VE<INT>& P){RE prev_permutation(P.BE(),P.EN());}TE <TY INT>ll InversionNumber(CO VE<INT>& A){CO int SZ = A.SZ();BIT<int> count{SZ};ll AN = 0;for(int i = SZ - 1;i >= 0;i--){AN += count.IntervalSum(0,A[i]- 1);count.Add(A[i],1);}RE AN;}TE <TY INT>VE<VE<INT>> CyclicPermutationRepresentation(CO VE<INT>& P,CO bool& zero_indexed = true){if(!zero_indexed){auto Q = P;for(auto& i:Q){i--;}auto AN = CyclicPermutationRepresentation(Q);for(auto& C:AN){for(auto& i:C){i++;}}RE AN;}CO int SZ = P.SZ();VE<VE<INT>> AN{};VE<bool> found(SZ);for(int i = 0;i < SZ;i++){if(found[i]){continue;}VE<INT> temp ={i};found[i]= true;int j = P[i];WH(j != i){found[j]= true;temp.push_back(j);j = P[j];}if(temp.SZ()> 1){AN.push_back(MO(temp));}}RE AN;}TE <TY INT>VE<pair<INT,INT>> MinimalTranspositionRepresentation(CO VE<INT>& P,CO bool& zero_indexed = true){auto crp = CyclicPermutationRepresentation(P,zero_indexed);VE<pair<INT,INT>> AN{};for(auto& C:crp){CO int SZ = C.SZ();for(int i = SZ - 1;i > 0;i--){AN.push_back({C[0],C[i]});}}RE AN;}TE <TY INT>VE<pair<INT,INT>> MinimalAdjacentTranspositionRepresentation(VE<INT> P,CO bool& zero_indexed = true){CO int SZ = P.SZ();CO INT d = zero_indexed?0:1;VE<pair<INT,INT>> AN{};for(int i = 0;i < SZ;i++){for(int j = i - 1;j >= 0;j--){if(P[j]< P[j+1]){break;}swap(P[j],P[j+1]);AN.push_back({d+j,d+j+1});}}RE AN;}TE <TY INT>ll PermutationOrder(CO VE<INT>& P,CO bool& zero_indexed = true){auto crp = CyclicPermutationRepresentation(P,zero_indexed);CO int SZ = crp.SZ();VE<ll> order(SZ);for(int i = 0;i < SZ;i++){order[i]= crp[i].SZ();}RE LCM(order);}TE <TY INT>INT LeastSwapCount(CO VE<INT>& P,CO bool& zero_indexed = true){auto crp = CyclicPermutationRepresentation(P,zero_indexed);INT AN = 0;for(auto& C:crp){AN += C.SZ()- 1;}RE AN;}TE <TY INT> IN ll LeastAdjacentSwapCount(CO VE<INT>& P){RE InversionNumber(P);}
#endif

