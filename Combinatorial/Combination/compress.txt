#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/Combination/a_Body.hpp"
#else
// - intやllの時はオーバーフローしうることに注意。
// - Modは法pが素数でないと/の計算が合わないことに注意。
// - DyamicModはSetModuloでis_prime=trueを渡した時のみ/がメモ化再帰でO(1)で計算され、
//   一般には/がユークリッドの互除法でO(log_2 n)で計算されることに注意。
// CombinationCumulativeProduct(n,m) 均しO(1)（nごとに合計O(min(m,n-m))）
// CombinationCumulativeProductValuative<MOD>(n,m,factor) 均しO(L)（前計算O(log n)、nごとに合計O(min(m,n-m)(L+log min(m,n-m)))）
// CombinationFactorial(n,m) O(1)（前計算O(n)、n<=20）
// CombinationFactorialValuative<MOD>(n,m,factor) O(L)（前計算O(n(L+log n))）

TE <TY RET,TY INT>RET CombinationCumulativeProductRecursion(CO INT& n,CO INT& m,CO bool& reset){ST Map<INT,VE<RET>> memory{};auto& memory_n = memory[n];if(memory_n.empty()){memory_n.push_back(1);}INT SZ;WH((SZ = memory_n.SZ())<= m){memory_n.push_back(memory_n.back()*(n - SZ + 1)/ SZ);}if(reset){RET AN = memory_n[m];memory.erase(n);RE AN;}RE memory_n[m];}TE <TY RET,TY INT1,TY INT2> IN RET CombinationCumulativeProduct(CO INT1& n,INT2 m,CO bool& reset){CO INT1 m_copy = MO(m);RE m < 0 || n < m_copy?CombinationCumulativeProductRecursion<RET>(n,INT1{0},reset)- 1:CombinationCumulativeProductRecursion<RET>(n,min(m_copy,n - m_copy),reset);}TE <TY MOD,TY INT,TY VEC> IN pair<MOD,VE<int>> CombinationCumulativeProductValuativeRecursion(CO INT& n,CO INT& m,CO VEC& factor,CO bool& reset){ST CO int L = factor.SZ();AS(L == int(factor.SZ()));ST Map<INT,tuple<VE<MOD>,VE<VE<int>>>> memory{};if(n < m){if(reset){memory.erase(n);}RE{MOD{0},VE<int>(L)};}auto&[comb,EX]= memory[n];if(comb.empty()){comb.push_back(1);EX.push_back(VE<int>(L));}INT SZ;WH((SZ = comb.SZ())<= m){MOD c = comb.back();VE<int> e = EX.back();for(int num = 0;num < 2;num++){INT r = num == 0?n - SZ + 1:SZ;for(int i = 0;i < L;i++){auto& p = factor[i];WH(r % p == 0){r /= p;num == 0?++e[i]:--e[i];}}num == 0?c *= r:c /= r;}comb.push_back(MO(c));EX.push_back(MO(e));}if(reset){pair<MOD,VE<int>> AN{MO(comb[m]),MO(EX[m])};memory.erase(n);RE AN;}RE{comb[m],EX[m]};}TE <TY MOD,TY INT1,TY INT2,TY VEC> IN pair<MOD,VE<int>> CombinationCumulativeProductValuative(CO INT1& n,INT2 m,CO VEC& factor,CO bool& reset){CO INT1 m_copy = MO(m);RE CombinationCumulativeProductValuativeRecursion<MOD>(n,m < 0 || n < m_copy?n + 1:min(m_copy,n - m_copy),factor,reset);}TE <TY INT>INT CombinationFactorialRecursion(CO INT& n,CO INT& m){ST VE<INT> factorial{1};INT SZ;WH((SZ = factorial.SZ())<= n){factorial.push_back(factorial.back()* SZ);}RE factorial[n]/ factorial[m]/ factorial[n-m];}TE <TY INT1,TY INT2> IN INT1 CombinationFactorial(CO INT1& n,INT2 m){AS(((is_same_v<INT1,int> || is_same_v<INT1,uint>)&& n <= 12)||((is_same_v<INT1,ll> || is_same_v<INT1,ull>)&& n <= 20));CO INT1 m_copy = MO(m);RE m < 0 || n < m_copy?INT1(0):CombinationFactorialRecursion(n,m_copy);}TE <TY MOD,TY INT1,TY INT2,TY VEC>pair<MOD,VE<int>> CombinationFactorialValuativeRecursion(CO INT1& n,CO VE<INT2>& m,CO VEC& factor){ST CO int L = factor.SZ();AS(L == int(factor.SZ()));if(m.empty()){RE{MOD{1},VE<int>(L)};}CO INT1 sum = Sum<INT1>(m);if(n < sum || Min(m)< 0){RE{MOD{0},VE<int>(L)};}ST VE<MOD> factorial{1};ST VE<MOD> factorial_inv{1};ST VE EX(1,VE<int>(L));INT1 SZ;WH((SZ = factorial.SZ())<= n){VE<int> e = EX.back();for(int i = 0;i < L;i++){auto& p = factor[i];WH(SZ % p == 0){SZ /= p;e[i]++;}}factorial.push_back(factorial.back()* SZ);factorial_inv.push_back(factorial_inv.back()/ SZ);EX.push_back(MO(e));}MOD f = factorial[n];VE<int> e = EX[n];CO int M = m.SZ();for(int j = 0;j <= M;j++){CO int k = j < M?INT1(m[j]):n - sum;f *= factorial_inv[k];auto& denom = EX[k];for(int i = 0;i < L;i++){e[i]-= denom[i];}}RE{MO(f),MO(e)};}TE <TY MOD,TY INT1,TY INT2,TY VEC> IN pair<MOD,VE<int>> CombinationFactorialValuative(CO INT1& n,CO VE<INT2> m,CO VEC& factor){RE CombinationFactorialValuativeRecursion<MOD>(n,m,factor);}TE <TY MOD,TY INT1,TY INT2,TY VEC> IN pair<MOD,VE<int>> CombinationFactorialValuative(CO INT1& n,INT2 m,CO VEC& factor){RE CombinationFactorialValuativeRecursion<MOD>(n,VE<INT1>{MO(m)},factor);}

// PrimeEnumeration:
// val_limit = 316 ≒ sqrt(1e5) -> length = 65
// val_limit = 448 ≒ sqrt(2e5) -> length = 86
// val_limit = 1e5 -> length = 9592
// val_limit = 1e6 -> length = 78498
// nの素因数分解：PrimeFactorisation(CO PE/LD& pe,CO INT& n) O(√n/log n)/O(log n)
// nの素羃への分解：PrimePowerFactorisation(CO PE/LD& pe,CO int& n) O(√n/log n)/O(log n)
TE <int val_limit,int le_max = val_limit>CL PrimeEnumeration{PU:bool m_is_composite[val_limit];int m_val[le_max];int m_le;CE PrimeEnumeration();IN CRI OP[](CRI i)CO;CE CRI Get(CRI i)CO;CE CO bool& IsComposite(CRI n)CO;CE CRI length()CO NE;};
TE <int val_limit,int le_max> CE PrimeEnumeration<val_limit,le_max>::PrimeEnumeration():m_is_composite(),m_val(),m_le(0){for(int i = 2;i < val_limit;i++){if(! m_is_composite[i]){for(ll j = ll(i)* i;j < val_limit;j += i){m_is_composite[j]= true;}m_val[m_le++]= i;if(m_le >= le_max){break;}}}}TE <int val_limit,int le_max> IN CRI PrimeEnumeration<val_limit,le_max>::OP[](CRI i)CO{AS(0 <= i && i < m_le);RE m_val[i];}TE <int val_limit,int le_max> CE CRI PrimeEnumeration<val_limit,le_max>::Get(CRI i)CO{RE m_val[i];}TE <int val_limit,int le_max> CE CO bool& PrimeEnumeration<val_limit,le_max>::IsComposite(CRI n)CO{RE m_is_composite[n];}TE <int val_limit,int le_max> CE CRI PrimeEnumeration<val_limit,le_max>::length()CO NE{RE m_le;}
CL HeapPrimeEnumeration{PU:int m_val_limit;VE<bool> m_is_composite;VE<int> m_val;int m_le;IN HeapPrimeEnumeration(CRI val_limit);IN CRI OP[](CRI i)CO;IN CRI Get(CRI i)CO;IN bool IsComposite(CRI n)CO;IN CRI length()CO NE;};
IN HeapPrimeEnumeration::HeapPrimeEnumeration(CRI val_limit):m_val_limit(val_limit),m_is_composite(m_val_limit),m_val(),m_le(0){for(int i = 2;i < m_val_limit;i++){if(! m_is_composite[i]){for(ll j = ll(i)* i;j < val_limit;j += i){m_is_composite[j]= true;}m_val.push_back(i);}}m_le = m_val.SZ();}IN CRI HeapPrimeEnumeration::OP[](CRI i)CO{AS(0 <= i && i < m_le);RE m_val[i];}IN CRI HeapPrimeEnumeration::Get(CRI i)CO{RE OP[](i);}IN bool HeapPrimeEnumeration::IsComposite(CRI n)CO{AS(0 <= n && n < m_val_limit);RE m_is_composite[n];}IN CRI HeapPrimeEnumeration::length()CO NE{RE m_le;}

TE <TY PE> auto CheckPE(CO PE& pe)-> decltype(pe.IsComposite(0),true_type());TE <TY...> false_type CheckPE(...);TE <TY T>CE bool IsPE = decltype(CheckPE(declval<T>()))();

TE <int val_limit>CL LeastDivisor{PU:int m_val[val_limit];CE LeastDivisor()NE;IN CRI OP[](CRI i)CO;CE CRI Get(CRI i)CO;CE int length()CO NE;};
TE <int val_limit> CE LeastDivisor<val_limit>::LeastDivisor()NE:m_val{}{for(int d = 2;d < val_limit;d++){if(m_val[d]== 0){for(int n = d;n < val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}TE <int val_limit> IN CRI LeastDivisor<val_limit>::OP[](CRI i)CO{AS(0 <= i && i < val_limit);RE m_val[i];}TE <int val_limit> CE CRI LeastDivisor<val_limit>::Get(CRI i)CO{RE m_val[i];}TE <int val_limit> CE int LeastDivisor<val_limit>::length()CO NE{RE val_limit;}
CL HeapLeastDivisor{PU:int m_val_limit;VE<int> m_val;IN HeapLeastDivisor(CRI val_limit)NE;IN CRI OP[](CRI i)CO;IN CRI Get(CRI i)CO;IN CRI length()CO NE;};
IN HeapLeastDivisor::HeapLeastDivisor(CRI val_limit)NE:m_val_limit(val_limit),m_val(m_val_limit){for(int d = 2;d < m_val_limit;d++){if(m_val[d]== 0){for(int n = d;n < m_val_limit;n += d){m_val[n]== 0?m_val[n]= d:d;}}}}IN CRI HeapLeastDivisor::OP[](CRI i)CO{AS(0 <= i && i < m_val_limit);RE m_val[i];}IN CRI HeapLeastDivisor::Get(CRI i)CO{RE m_val[i];}IN CRI HeapLeastDivisor::length()CO NE{RE m_val_limit;}

TE <TY PE,TY INT>auto PrimeFactorisation(CO PE& pe,INT n)-> enable_if_t<IsPE<PE>,pair<VE<INT>,VE<int>>>{AS(n > 0);VE<INT> P{};VE<int> E{};CRI le = pe.length();for(int i = 0;i < le;i++){auto& p = pe[i];if(n % p == 0){int e = 1;WH((n /= p)% p == 0){e++;}P.push_back(p);E.push_back(e);}else if(n / p < p){break;}}if(n != 1){P.push_back(n);E.push_back(1);}RE{MO(P),MO(E)};}TE <TY LD>auto PrimeFactorisation(CO LD& ld,int n)-> enable_if_t<!IsPE<LD>,pair<VE<int>,VE<int>>>{AS(n > 0);VE<int> P{};VE<int> E{};if(n > 1){P.push_back(ld[n]);E.push_back(1);n /= ld[n];}WH(n > 1){if(P.back()!= ld[n]){P.push_back(ld[n]);E.push_back(1);}else{E.back()++;}n /= ld[n];}RE{MO(P),MO(E)};}TE <TY PE,TY INT>auto PrimePowerFactorisation(CO PE& pe,INT n)-> enable_if_t<IsPE<PE>,tuple<VE<INT>,VE<int>,VE<INT>>>{AS(n > 0);VE<INT> P{};VE<int> E{};VE<INT> Q{};CRI le = pe.length();for(int i = 0;i < le;i++){auto& p = pe[i];if(n % p == 0){int e = 1;INT q = p;WH((n /= p)% p == 0){e++;q *= p;}P.push_back(p);E.push_back(e);Q.push_back(q);}else if(n / p < p){break;}}if(n != 1){P.push_back(n);E.push_back(1);Q.push_back(n);}RE{MO(P),MO(E),MO(Q)};}TE <TY LD>auto PrimePowerFactorisation(CO LD& ld,int n)-> enable_if_t<!IsPE<LD>,tuple<VE<int>,VE<int>,VE<int>>>{AS(n > 0);VE<int> P{};VE<int> E{};VE<int> Q{};if(n > 1){P.push_back(ld[n]);E.push_back(1);Q.push_back(ld[n]);n /= ld[n];}WH(n > 1){if(P.back()!= ld[n]){P.push_back(ld[n]);E.push_back(1);Q.push_back(ld[n]);}else{Q.back()*= ld[n];E.back()++;}n /= ld[n];}RE{MO(P),MO(E),MO(Q)};}TE <TY PE,TY INT> bool IsPrime(CO PE& pe,CO INT& n){auto& L = pe.length();for(int i = 0;i < L && pe[i]* INT(pe[i])<= n;i++){if(n % pe[i]== 0){RE false;}}RE n > 1;}
#endif

