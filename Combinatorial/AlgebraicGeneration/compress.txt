#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/AlgebraicGeneration/a_Body.hpp"
#else
TE <TY MONOID,TY GROUP,TY FUNC,TY U = inner_t<MONOID>>CL AlgebraicGenerator{PU:MONOID m_M;GROUP m_G;FUNC m_f;VE<Map<U,pair<U,U>>> m_div;Map<U,int> m_len;int m_len_max;TE <TY V> AlgebraicGenerator(MONOID M,GROUP G,FUNC f,CO VE<V>& gen,CRI len);tuple<bool,VE<U>,VE<U>> Express(CO U& u,CO bool& opt_max);};
TE <TY MONOID,TY GROUP,TY FUNC,TY U> TE <TY V>AlgebraicGenerator<MONOID,GROUP,FUNC,U>::AlgebraicGenerator(MONOID M,GROUP G,FUNC f,CO VE<V>& gen,CRI len):m_M(MO(M)),m_G(MO(G)),m_f(MO(f)),m_div(2),m_len(),m_len_max(len){ST_AS(is_same_v<inner_t<MONOID>,U> && is_same_v<inner_t<GROUP>,U> && is_invocable_r_v<U,FUNC,CO U&> && is_COructible_v<U,V>);AS(len >= 1);CO U& one = m_M.One();m_div[0][one]={one,one};m_len[one];for(auto& s:gen){if(s != one){m_div[1][s]={s,one};m_len[s]= 1;}}for(int l = 2;l <= m_len_max;l++){m_div.push_back({});for(auto&[s,q]:m_div[1]){for(auto&[u,p]:m_div[l-1]){CO U su = m_M.Product(s,u);if(m_len.count(su)== 0){m_len[su]= l;m_div[l][su]={s,u};}}}}}TE <TY MONOID,TY GROUP,TY FUNC,TY U>tuple<bool,VE<U>,VE<U>> AlgebraicGenerator<MONOID,GROUP,FUNC,U>::Express(CO U& u,CO bool& opt_max){int l0 = 0,l_opt = -1;VE<VE<U>> v ={{},{}};WH(l0 <= m_len_max &&(l_opt == -1 || l0 < l_opt)){for(auto&[u0,p0]:m_div[l0]){CO U u1 = m_G.Product(m_G.Inverse(m_f(u0)),u);if(m_len.count(u1)> 0){auto& l1 = m_len[u1];if(l_opt == -1 ||(opt_max?l1:l0 + l1)< l_opt){l_opt = max(l0,l1);v ={{u0},{u1}};}}}l0++;}if(l_opt != -1){for(auto& vi:v){WH(!vi.empty()){auto& p = vi.back();auto& m = m_len[p];if(m > 1){auto&[p0,p1]= m_div[m][p];p = p0;vi.push_back(p1);}else if(m == 0){vi.pop_back();}else{break;}}}}RE{l_opt!=-1,MO(v[0]),MO(v[1])};}
#endif

