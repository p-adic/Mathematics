#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Interval/Costfree/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY U1,TY ABEL_GROUP1,TY U2,TY ABEL_GROUP2>pair<U1,U2> NonNegativeAbstractIntervalKnapsack(ABEL_GROUP1 M1,ABEL_GROUP2 M2,CRI N,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound,CRI diff_min,CRI diff_max){U1 value_sum = value[0];U2 cost_sum = cost[0];int l = 0,l_min = diff_min - diff_max,l_max = 0,r = 0;WH(r < diff_min){r++;value_sum = M2.Sum(MO(value_sum),value[r]);cost_sum = M1.Sum(MO(cost_sum),cost[r]);}pair<U1,U2> AN ={M1.Zero(),M2.Zero()};WH(true){CO bool over = cost_sum_bound < cost_sum || value_sum_bound < value_sum;!over &&(AN.first < value_sum ||(AN.first == value_sum && cost_sum < AN.second))?AN ={value_sum,cost_sum}:AN;if(l ==(over?l_max:l_min)){if(++r < N){++l_min,++l,++l_max;value_sum = M1.Sum(MO(value_sum),value[r]);cost_sum = M2.Sum(MO(cost_sum),cost[r]);}else{break;}}else{value_sum = M1.Sum(MO(value_sum),M2.Inverse(value[l]));cost_sum = M2.Sum(MO(cost_sum),M1.Inverse(cost[l]));++l;}}RE AN;}TE <TY U1,TY ABEL_GROUP1,TY U2,TY ABEL_GROUP2>pair<U1,U2> NegativeAbstractIntervalKnapsack(ABEL_GROUP1 M1,ABEL_GROUP2 M2,CRI N,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound,CRI diff_min,CRI diff_max){U1 value_sum = value[0];U2 cost_sum = cost[0];int l_min = diff_min - diff_max,l_max = 0,r = 0;WH(r < diff_min){r++;value_sum = M1.Sum(MO(value_sum),value[r]);cost_sum = M2.Sum(MO(cost_sum),cost[r]);}pair<U1,U2> AN ={M1.Zero(),M2.Zero()};WH(true){U1 value_sum_prev = value_sum;U2 cost_sum_prev = cost_sum;for(int l = max(0,l_min);l <= l_max;l++){!(cost_sum_bound < cost_sum || value_sum_bound < value_sum)&&(AN.first < value_sum ||(AN.first == value_sum && cost_sum < AN.second))?AN ={value_sum,cost_sum}:AN;value_sum = M1.Sum(MO(value_sum),M2.Inverse(value[l]));cost_sum = M2.Sum(MO(cost_sum),M1.Inverse(cost[l]));}if(++r < N){value_sum = M1.Sum(MO(value_sum_prev),l_min < 0?value[r]:M1.Sum(M1.Inverse(value[l_min]),value[r]));cost_sum = M2.Sum(MO(cost_sum_prev),l_min < 0?cost[r]:M2.Sum(M2.Inverse(cost[l_min]),cost[r]));++l_min,++l_max;}else{break;}}RE AN;}TE <TY U1,TY ABEL_GROUP1,TY U2,TY ABEL_GROUP2>pair<U1,U2> AbstractIntervalKnapsack(ABEL_GROUP1 M1,ABEL_GROUP2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound,CRI diff_min,int diff_max){CO int N = value.SZ();AS(int(cost.SZ())== N);AS(diff_min <=(diff_max == -1?diff_max = N - 1:diff_max));AS(diff_max < N);bool non_negative = true;CO U1& zero1 = M1.Zero();for(auto& v:value){non_negative &= zero1 < v;}CO U2& zero2 = M2.Zero();for(auto& c:cost){non_negative &= zero2 < c;}RE non_negative?NonNegativeAbstractIntervalKnapsack(MO(M1),MO(M2),N,value,value_sum_bound,cost,CO_Sum_bound,diff_min,diff_max):NegativeAbstractIntervalKnapsack(MO(M1),MO(M2),N,value,value_sum_bound,cost,CO_Sum_bound,diff_min,diff_max);}TE <TY INT1,TY INT2> IN pair<INT1,INT2> IntervalKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound,CRI diff_min = 0,int diff_max){RE AbstractIntervalKnapsack(AddiiveGroup<INT1>(),AddiiveGroup<INT2>(),value,value_sum_bound,cost,cost_sum_bound,diff_min,MO(diff_max));}

TE <TY U,TY ABEL_GROUP> IN U AbstractIntervalCostfreeKnapsack(ABEL_GROUP M,CO VE<U>& value,CO U& value_sum_bound,CRI diff_min,int diff_max){RE AbstractIntervalKnapsack(AddiiveGroup<int>(),M,value,value_sum_bound,VE<int>(value.SZ()),int(0),diff_min,MO(diff_max));}TE <TY INT> IN INT IntervalCostfreeKnapsack(CO VE<INT>& value,CO INT& value_sum_bound,CRI diff_min,int diff_max){RE AbstractIntervalCostfreeKnapsack(AddiiveGroup<INT>(),value,value_sum_bound,diff_min,MO(diff_max));}
#endif
