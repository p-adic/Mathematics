#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Value/a_Body.hpp"
#else
TE <TY INT> CE INT Log(INT N){INT AN = 0,pw = 1;WH(N > pw){pw <<= 1;AN++;}RE AN;}

TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractNegativeValueCostwiseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE AN(cost_sum_bound + 1,exceptional);AN[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(value_i != exceptional);AS(cost_i >= 0);for(INT c = cost_sum_bound;c >= cost_i;c--){auto& AN_c_minus = AN[c - cost_i];if(AN_c_minus != exceptional){auto temp = M.Product(AN_c_minus,value_i);AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> NegativeValueCostwiseKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueCostwiseKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}

TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueKnapsackFewCosts(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractNegativeValueCostwiseKnapsack(MO(M),value,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional &&(AN.first < v_c ||(AN.first == v_c && c < AN.second))?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();RE Log(ll(cost_sum_bound))< ll(N >> 1)?AbstractNegativeValueKnapsackFewCosts(MO(M),value,exceptional,cost,cost_sum_bound):AbstractNegativeBoundedValueSumKnapsack(M,value,AbstractValueSumBound(M,value),cost,cost_sum_bound);}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeValueKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}
#endif
