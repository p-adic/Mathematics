#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Subsetwise/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>VE<pair<U1,U2>> AbstractNegativeBitExhausiveSeachForKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CRI N,CO VE<U1>& value,CO VE<U2>& cost){int PW = 1 << N;VE<pair<U1,U2>> product(PW,{M1.One(),M2.One()});for(int i = 0;i < N;i++){int p = 1 << i;for(int j = p;j < PW;(++j)|= p){auto&[v,w]= product[j ^ p];product[j]={M1.Product(v,value[i]),M2.Product(w,cost[i])};}}RE product;};TE <TY U1,TY U2>VE<pair<U1,U2>> AbstractNegativeFastZetaTransformForKnapsack(CRI N,CO U1& one1,VE<pair<U1,U2>> product,CO U1& value_sum_bound,CO U2& cost_sum_bound){for(auto&[v,w]:product){value_sum_bound < v || cost_sum_bound < w?v = one1:v;}CO int PW = 1 << N;int p = 1;for(int i = 0;i < N;i++,p <<= 1){int j = p;WH(j < PW){auto&[v_j,w_j]= product[j];auto&[v_j_prev,w_j_prev]= product[j ^ p];v_j < v_j_prev?(v_j = v_j_prev,w_j = w_j_prev):v_j == v_j_prev && w_j_prev < w_j?w_j = w_j_prev:w_j;(++j)|= p;}}RE product;}TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>VE<pair<U1,U2>> AbstractNegativeBoundedValueSumSubsetwiseKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N && N < 30);CO U1 one1 = M1.One();auto product = AbstractNegativeBitExhausiveSeachForKnapsack(MO(M1),MO(M2),N,value,cost);RE AbstractNegativeFastZetaTransformForKnapsack(N,one1,MO(product),value_sum_bound,cost_sum_bound);}TE <TY INT1,TY INT2> IN VE<pair<INT1,INT2>> NegativeBoundedValueSumSubsetwiseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeBoundedValueSumSubsetwiseKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}
#endif
