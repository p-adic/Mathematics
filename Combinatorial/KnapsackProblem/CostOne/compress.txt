#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/CostOne/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID>pair<U,int> AbstractValueCostOneKnapsack(COMM_MONOID M,CO VE<U>& value,CO VE<int>& cost_sum_bound){CO int N = value.SZ();AS(N == int(cost_sum_bound.SZ()));CO U& one = M.One();multiset<U> opt{};for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_sum_bound_i = cost_sum_bound[i];AS(0 <= cost_sum_bound_i);if(one < value_i){opt.insert(value_i);WH(int(opt.SZ())> cost_sum_bound_i){opt.erase(opt.BE());}}}U sum = one;for(auto& v:opt){sum = M.Product(MO(sum),v);}RE{sum,opt.SZ()};}TE <TY INT> IN pair<INT,int> CostOneKnapsack(CO VE<INT>& value,CO VE<int>& cost_sum_bound){RE AbstractValueCostOneKnapsack(AdditiveMonoid<INT>(),value,cost_sum_bound);}TE <TY U,TY ABEL_GROUP>VE<pair<U,int>> AbstractValueCostOneItemwiseKnapsack(ABEL_GROUP M,CO VE<U>& value,CO VE<int>& cost_sum_bound){CO int N = value.SZ();AS(N == int(cost_sum_bound));CO U& one = M.One();U sum = one;multiset<U> opt{};VE<pair<U,int>> AN(N);for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_sum_bound_i = cost_sum_bound[i];AS(0 <= cost_sum_bound_i);if(one < value_i){opt.insert(value_i);sum = M.Product(MO(sum),value_i);WH(int(opt.SZ())> cost_sum_bound_i){auto IT = opt.BE();sum = M.Product(MO(sum),M.Inverse(*IT));opt.erase(IT);}}AN[i]={sum,opt.SZ()};}RE AN;}TE <TY INT> IN VE<pair<INT,int>> CostOneItemwiseKnapsack(CO VE<INT>& value,CO VE<int>& cost_sum_bound){RE AbstractValueCostOneItemwiseKnapsack(AdditiveGroup<INT>(),value,cost_sum_bound);}
#endif

