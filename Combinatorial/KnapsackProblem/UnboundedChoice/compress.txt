#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/UnboundedChoice/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY INT>VE<U> AbstractNegativeValueUnboundedChoiceCostwiseKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);auto& one = M.One();VE<U> value_max(cost_sum_bound + 1,exceptional);value_max[0]= one;for(int i = 0;i < N;i++){auto& value_i = value[i];auto& cost_i = cost[i];AS(0 < cost_i ||(cost_i == 0 && !(one < value_i)));if(cost_i <= cost_sum_bound){auto& value_max_i = value_max[cost_i];value_max_i = value_max_i == exceptional?value_i:max(value_max[cost_i],value_i);}}auto AN = value_max;for(INT d = 1;d < cost_sum_bound;d++){auto& value_max_d = value_max[d];if(value_max_d == exceptional){continue;}for(INT c = d + d;c <= cost_sum_bound;c++){auto temp = M.Product(AN[c - d],value_max_d);if(!(temp < one)){AS(temp != exceptional);auto& AN_c = AN[c];AN_c = AN_c == exceptional?MO(temp):max(AN_c,temp);}}}RE AN;}TE <TY INT1,TY INT2> IN VE<INT1> NegativeValueUnboundedChoiceCostwiseKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueUnboundedChoiceCostwiseKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}TE <TY U,TY COMM_MONOID,TY INT> IN pair<U,INT> AbstractNegativeValueUnboundedChoiceKnapsack(COMM_MONOID M,CO VE<U>& value,CO U& exceptional,CO VE<INT>& cost,CO INT& cost_sum_bound){pair<U,INT> AN ={M.One(),0};auto value_max = AbstractNegativeValueUnboundedChoiceCostwiseKnapsack(MO(M),value,exceptional,cost,cost_sum_bound);for(INT c = 0;c <= cost_sum_bound;c++){auto& v_c = value_max[c];v_c != exceptional && AN.first < v_c?AN ={MO(v_c),c}:AN;}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeValueUnboundedChoiceKnapsack(CO VE<INT1>& value,CO INT1& exceptional,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeValueUnboundedChoiceKnapsack(AdditiveMonoid<INT1>(),value,exceptional,cost,cost_sum_bound);}

TE <TY INT1,TY INT2>pair<INT1,INT2> UnboundedChoiceKnapsackFewValues(CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound){US T = Pair<INT2,INT1>;VE<T> rate{};int N = value.SZ();AS(N == int(cost.SZ()));if(N == 0){RE{0,0};}for(int i = 0;i < N;i++){AS(cost[i]== 0?value[i]== 0:0 < cost[i]&& 0 < value[i]);if(0 < value[i]){rate <<={cost[i],value[i]};}}sort(rate.BE(),rate.EN(),[&](CO T& r0,CO T& r1){RE r0[O]* r1[I]< r1[O]* r0[I];});N = rate.SZ();INT1 val_sum = 0;for(int i = 1;i < N;i++){val_sum += rate[i][I]* min(rate[0][O],cost_sum_bound / rate[i][O]);}VE<INT2> cost_min(val_sum + 1,cost_sum_bound + 1);cost_min[0]= 0;for(int i = 1;i < N;i++){for(INT1 v = rate[i][I];v <= val_sum;v++){SetMin(cost_min[v],min(cost_min[v-rate[i][I]]+ rate[i][O],cost_sum_bound + 1));}}pair<INT1,INT2> AN{};for(INT1 v = 0;v <= val_sum;v++){if(cost_min[v]<= cost_sum_bound){CO INT2 c =(cost_sum_bound - cost_min[v])/ rate[0][O],w_temp = cost_min[v]+ c * rate[0][O];CO INT1 v_temp = v + c * rate[0][I];SetMax(AN,pair{v_temp,w_temp});}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> UnboundedChoiceKnapsack(CO VE<INT1>& value,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE len(value)+ static_cast<double>(cost_sum_bound)* cost_sum_bound < Sum<double>(value)* Max(cost)?NegativeValueUnboundedChoiceKnapsack(value,INT1(-1),cost,cost_sum_bound):UnboundedChoiceKnapsackFewValues(value,cost,cost_sum_bound);}
#endif

