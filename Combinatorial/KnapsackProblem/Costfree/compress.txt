#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Costfree/a_Body.hpp"
#else
TE <TY INT>INT CostfreeKnapsackFewValues(CRI N,CO VE<INT>& value,CO INT& value_bound,CO INT& value_sum_bound){INT AN = 0;int i = -1;WH(++i < N && AN <= value_sum_bound){auto& value_i = value[i];AS(0 <= value_i && value_i <= value_bound);AN += value[i];}if(i == N){RE AN;}CO INT value_bound2 = value_bound << 1;VE<INT> u(value_bound2,-1);for(INT v = value_bound;v < value_bound2;v++){u[v]= 0;}u[AN -= value[i-1]+(value_sum_bound - value_bound + 1)]= i - 1;WH(++i < N){auto& value_i = value[i];AS(0 <= value_i && value_i <= value_bound);auto u_prev = u;for(INT v = 0;v < value_bound;v++){auto& u_v_i = u[v + value_i];u_v_i = max(u_v_i,u_prev[v]);}for(INT v = value_bound2 - 1;v >= value_bound;v--){auto& j_ulim = u[v];for(INT j = u_prev[v];j < j_ulim;j++){auto& u_v_j = u[v - value[j]];u_v_j = max(u_v_j,j);}}}for(INT v = value_bound - 1;v >= 0;v--){if(u[v]!= -1){RE v +(value_sum_bound - value_bound + 1);}}abort();RE -1;}TE <TY U,TY COMM_MONOID>U AbstractCostfreeKnapsackFewItems(COMM_MONOID M,CO VE<U>& value,CO U& value_bound,CO U& value_sum_bound){CO int N = value.SZ();CO U& one = M.One();AS(!(value_sum_bound < one));U AN = one;if(N == 1){if(!(value_sum_bound < value[0])){AN = value[0];}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<U> value_sum_left(PW_left,one);for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;value_sum_left[s]= M.Product(value_sum_left[s ^ lsb],value[valuation[lsb]]);}CO int PW_right = 1 << N_half_right;VE<U> value_sum_right(PW_right,one);for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;auto& value_sum_right_s = value_sum_right[s]= M.Product(value_sum_right[s ^ lsb],value[N_half_left + valuation[lsb]]);value_sum_bound < value_sum_right_s?value_sum_right_s = one:value_sum_right_s;}sort(value_sum_right.BE(),value_sum_right.EN());for(int s = 0;s < PW_left;s++){auto& value_sum_left_s = value_sum_left[s];if(!(value_sum_bound < value_sum_left_s)){BS2(t,0,PW_right - 1,M.Product(value_sum_left_s,value_sum_right[t]),value_sum_bound);AN = max(AN,M.Product(value_sum_left_s,value_sum_right[t]));}}}RE AN;}TE <TY INT> IN INT CostfreeKnapsack(CO VE<INT>& value,CO INT& value_bound,CO INT& value_sum_bound){AS(1 <= value_bound && value_bound <= value_sum_bound);CO int N = value.SZ();RE value_bound >>(N >> 1)== 0?CostfreeKnapsackFewValues(N,value,value_bound,value_sum_bound):AbstractCostfreeKnapsackFewItems(AdditiveMonoid<INT>(),value,value_bound,value_sum_bound);}
#endif
