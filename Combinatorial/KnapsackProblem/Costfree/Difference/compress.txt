// 多重ループの非再帰版
#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Costfree/Difference/a_Body.hpp"
#else
TE <TY T> IN TY set<T>::const_iterator MaximumLeq(CO set<T>& S,CO T& t){auto IT = S.upper_bound(t);RE IT == S.BE()?S.EN():--IT;}TE <TY T> IN TY set<T>::const_iterator MinimumGeq(CO set<T>& S,CO T& t){RE S.lower_bound(t);}

TE <TY INT>INT CostfreeDifferenceKnapsack(CO VE<INT>& value,CO INT& value_bound,int SZ_diff_bound = 0){CO int N = value.SZ();AS(N >= 1 + max(0,1 - SZ_diff_bound));INT value_sum_bound = 0;SZ_diff_bound = min(SZ_diff_bound,N);VE<ll> Comb(N + 1,1);ll comb_sum = Comb[0];for(int i = 1;i <= SZ_diff_bound;i++){if((comb_sum += Comb[i]= Comb[i-1]*(N - 1 - i)/ i)>(value_sum_bound += value_bound)){RE 0;}}for(int i = SZ_diff_bound + 1;i <= N;i++){if(Comb[i - SZ_diff_bound - 1]<(Comb[i]= Comb[i-1]*(N - 1 - i)/ i)){if((comb_sum += Comb[i]- Comb[i - SZ_diff_bound - 1])>(value_sum_bound += value_bound)){RE 0;}}else{break;}}CO int N_back = N / 2;CO int N_front = N - N_back;VE<set<int>> S(N_back + 1);VE<int> lower_bound(N_back,-1),upper_bound(N_back,1),index = lower_bound,one(1,1);one.resize(N_back);INT AN = value_bound;bool valid = true;WH(valid){INT temp = 0;int SZ_diff = 0;for(int i = 0;i < N_back;i++){temp += value[i + N_front]* index[i];SZ_diff += index[i];}valid = NextLoopEq(lower_bound,upper_bound,index);if(SZ_diff >= 0){if(SZ_diff == 0 && temp == 0){if(index == one){continue;}RE 0;}S[SZ_diff].insert(temp);if(SZ_diff <= SZ_diff_bound){AN = min(AN,abs(temp));}}}lower_bound.resize(N_front,-1),upper_bound.resize(N_front,1),index = lower_bound,one.resize(N_front);valid = true;WH(valid){INT temp = 0;int SZ_diff = 0;for(int i = 0;i < N_front;i++){temp += value[i]* index[i];SZ_diff += index[i];}valid = NextLoopEq(lower_bound,upper_bound,index);if(SZ_diff == 0 && temp == 0){if(index == one){continue;}RE 0;}CO int SZ_min = max(0,-SZ_diff - SZ_diff_bound);CO int SZ_max = min(N_back,-SZ_diff + SZ_diff_bound);for(int SZ = SZ_min;SZ <= SZ_max;SZ++){CO set<int>& s = S[SZ];auto IT = MaximumLeq(s,-temp);auto EN = s.EN();if(IT != EN){AN = min(AN,abs(*IT + temp));}IT = MinimumGeq(s,-temp);if(IT != EN){AN = min(AN,abs(*IT + temp));}}if(abs(SZ_diff)<= SZ_diff_bound){AN = min(AN,abs(temp));}}RE AN;}
#endif

// 多重ループの再帰版（遲い）
// #ifdef DEBUG
//   #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Costfree/Difference/a_Body.hpp"
// #else
// TE <TY T> IN TY set<T>::const_iterator MaximumLeq(CO set<T>& S,CO T& t){auto IT = S.upper_bound(t);RE IT == S.BE()?S.EN():--IT;}TE <TY T> IN TY set<T>::const_iterator MinimumGeq(CO set<T>& S,CO T& t){RE S.lower_bound(t);}
// 
// TE <TY INT,TY Arg,TY BEFORE,TY AFTER>Arg ExecuteLoop(CRI SZ,CO VE<INT>& lower_bound,CO VE<INT>& upper_limit,CRI d,Arg&& arg,CO BEFORE& before,CO AFTER& after){ST_AS(is_invocable_r_v<Arg,BEFORE,CRI,CRI,CO Arg&> && is_invocable_v<AFTER,CRI,CRI,CO Arg&>);if(d + 1 < SZ){for(INT i = lower_bound[d];i < upper_limit[d];i++){after(d,i,ExecuteLoop(SZ,lower_bound,upper_limit,d + 1,before(d,i,arg),before,after));}}else{for(INT i = lower_bound[d];i < upper_limit[d];i++){after(d,i,before(d,i,arg));}}RE MO(arg);}TE <TY INT,TY Arg,TY BEFORE,TY AFTER> IN Arg ExecuteLoop(CO VE<INT>& lower_bound,CO VE<INT>& upper_limit,Arg&& arg,CO BEFORE& before,CO AFTER& after){RE ExecuteLoop(lower_bound.SZ(),lower_bound,upper_limit,0,MO(arg),before,after);}TE <TY INT,TY Arg,TY BEFORE,TY AFTER>Arg ExecuteLoopEq(CRI SZ,CO VE<INT>& lower_bound,CO VE<INT>& upper_bound,CRI d,Arg&& arg,CO BEFORE& before,CO AFTER& after){ST_AS(is_invocable_r_v<Arg,BEFORE,CRI,CRI,CO Arg&> && is_invocable_v<AFTER,CRI,CRI,CO Arg&>);if(d + 1 < SZ){for(INT i = lower_bound[d];i <= upper_bound[d];i++){after(d,i,ExecuteLoopEq(SZ,lower_bound,upper_bound,d + 1,before(d,i,arg),before,after));}}else{for(INT i = lower_bound[d];i <= upper_bound[d];i++){after(d,i,before(d,i,arg));}}RE MO(arg);}TE <TY INT,TY Arg,TY BEFORE,TY AFTER> IN Arg ExecuteLoopEq(CO VE<INT>& lower_bound,CO VE<INT>& upper_bound,Arg&& arg,CO BEFORE& before,CO AFTER& after){RE ExecuteLoopEq(lower_bound.SZ(),lower_bound,upper_bound,0,MO(arg),before,after);}
// 
// TE <TY INT>INT CostfreeDifferenceKnapsack(CO VE<INT>& value,CO INT& value_bound,int SZ_diff_bound = 0){CO int N = value.SZ();AS(N >= 1 + max(0,1 - SZ_diff_bound));INT value_sum_bound = 0;SZ_diff_bound = min(SZ_diff_bound,N);VE<ll> Comb(N + 1,1);ll comb_sum = Comb[0];for(int i = 1;i <= SZ_diff_bound;i++){if((comb_sum += Comb[i]= Comb[i-1]*(N - 1 - i)/ i)>(value_sum_bound += value_bound)){RE 0;}}for(int i = SZ_diff_bound + 1;i <= N;i++){if(Comb[i - SZ_diff_bound - 1]<(Comb[i]= Comb[i-1]*(N - 1 - i)/ i)){if((comb_sum += Comb[i]- Comb[i - SZ_diff_bound - 1])>(value_sum_bound += value_bound)){RE 0;}}else{break;}}CO int N_back = N / 2;CO int N_front = N - N_back;VE<set<int>> S(N_back + 1);VE<int> lower_bound(N_back,-1),upper_bound(N_back,1);INT AN = value_bound;int count = 0;auto before_back =[&](CRI i,CRI sign,CO T2<int>& v){RE T2<int>{v.first + value[i+N_front]* sign,v.second + sign};};auto after_back =[&](CRI i,CRI sign,CO T2<int>& v){if(i < N_back - 1){RE;}auto&[temp,SZ_diff]= v;if(SZ_diff < 0){RE;}if(SZ_diff == 0 && temp == 0){if(count++ != 0){AN = 0;}RE;}S[SZ_diff].insert(temp);if(SZ_diff <= SZ_diff_bound){AN = min(AN,abs(temp));}RE;};ExecuteLoopEq(lower_bound,upper_bound,T2<int>{0,0},before_back,after_back);lower_bound.resize(N_front,-1),upper_bound.resize(N_front,1);count = 0;auto before_front =[&](CRI i,CRI sign,CO T2<int>& v){RE T2<int>{v.first + value[i]* sign,v.second + sign};};auto after_front =[&](CRI i,CRI sign,CO T2<int>& v){if(i < N_front - 1){RE;}auto&[temp,SZ_diff]= v;if(SZ_diff == 0 && temp == 0){if(count++ != 0){AN = 0;}RE;}CO int SZ_min = max(0,-SZ_diff - SZ_diff_bound);CO int SZ_max = min(N_back,-SZ_diff + SZ_diff_bound);for(int SZ = SZ_min;SZ <= SZ_max;SZ++){CO set<int>& s = S[SZ];auto IT = MaximumLeq(s,-temp);auto EN = s.EN();if(IT != EN){AN = min(AN,abs(*IT + temp));}IT = MinimumGeq(s,-temp);if(IT != EN){AN = min(AN,abs(*IT + temp));}}if(abs(SZ_diff)<= SZ_diff_bound){AN = min(AN,abs(temp));}RE;};ExecuteLoopEq(lower_bound,upper_bound,T2<int>{0,0},before_front,after_front);RE AN;}
// #endif

