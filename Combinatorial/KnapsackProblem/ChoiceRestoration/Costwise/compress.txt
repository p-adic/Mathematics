#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/ChoiceRestoration/Costwise/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID,TY INT>CL AbstractValueKnapsackChoiceRestoration{PU:COMM_MONOID m_M;VE<INT> m_cost;INT m_cost_sum_bound;int m_N;VE<VE<int>> m_prev;VE<VE<pair<U,int>>> m_curr;AbstractValueKnapsackChoiceRestoration(COMM_MONOID M,CO VE<U>& value,VE<INT> cost,CO INT& cost_sum_bound);tuple<U,INT,VE<int>> Get(CRI L,CO INT& cost_sum_max);};TE <TY INT1,TY INT2>CL KnapsackChoiceRestoration:PU AbstractValueKnapsackChoiceRestoration<INT1,AdditiveMonoid<INT1>,INT2>{PU:IN KnapsackChoiceRestoration(CO VE<INT1>& value,VE<INT2> cost,CO INT2& cost_sum_bound);};
TE <TY U,TY COMM_MONOID,TY INT>AbstractValueKnapsackChoiceRestoration<U,COMM_MONOID,INT>::AbstractValueKnapsackChoiceRestoration(COMM_MONOID M,CO VE<U>& value,VE<INT> cost,CO INT& cost_sum_bound):m_M(MO(M)),m_cost(MO(cost)),m_cost_sum_bound(cost_sum_bound),m_N(value.SZ()),m_prev(m_N + 1,VE(m_cost_sum_bound + 1,-1)),m_curr(m_N + 1,VE(m_cost_sum_bound + 1,pair{m_M.One(),-1})){ST_AS(is_same_v<inner_t<COMM_MONOID>,U>);AS(int(m_cost.SZ())== m_N);CO U& one = m_M.One();if(m_N > 0){for(int i = 0;i < m_N;i++){AS(!(value[i]< one || m_cost[i]< INT(0)));m_curr[i+1]= m_curr[i];if(m_cost_sum_bound < m_cost[i]){continue;}for(int cost_sum = m_cost[i];cost_sum <= m_cost_sum_bound;cost_sum++){auto&[v,j]= m_curr[i][cost_sum - m_cost[i]];if(j != -1 || cost_sum == m_cost[i]){m_prev[i+1][cost_sum]= j;auto&[opt,k]= m_curr[i+1][cost_sum];U temp = m_M.Product(v,value[i]);if(k == -1 || opt < temp){opt = MO(temp);k = i;}}}}}}TE <TY INT1,TY INT2> IN KnapsackChoiceRestoration<INT1,INT2>::KnapsackChoiceRestoration(CO VE<INT1>& value,VE<INT2> cost,CO INT2& cost_sum_bound):AbstractValueKnapsackChoiceRestoration<INT1,AdditiveMonoid<INT1>,INT2>(AdditiveMonoid<INT1>(),value,MO(cost),cost_sum_bound){}TE <TY U,TY COMM_MONOID,TY INT>tuple<U,INT,VE<int>> AbstractValueKnapsackChoiceRestoration<U,COMM_MONOID,INT>::Get(CRI L,CO INT& cost_sum_max){AS(0 <= L && L <= m_N && 0 <= cost_sum_max && cost_sum_max <= m_cost_sum_bound);U opt = m_M.One();INT w = 0;int last = -1;for(int cost_sum = 0;cost_sum <= cost_sum_max;cost_sum++){auto&[temp,i]= m_curr[L][cost_sum];if(opt < temp){opt = temp;w = cost_sum;last = i;}}VE<int> choice{};INT cost_sum = w;WH(last != -1){choice.push_back(last);int i = m_prev[last+1][cost_sum];cost_sum -= m_cost[last];last = i;}AS(cost_sum == INT(0));RE{MO(opt),w,MO(choice)};}
#endif

